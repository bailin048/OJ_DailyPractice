LeetCode【24】【两两交换链表中的节点】：https://leetcode-cn.com/problems/swap-nodes-in-pairs/
【递归法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next)
        return head;
        struct ListNode *newhead = head->next;
        head->next = swapPairs(newhead->next);
        newhead->next = head;
        return newhead;
    }
};
【迭代法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* rear = dummyHead;
        while(rear->next != nullptr && rear->next->next != nullptr ){
            ListNode *node1 = rear->next;
            ListNode *node2 = rear->next->next;
            rear->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            rear = node1;
        }
        return dummyHead->next;
    }
};

LeetCode【41】【缺失的第一个正数】：https://leetcode-cn.com/problems/first-missing-positive/
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0;i < n; i++){
            while(nums[i]>0 && nums[i]<=n && nums[nums[i]-1] != nums[i])
                swap(nums[i],nums[nums[i]-1]);
        }
        for(int i = 0;i < n; i++)
            if(nums[i]!=i+1)
                return i+1;
        return n+1;
    }
};

面试题【17.16】【按摩师】：https://leetcode-cn.com/problems/the-masseuse-lcci/
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n==0)
            return 0;
        if(n==1)
            return nums[0];
        if(n==2)
            return fmax(nums[0],nums[1]);
        int dp0 = nums[0],dp1 = fmax(nums[0],nums[1]),dp2 = 0;
        for(int i = 2;i<n;i++){
            dp2 = fmax(dp1,dp0+nums[i]);
            dp0 = dp1;
            dp1 = dp2; 
        }
        return dp2;
    }
};

面试题【16.01】【交换数字】：https://leetcode-cn.com/problems/swap-numbers-lcci/
class Solution {
public:
    vector<int> swapNumbers(vector<int>& numbers) {
        numbers[0]^=numbers[1];
        numbers[1]^=numbers[0];
        numbers[0]^=numbers[1];
        return numbers;
    }
};

面试题【17.10】【主要元素】：https://leetcode-cn.com/problems/find-majority-element-lcci/
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int sum = 0,flag = 0,i;
        for(int i=0;i<n;i++){
            if(sum<=0){
                flag = nums[i];
                ++sum;
            }
            else{
                nums[i] == flag?++sum:--sum;
            }
        }
        int cnt = 0;
        for(int  i =0;i<n;i++)
            if(flag == nums[i])
                cnt++;
        return cnt>n/2?flag:-1;
    }
};

LeetCode【961】【重复N次的元素】：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/
class Solution {
public:
    int repeatedNTimes(vector<int>& A) {
        int n = A.size(),flag = 0;
        for(int i = 1; i<n-1;++i){
            if(A[i] == A[i-1] || A[i] == A[i+1]){
                flag = i;
                break;
            }
            if(A[i-1] == A[i+1]){
                flag = i - 1;
                break;
            }
        }
        return A[flag];
    }
};

剑指offer【43】【1~n整数中1出现的次数】：https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/
class Solution {
public:
    int countDigitOne(int n) {
         int count = 0;
    long digit = 1;
    int cur=n%10,high = n/10,low = 0;
    while(high != 0 || cur != 0){
        if(cur == 0)
            count += high*digit;
        else if(cur == 1)
            count += high*digit+low+1;
        else
            count += (high+1)*digit;
        low += cur*digit;
        cur = high % 10;
        high/=10;
        digit *= 10;
    }
    return count;
    }
};

剑指offer【54】【二叉搜索树的第k大的节点】：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/
public:
    void NumofNode(TreeNode* root,int *n){
        if(!root)
            return;
        (*n)++;
        NumofNode(root->left,n);
        NumofNode(root->right,n);
        return; 
    }
    void midorder(TreeNode* root,int *arg,int* index){
        if(!root)
            return;
        midorder(root->left,arg,index);
        arg[*index] = root->val;
        (*index)++;
        midorder(root->right,arg,index);
        return;
    }
    int kthLargest(TreeNode* root, int k) {
        int n = 0;
        NumofNode(root,&n);
        int* arg = (int*)malloc(sizeof(int)*n);
        int index = 0;
        midorder(root,arg,&index);
        return arg[n-k];
    }
};

剑指offer【63】【股票的最大利润】：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(!n)
            return 0;
        int buy = prices[0];
        int Max = 0;
        int* profit = (int*)malloc(sizeof(int)*n);
        for(int i = 1; i < n; i++){
            buy = prices[i]<buy?prices[i]:buy;
            profit[i] = prices[i]-buy;
            Max = Max < profit[i]?profit[i]:Max;
        }
        return Max;
    }
};

LeetCode【129】【求根节点到叶节点数字之和】：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/
class Solution {
public:
    void NumofLeaf(TreeNode* root,int* count){
        if(!root)
            return;
        if((!root->left) && (!root->right))
            (*count)++;
        NumofLeaf(root->left,count);
        NumofLeaf(root->right,count);
        return;
    }
    void helper(TreeNode* root,int* tmp,int* index, int num){
        if(!root)
            return;
        if((!root->left) && (!root->right)){
            tmp[(*index)] = num*10+root->val;
            (*index)++;
        }
        num = num*10 + root->val;
        helper(root->left,tmp,index,num);
        helper(root->right,tmp,index,num);
        return;
    }
    int sumNumbers(TreeNode* root) {
        int count = 0;
        NumofLeaf(root,&count);
        int* tmp = (int*)malloc(sizeof(int)*count);
        int index = 0;
        helper(root,tmp,&index,0);
        int sum = 0;
        for(int  i = 0;i<index;i++)
            sum+=tmp[i];
        return sum;
    }
};

LeetCode【222】【完全二叉树的节点个数】：https://leetcode-cn.com/problems/count-complete-tree-nodes/
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root)
            return 0;
        return countNodes(root->left)+countNodes(root->right)+1;
    }
};

LeetCode【543】【二叉树的直径】：https://leetcode-cn.com/problems/diameter-of-binary-tree/
class Solution {
public:
    int helper(TreeNode* root,int& ans){
        if(!root)
            return 0;
        int l = helper(root->left,ans);
        int r = helper(root->right,ans);
        ans = max(l + r, ans);
        return max(l, r) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int length = 0;
        helper(root,length);
        return length;
    }
};

剑指offer【64】【求1+2+3+……+n】：https://leetcode-cn.com/problems/qiu-12n-lcof/
class Solution {
public:
    int sumNums(int n) {
        int res = 0;
        for(int  i = 0;i<14;i++)//将n+1拆分为2的幂和
        {
            int tmp = (n&-((n+1)>>i&1))<<i;
            res += tmp;
        }
        return res>>1;
    }
};

牛客【计算日期到天数转换】：https://www.nowcoder.com/practice/769d45d455fe40b385ba32f97e7bcded?tpId=37&tqId=21296&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fhuawei%2Fquestion-ranking&tab=answerKey
#include <iostream>
using namespace std;

int OrderofDay(int year,int month,int day){
    int res = 0 , _month = 1;
    int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
    bool flag = false;
    if(year%400==0 || (year%4==0 && year%100!=0))
        flag = true;
    if(year<1 || month<1 ||  month>12 || day<1 || day>31 || 
       (flag && month == 2 && day>29) || ((!flag) && month == 2 && day>28))
            return -1;
    while(_month && _month<month){
        res += days[_month];
        if(flag && _month==2)
            ++res;
        ++_month;
    }
    return res + day;
}
int main(){
    int y,m,d;
    while(cin>>y>>m>>d)
        cout<<OrderofDay(y, m, d)<<endl;
    return 0;
}

牛客【日期累加】：https://www.nowcoder.com/practice/eebb2983b7bf40408a1360efb33f9e5d?tpId=40&tqId=31013&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fkaoyan%2Fquestion-ranking&tab=answerKey
#include <iostream>
#include <stdio.h>
using namespace std;
bool IsLeapYear(int y){
    if(y%400==0 || (y%4==0 && y%100!=0))
        return true;
    return false;
}
int GetDayofMonth(int year,int month){
    int _days[13]={29,31,28,31,30,31,30,31,31,30,31,30,31};
    bool flag = IsLeapYear(year);
    if(flag && month == 2)
        return _days[0];
    return _days[month];
}
void DateAddDay(int y,int m,int d,int day){
    d += day;
    while(d > GetDayofMonth(y,m)){
        d-=GetDayofMonth(y,m);
        ++m;
        if(m == 13)
            ++y,m=1;
    }
    printf("%04d-%02d-%02d\n",y,m,d);
}
int main(){
    int group = 0;
    cin>>group;
    int y,m,d,day;
    for(int i = 0;i<group;i++){
        cin>>y>>m>>d>>day;
        DateAddDay(y, m,d,day);
    }
    return 0;
}

牛客【打印日期】：https://www.nowcoder.com/practice/b1f7a77416194fd3abd63737cdfcf82b?tpId=69&tqId=29669&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fhust-kaoyan%2Fquestion-ranking&tab=answerKey
#include <iostream>
using namespace std;
bool IsLeapYear(int y){
    if(y%400==0 || (y%4==0 && y%100!=0))
        return true;
    return false;
}
int GetDayofMonth(int year,int month){
    int _days[13]={29,31,28,31,30,31,30,31,31,30,31,30,31};
    bool flag = IsLeapYear(year);
    if(flag && month == 2)
        return _days[0];
    return _days[month];
}
void PrintDate(int year,int day){
    int month = 1;
    while(day>GetDayofMonth(year, month)){
        day -= GetDayofMonth(year, month);
        ++month;
        if(month == 13)
            month = 1,++year;
    }
    printf("%04d-%02d-%02d\n",year,month,day);
}
int main(){
    int year,day;
    while(cin>>year>>day)
        PrintDate(year,day);
    return 0;
}

牛客【日期差值】：https://www.nowcoder.com/practice/ccb7383c76fc48d2bbc27a2a6319631c?tpId=62&tqId=29468&rp=1&ru=&tab=answerKey
#include <iostream>
using namespace std;
bool IsLeapYear(int year);
namespace Days {//申请13个的目的：月份=索引
    int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31 };
};

using namespace Days;
class Date
{
    friend bool IsLeapYear(int year);
public:
    int GetMonthDay(int year, int month) {
        bool  flag = IsLeapYear(year);
        return (flag&& month==2)?days[month]+1:days[month];//闰年2月+1天
    }
    void DateShow() {
        cout << _year << "年" << _month << "月" << _day << "日" << endl;
    }
    Date(int year = 1900, int month = 1, int day = 1) {    //全缺省默认构造函数
        _year = year;
        _month = month;
        _day = day;
    }
    Date(const Date &t) {// 拷贝构造函数
        _year = t._year;
        _month = t._month;
        _day = t._day;
    }
    Date& operator=(const Date& d) {//赋值运算符重载
        if (this != &d) {
            _year = d._year;
            _month = d._month;
            _day = d._day;
        }
        return *this;
    }
    ~Date() {}
    Date& operator+=(int day) {
        *this = *this + day;
        return *this;
    }
    Date operator+(int day) {
        Date p(*this);
        if (day < 0) {
            p -= -day;
            return p;
        }
        p._day += day;
        while (p._day > GetMonthDay(p._year, p._month)) {
            p._day -= GetMonthDay(p._year, p._month);
            ++p._month;
            if (p._month == 13) {
                p._month = 1;
                ++p._year;
            }
        }
        return p;
    }
    Date operator-(int day) {
        Date p(*this);//新对象
        if (day < 0) {
            p += -day;
            return p;
        }
        p._day -= day;
        int month = 0;
        while (p._day <= 0) {
            month = p._month == 1 ? 12 : p._month - 1;//月份为1则减到上一年12月
            p._day += GetMonthDay(p._year, month);//加上上一月天数
            --p._month;//月份倒退
            if (p._month == 0) {//年份倒退
                p._month = 12;
                --p._year;
            }
        }
        return p;
    }
    Date& operator-=(int day) {
        *this = *this - day;
        return *this;
    }
    Date& operator++() {
        *this = *this + 1;
        return *this;
    }
    Date operator++(int) {
        Date tmp(*this);
        *this += 1;
        return tmp;
    }
    Date operator--(int) {
        Date tmp(*this);
        *this -= 1;
        return tmp;
    }
    Date& operator--() {
        *this -= 1;
        return *this;
    }
    bool operator>(const Date& d) {
        if (d._year > (*this)._year)
            return false;
        if (d._year < (*this)._year)
            return true;
        if (d._month > (*this)._month)//到达此处，说明年份一样
            return false;
        if (d._month < (*this)._month)
            return true;
        if (d._day > (*this)._day)//达到此处，说明月份一样
            return false;
        if (d._day < (*this)._day)
            return true;
        return true;
    }
    bool operator==(const Date& d) {
        return d._year == (*this)._year &&
            d._month == (*this)._month &&
            d._day == (*this)._day;
    }
    inline bool operator >= (const Date& d) {
        return *this > d || *this == d;
    }
    bool operator < (const Date& d) {
        return !(*this >= d);//<的互斥函数为>=
    }
    bool operator <= (const Date& d) {
        return !(*this > d);//<= 的互斥事件为>
    }
    bool operator != (const Date& d) {
        return !((*this) == d);//!= 的互斥事件为 ==
    }
    int operator-(const Date& d) {
        Date Min;
        Date Max;
        *this < d ? (Max = d, Min = *this) :(Max = *this, Min = d);
        int res = 0;
        while (Min < Max)
            ++res, ++Min;
        return ++res;
    }
private:
    int _year;
    int _month;
    int _day;
};
bool IsLeapYear(int year) {
    if (year % 4 == 0 && year % 100 != 0)//普通闰年
        return true;
    if (year % 400 == 0)//世纪闰年
        return true;
    return false;
}
int main(){
    int data1,data2;
    int y1,y2,m1,m2,d1,d2;
    while(cin>>data1,cin>>data2){
        d1 = data1%100,d2 = data2%100;
        m1 = data1/100%100,m2 = data2/100%100;
        y1 = data1/10000,y2 = data2/10000;
        Date D1(y1,m1,d1);
        Date D2(y2,m2,d2);
        cout<<D2-D1<<endl;
    }
}

LeetCode【230】【二叉搜索树中第K小的元素】：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/
class Solution {
public:
    void helper(TreeNode* root,int k,int* res,int* index){
        if(!root)
            return;
        helper(root->left,k,res,index);
        (*index)++;
        if(*index == k)
            *res = root->val;
        helper(root->right,k,res,index);
        return;
    } 
    int kthSmallest(TreeNode* root, int k) {
        int res = INT_MIN;
        int index = 0; 
        helper(root,k,&res,&index);
        return res;
    }
};

LeetCode【671】【二叉树中第二小的节点】：https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/
class Solution {
public:
    void helper(TreeNode* root,int* tmp,int* index){
        if(!root)
            return;
        helper(root->left,tmp,index);
        tmp[*index] = root->val;
        (*index)++;
        helper(root->right,tmp,index);
    }
    int findSecondMinimumValue(TreeNode* root) {
        int* tmp = new int[25];
        int index = 0;
        int res = -1;
        helper(root,tmp,&index);
        int dk = index;
        while(dk/=2){
            for(int i = dk;i<index;i++){
                if(tmp[i-dk]>tmp[i]){
                    int n = tmp[i],j;
                    for(j = i-dk;j>-1&&tmp[j]>n;j-=dk)
                        tmp[j+dk] = tmp[j];
                    tmp[j+dk] = n;
                }
            }
        }
        for(int i = 0;i<index;i++)
            if(tmp[i]!=root->val){
                res = tmp[i];
                break;
            }
        delete []tmp;
        return res;
    }
};

LeetCode【108】【将有序数组转换为二叉搜索树】：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/
class Solution {
public:
    TreeNode* helper(vector<int>& nums, int left, int right){
        if(left>right)
            return nullptr;
        int mid = left + (right-left)/2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = helper(nums, left, mid-1);
        root->right = helper(nums, mid+1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums, 0,nums.size()-1);
    }
};

LeetCode【700】【二叉搜索树中的搜索】：https://leetcode-cn.com/problems/search-in-a-binary-search-tree/
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root || root->val ==    val)
            return root;
        return  val < root->val ? searchBST(root->left, val) : searchBST(root->right, val);
    }
};

LeetCode【653】【两数之和IV-输入BST】：https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/
class Solution {
public:
    void helper(TreeNode* root,int* res,int* index){
        if(!root)
            return;
        helper(root->left,res,index);
        res[*index] = root->val;
        (*index)++;
        helper(root->right,res,index);
    } 
    bool findTarget(TreeNode* root, int k) {
        int* res = new int[10000];
        int index = 0;
        helper(root,res,&index);
        int left = 0,right = index - 1;
        while(left<right){
            if(res[left] + res[right] > k)
                --right;
            else if(res[left] + res[right] < k)
                ++left;
            else
                return true;
        }
        return false;
    }
};

LeetCode【563】【二叉树的坡度】：https://leetcode-cn.com/problems/binary-tree-tilt/
class Solution {
public:
    int res = 0;
    int helper(TreeNode* root){
        if(!root)
            return 0;
        int left = helper(root->left);
        int right = helper(root->right);
        res += fabs(left-right);
        return left + right + root->val;
    } 
    int findTilt(TreeNode* root) {
        helper(root);
        return res;
    }
};

剑指offer【31】【栈的压入、弹出序列】：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/
bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){
    int* stack = (int*)malloc(sizeof(int)*poppedSize);
    int top = -1;
    int index = 0;
    for(int i = 0;i<pushedSize;i++){
        stack[++top] = pushed[i];
        while(top!=-1 && stack[top]==popped[index])
            --top,++index;
    }
    return top == -1;
}

LeetCode【704】【二分查找】：https://leetcode-cn.com/problems/binary-search/
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0,right = n - 1;
        while(left<=right){
            int mid = left + (right-left)/2;
            if(nums[mid]>target)
                right = mid - 1;
            else if(nums[mid]<target)
                left = mid + 1;
            else
                return mid;
        }
        return -1;
    }
};

LeetCode【11】【盛最多水的容器】：https://leetcode-cn.com/problems/container-with-most-water/
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int left = 0,right = n - 1,max = 0;
        while(left<right){
            int tmp = (right-left)*fmin(height[left],height[right]);
            max = tmp > max ? tmp:max;
            if(height[left]<=height[right])
                ++left;
            else
                --right; 
        }
        return max;
    }
};

LeetCode【33】【搜索旋转排序数组】:https://leetcode-cn.com/problems/search-in-rotated-sorted-array/
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if(!n)
            return -1;
        if(n == 1)
            return target == nums[0]?0:-1;
        int left = 0,right = n - 1;
        while(left<=right){
            int mid = left + (right-left)/2;
            if(target == nums[mid])
                return mid;
            if(nums[0]<=nums[mid]){
                if(nums[0] <= target && target < nums[mid])
                    right = mid - 1;
                else
                    left = mid + 1;
            }
            else{
                if(nums[mid]<target && target <= nums[n-1])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
};

LeetCode【80】【删除排序数组中的重复项II】：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n<2)
            return n;
        int j = 1,cnt = 1;
        for(int i = 1;i<n;i++){
            if(nums[i] == nums[i-1])
                ++cnt;
            else
                cnt = 1;
            if (cnt <= 2) {
                nums[j++] = nums[i];
            }
        }
        return j;
    }
};

LeetCode【82】【删除排序链表的重复元素】：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next)
            return head;
        ListNode* tmp = new ListNode(0,head);
        ListNode* cur = tmp;
        while(cur->next && cur->next->next){
            if(cur->next->val == cur->next->next->val){
                int x = cur->next->val;
                while(cur->next && cur->next->val == x)
                    cur->next = cur->next->next;
            }
            else
                cur = cur->next;
        }
        return tmp->next;
    }
};

LeetCode【922】【按奇偶排序数组】：https://leetcode-cn.com/problems/sort-array-by-parity-ii/
class Solution {
public:
    void swap(int& x,int& y){
        int tmp = x;
        x = y;
        y = tmp;
    } 
    vector<int> sortArrayByParityII(vector<int>& nums) {
        int n = nums.size();
        int j = 1;
        for (int i = 0; i < n; i += 2) {
            if (nums[i] % 2 == 1) {
                while (nums[j] % 2 == 1) {
                    j += 2;
                }
                swap(nums[i], nums[j]);
            }
        }   
        return nums;
    }
};

LeetCode【287】【寻找重复数】：https://leetcode-cn.com/problems/find-the-duplicate-number/
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int numSize = nums.size();
        int* cnt = new int[numSize-1];
        int i = 0;
        for(;i<numSize-1;i++)
            cnt[i] = 0;
        for(i = 0;i<numSize;i++){
            if(cnt[nums[i]-1]==0)
                cnt[nums[i]-1] = 1;
            else
                break;
        }
        delete[]cnt;
        return nums[i];
    }
};

LeetCode【92】【反转链表II】：https://leetcode-cn.com/problems/reverse-linked-list-ii/
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(!head->next || left == right)
            return head;
        ListNode* dummy = new ListNode(0,head);  
        ListNode* pre = dummy;
        int index = 0;
        while(index!=left-1){//找到反转之前的节点
            ++index;
            pre = pre->next;
        }
        ListNode* end = pre->next;
        ListNode* t = end->next;
        ListNode* rear = t->next;
        while(left<right){
            t->next = pre->next;
            end->next = rear;
            pre->next = t;
            t = rear;
            if(rear)
                rear = rear->next;
            --right;
        }
        head = dummy->next;
        delete dummy;
        return  head;
    }
};

LeetCode【61】【旋转链表】：https://leetcode-cn.com/problems/rotate-list/
class Solution {
public:
    int helper(ListNode* head,ListNode*& connect){
        int res = 0;
        ListNode* tmp = head;
        while(tmp){
            ++res;
            connect = tmp;
            tmp = tmp->next;
        }
        return res;
    }
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return head;
        ListNode* connect = nullptr;
        int size = helper(head,connect);
        k %= size;
        if(!k)
            return head;
        int cnt = 0;
        ListNode* tail = head;
        while(cnt!=size - k-1){
            ++cnt;
            tail = tail->next;
        }
        ListNode* newhead = tail->next;
        tail->next = nullptr;
        connect->next = head;
        return newhead;
    }
};

LeetCode【771】【宝石与石头】：https://leetcode-cn.com/problems/jewels-and-stones/
class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        int sz1 = jewels.size();
        int sz2 = stones.size();
        int* flag = new int[128];
        for(int i = 0;i<128;i++)
            flag[i] = 0;
        for(int i = 0;i<sz1;i++)
            flag[jewels[i]] = 1;
        for(int i = 0;i<sz2;i++)
            if(flag[stones[i]]!=0)
                flag[stones[i]]++;
        int res = -sz1;
        for(int i = 0;i<128;i++)
            res+=flag[i];
        return res;
    }
};

LeetCode【796】【旋转字符串】：https://leetcode-cn.com/problems/rotate-string/
class Solution {
public:
    bool rotateString(string A, string B) {
        int sz1 = A.size(),sz2 = B.size();
        if(sz1 != sz2)
            return false;
        if(!sz1)
            return true;
        return (B+B).find(A)!=-1;
    }
};

LeetCode【345】【反转字符串中的原因字符】：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/
class Solution {
public:
    bool IsVowels(char& s){
        if(s == 'a' || s == 'e' || s == 'i' || s == 'o' || s == 'u')
            return true;
        if(s == 'A' || s == 'E' || s == 'I' || s == 'O' || s == 'U')
            return true;
        return false;
    }
    string reverseVowels(string s) {
        int n = s.size();
        if(n<2)
            return s;
        int left = 0,right = n - 1;
        while(left<right){
            if(!IsVowels(s[left]))
                ++left;
            if(!IsVowels(s[right]))
                --right;
            if(IsVowels(s[left])&&IsVowels(s[right])){
                char tmp = s[left];
                s[left++] = s[right];
                s[right--] = tmp;
            }
        }
        return s;
    }
};

LeetCode【86】【分隔链表】：https://leetcode-cn.com/problems/partition-list/
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if(!head || !head->next)
            return head;
        ListNode* dummy = new ListNode(-1,head);
        ListNode* start = dummy;
        while(start&&start->next&&start->next->val<x)//令pre指向第一个>=x的节点的前一个节点
            start = start->next;
        if(!start)
            return dummy->next;
        ListNode* target = start->next;
        ListNode* prev = start;
        ListNode* rear = start;
        while(rear){
            while(target&&target->val >= x){//向后寻找小于x的节点
                prev = target;//小于x节点的前一节点
                target = target->next;
            }
            if(!target)
                break; 
            if(target){//定位后续链表
                rear = target->next;
                prev->next = rear;
                target->next = start->next;
                start->next = target;
                start = start->next;
                target = rear;
            }
        }
        head = dummy->next;
        delete dummy;
        return head;
    }
};

LeetCode【73】【矩阵置零】：https://leetcode-cn.com/problems/set-matrix-zeroes/
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(),n = matrix[0].size();
        int* row = new int[m];
        int* col = new int[n];
        for(int i = 0;i < m; i++){
            for(int j = 0;j < n; j++)
                if(!matrix[i][j]){
                    row[i] = 1;
                    col[j] = 1;
                }
        }
        for(int  i = 0;i<m;i++)
            if(row[i]==1){
                for(int j = 0;j<n;j++)
                    matrix[i][j] = 0;
            }
        for(int j = 0;j<n;j++)
            if(col[j]==1){
                for(int i = 0;i<m;i++)
                    matrix[i][j]=0;
            }
        delete[]col;
        delete[]row;
    }
};

LeetCode【233】【数字1的个数】：https://leetcode-cn.com/problems/number-of-digit-one/
class Solution {
public:
    int countDigitOne(int n) {
        long digit = 1;
        int high = n/10,low = 0,cur = n%10; 
        int count = 0;
        while(high||cur){
            if(!cur)
                count += high*digit;
            else if(cur == 1)
                count += high*digit+low+1;
            else
                count += (high+1)*digit;
            low+=cur*digit;
            cur = high%10;
            high/=10;
            digit*=10;
        }
        return count;
    }
};

LeetCode【75】【颜色分类】：https://leetcode-cn.com/problems/sort-colors/
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int* cnt = new int[3];
        cnt[0]=cnt[1]=cnt[2]=0;
        int n = nums.size();
        for(int i = 0;i < n;i++)
            cnt[nums[i]]++;
        int i = 0,j = 0; 
        while(i<3){
            if(cnt[i]--)
                nums[j++]=i;
            else
                i++;
        }
    }
};

LeetCode【274】【H指数】：https://leetcode-cn.com/problems/h-index/
class Solution {
public:
    void AdjustDown(vector<int>& citations,int parent,int n){
        int child = parent*2+1;
        int tmp = citations[parent];
        while(child<n){
            if(child+1<n && citations[child+1]<citations[child])
                ++child;
            if(tmp<=citations[child])
                break;
            citations[parent] =citations[child];
            parent = child;
            child = parent*2+1;
        }
        citations[parent]=tmp;
    }
    void HeapSort(vector<int>& citations){
        int n = citations.size();
        int curpos = n/2-1;
        while(curpos>=0){//建成最大堆
            AdjustDown(citations,curpos,n);
            curpos--;
        }
        for(int i = n - 1;i>0;i--){
            int tmp = citations[0];
            citations[0] = citations[i];
            citations[i] = tmp;
            AdjustDown(citations,0,i);
        }
    }
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        HeapSort(citations);
        int i=0;
        while (i < n && citations[i] > i) 
            i++;
        return i;
    }
};

LeetCode【275】【H指数II】：https://leetcode-cn.com/problems/h-index-ii/
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        int i=0;
        while (i < n && citations[n-1-i] > i) 
            i++;
        return i;
    }
};

LeetCode【12】【整数转罗马数字】：https://leetcode-cn.com/problems/integer-to-roman/
class Solution {
public:
    string intToRoman(int num) {
        string thousands[] = {"","M","MM","MMM"};
        string hundreds[] = {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
        string tens[] = {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
        string ones[] = {"","I","II","III","IV","V","VI","VII","VIII","IX"};
        int thousands_digit = num/1000;
        int hundreds_digit = num/100%10;
        int tens_digit = num/10%10;
        int ones_digit = num%10;
        return thousands[thousands_digit]+hundreds[hundreds_digit]+tens[tens_digit]+ones[ones_digit];
    }
};

LeetCode【338】【比特位计数】：https://leetcode-cn.com/problems/counting-bits/submissions/
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res(num+1);
        res[0] = 0;
        for(int i = 1;i<=num;++i){
            if(i&1)
                res[i]=res[i-1]+1;
            else
                res[i] = res[i>>1];
        }
        return res;
    }
};

LeetCode【665】【非递减数列】：https://leetcode-cn.com/problems/non-decreasing-array/submissions/
class Solution {
public:
    bool checkPossibility(vector<int>& nums) {
       int n = nums.size();
       int cnt = 0;
       for(int i = 1;i<n;i++){
            if(nums[i]<nums[i-1]){
                if(i == 1 || nums[i]>=nums[i-2])
                    nums[i-1] = nums[i];
                else
                    nums[i] = nums[i-1];
                ++cnt;
            }
       }
       return cnt<=1;
    }
};

LeetCode【872】【叶子相似的树】：https://leetcode-cn.com/problems/leaf-similar-trees/submissions/
class Solution {
public:
    void helper(vector<int>& leaf,TreeNode* root){
        if(!root)
            return;
        if(!root->left&&!root->right)
            leaf.push_back(root->val);
        helper(leaf,root->left);
        helper(leaf,root->right);
    }
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        vector<int> leaf1;
        vector<int> leaf2;
        helper(leaf1,root1);
        helper(leaf2,root2);
        return leaf1==leaf2;
    }
};

LeetCode【628】【三个数的最大乘积】：https://leetcode-cn.com/problems/maximum-product-of-three-numbers/
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end());
        return max(nums[0]*nums[1]*nums[n-1],nums[n-3]*nums[n-2]*nums[n-1]);
    }
};

LeetCode【74】【搜索二维矩阵】：https://leetcode-cn.com/problems/search-a-2d-matrix/submissions/
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = matrix.size();
        int col = matrix[0].size();
        for(int i = 0;i < row;++i){
            for(int j = col - 1;j>=0;--j){
                if(target>matrix[i][j])
                    break;
                else if(target == matrix[i][j])
                    return true;
            }
        }
        return false;
    }
};

LeetCode【面试题17.14】【最小k个数】：https://leetcode-cn.com/problems/smallest-k-lcci/
class Solution {
public:
    void AdjustDown(vector<int>& arr,int parent,int n){
        int tmp = arr[parent];
        int child = parent*2+1;
        while(child<n){
            if(child+1<n&&arr[child+1]>arr[child])//寻找最大的孩子
                ++child;
            if(tmp>=arr[child])
                break;
            arr[parent] = arr[child];
            parent = child;
            child = parent*2+1;
        }
        arr[parent]= tmp;
    }
    vector<int> smallestK(vector<int>& arr, int k) {
        vector<int>res(arr.begin(),arr.begin()+k); 
        if(!k)
            return res;

        for(int i = k/2-1;i>=0;--i)//大根堆
            AdjustDown(res,i,k);

        int n = arr.size();
        for(int i = k;i < n;i++){
            if(arr[i]<res[0]){//小于最大的数
                res[0] = arr[i];
                AdjustDown(res,0,k);
            }
        }
        return res;
    }
};

LeetCode【707】【设计链表】：https://leetcode-cn.com/problems/design-linked-list/
class MyLinkedList {
public:
    typedef struct Node{
        int val;
        Node* next;
        Node(int data):val(data),next(nullptr){}
    }Node;
public:
    /** Initialize your data structure here. */
    MyLinkedList() {
        m_head = new Node(0);
        m_size = 0;
    }
    
    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
    int get(int index) {
        if(index<0 || index>m_size-1)
            return -1;
        Node* p = m_head->next;
        while(index--)
           p = p->next;
        return p->val;
    }
    
    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
    void addAtHead(int val) {
        Node* p = new Node(val);
        p->next = m_head->next;
        m_head->next = p;
        ++m_size;
    }
    
    /** Append a node of value val to the last element of the linked list. */
    void addAtTail(int val) {
        Node* p = m_head;
        Node* q = new Node(val);
        while(p->next)
            p = p->next;
        p->next = q;
        ++m_size;
    }
    
    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
    void addAtIndex(int index, int val) {
        if(index > m_size)
            return;
        Node* p = m_head;
        while(index--)
            p = p->next;
        Node* q = new Node(val);
        q->next = p->next;
        p->next = q;
        ++m_size;
    }
    
    /** Delete the index-th node in the linked list, if the index is valid. */
    void deleteAtIndex(int index) {
        if(index<0 || index>=m_size)
            return;
        Node* p = m_head;
        while(index--)
            p = p->next;
        Node* tmp = p->next;
        p->next = tmp->next;
        delete tmp;
        --m_size;
    }
private:
    Node* m_head;
    int m_size;
};

【1161】【最大层内元素和】：https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree/submissions/
class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        queue<TreeNode*> Q;
        int sum_pre = INT_MIN,sum_rear = 0;
        Q.push(root);
        int sz = 1;
        int layer = 0,h = 0;
        while(!Q.empty()){
            ++h;
            while(sz){
                TreeNode* tmp = Q.front();
                sum_rear += tmp->val;
                if(tmp->left)
                    Q.push(tmp->left);
                if(tmp->right)
                    Q.push(tmp->right);
                Q.pop();
                --sz;
            }
            sz = Q.size();
            sum_pre = sum_rear>sum_pre?(layer = h,sum_rear):sum_pre;
            sum_rear = 0;
        }
        return layer;
    }
};

LeetCode【889】【根据前序和后序遍历构造二叉树】：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
class Solution {
public:
    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {
        int len_pre = pre.size();
        if(!len_pre) return nullptr;
        TreeNode* root = new TreeNode(pre[0]);
        if(len_pre == 1) return root;

        int i = 0;
        for(;i<len_pre;++i)
            if(post[i] == pre[1])
                break;

        vector<int> newLeftPre(pre.begin()+1, pre.begin()+i+2);
        vector<int> newLeftPos(post.begin(), post.begin()+i+1);
        vector<int> newRightPre(pre.begin()+i+2, pre.end());
        vector<int> newRightPos(post.begin()+i+1, post.end()-1);

        root->left = constructFromPrePost(newLeftPre, newLeftPos);
        root->right = constructFromPrePost(newRightPre, newRightPos);
        return root;
    }
};

LeetCode【541】【	反转字符串II】：https://leetcode-cn.com/problems/reverse-string-ii/submissions/
class Solution {
public:
    string reverseStr(string s, int k) {
        int len = s.size();
        for(int i = 0;i<len;i+=(2*k)){
            if(i+k <= len){
                reverse(s.begin()+i,s.begin()+i+k);
                continue;
            }
            reverse(s.begin()+i,s.end());
        }
        return s;
    }
};

LeetCode【557】【反转字符串中的单词III】：https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/
class Solution {
public:
    void Swap(char*& s1,char*& s2){
        char tmp = *s1;
        *s1 = *s2;
        *s2 = tmp;
    }
    string reverseWords(string s) {
        char* start = (char*)s.c_str();
        while(*start){
            while(*start && isspace(*start))
                ++start;
            char* end = start;
            while(*end && !isspace(*end))
                ++end;
            char* tmp = end; 
            --end;
            int len = (end - start) + 1;
            if(*start){
                for(int i = 0;i<len/2;++i){
                    Swap(start,end);
                    start++,--end;
                }
            }
            start = tmp;
        }
        return s;
    }
};

剑指offer【35】【复杂链表的复制】：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(!head)
            return nullptr;
        Node* tmp = head;
        while(tmp){
            Node* des = new Node(tmp->val);//拷贝值
            des->next = tmp->next;//插入旧链
            des->random = tmp->random;//暂指旧链random 
            tmp->next = des;//完成节点插入
            tmp = des->next;  //旧链后移
        }
        tmp = head->next;
        while(tmp){//纠正random
            if(tmp->random)
                tmp->random = tmp->random->next;
            if(tmp->next)
                tmp = tmp->next->next;
            else
                break;
        }
        tmp = head;
        Node* newhead = head->next;
        Node* newtmp = newhead;
        while(tmp){//分离两链
            tmp->next = newtmp->next;
            tmp = tmp->next;
            if(tmp){
                newtmp->next = tmp->next;
                newtmp = newtmp->next;
            } 
        }
        return newhead;
    }
};

剑指offer【14】【剪绳子-II】：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/
class Solution {
public:
    int cuttingRope(int n) {
        if(n<=3)
            return n-1;
        long res = 1;
        while(n>4){
            n-=3;
            res=res*3%1000000007;
        }
        res = res*n%1000000007;
        return res;
    }
};

LeetCode【260】【只出现一次的数字】：https://leetcode-cn.com/problems/single-number-iii/
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        vector<int> res(2,0);
        for(int i =0;i<nums.size();++i)
            res[0]^=nums[i];
        res[1] = res[0];
        int flag = 0;
        for(;flag<32;++flag)
            if(res[0]>>flag&1)
                break;
        for(int i = 0;i<nums.size();++i){
            if(nums[i]>>flag&1)
                res[0]^=nums[i];
        }
        res[1]^=res[0];
        return res;
    }
};

LeetCode【137】【只出现一次的数字II】：https://leetcode-cn.com/problems/single-number-ii/
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0;i<32;++i){
            int cnt = 0;
            for(int num :nums)
                cnt += (num>>i)&1;
            cnt%=3;
            res += cnt<<i;
        }
        return res;
    }
};

LeetCode【215】【数组中的第K个最大元素】：https://leetcode-cn.com/problems/single-number-ii/
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> q(nums.begin(),nums.end());
        for(int i = 0;i<k-1;++i)
            q.pop();
        return q.top();
    }
};

LeetCode【114】【二叉树展开为链表】：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
class Solution {
public:
    void pre_order(TreeNode* root,queue<TreeNode*>& Q){
        if(!root)
            return;
        Q.push(root);
        pre_order(root->left,Q);
        pre_order(root->right,Q);
    }
    void flatten(TreeNode* root) {
        queue<TreeNode*> Q;
        pre_order(root,Q);
        while(!Q.empty()){
            TreeNode* p = Q.front();
            Q.pop();
            p->left = nullptr;
            p->right = Q.empty()?nullptr:Q.front();
        }
    }
};

LeetCode【116】【填充每个节点的下一个右侧节点指针】：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/
class Solution {
public:
    Node* connect(Node* root) {
        if(!root)
            return nullptr;
        queue<Node*> Q;
        Q.push(root);
        while(!Q.empty()){
            int sz = Q.size();
            for(int i = 0;i<sz;++i){
                Node* p = Q.front();
                Q.pop();
                if(i<sz-1)
                    p->next = Q.front();
                if(p->left)
                    Q.push(p->left);
                if(p->right)
                    Q.push(p->right);
            }
        }
        return root;
    }
};
【方法2】：
class Solution {
public:
    Node* connect(Node* root) {
        if(!root)
            return nullptr;
        Node* temp = root;
        while(temp->left){
            Node* head = temp;
            while(head){
                head->left->next = head->right;
                if(head->next)
                    head->right->next =  head->next->left;
                head = head->next;
            }
            temp = temp->left; 
        }
        return root;
    }
};

LeetCode【378】【有序矩阵中第k小的元素】：https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/
class Solution {
public:
    bool check(vector<vector<int>>& matrix,int& mid,int& k){
        int n = matrix.size();
        int cnt = 0;
        int i = n-1,j = 0;
        while(i>=0&&j<n){
            if(matrix[i][j]<=mid){
                cnt += i+1;
                ++j;
            }else
                --i;
        }
        return cnt>=k;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n = matrix.size();
        int left = matrix[0][0],right = matrix[n-1][n-1];
        while(left<right){
            int mid = left + ((right-left)>>1);
            if(check(matrix,mid,k))
                right = mid;
            else
                left = mid + 1;
        }
        return left;
    }
};

LeetCode【31】【下一个排列】：https://leetcode-cn.com/problems/next-permutation/
class Solution {
public:
    void swap(int& a,int& b){
        int tmp = a;
        a = b;
        b = tmp;
    } 
    void nextPermutation(vector<int>& nums) {
        int boarder = 0;
        int n = nums.size();
        if(n == 1)
            return;
        for(int i = n - 1;i>0;--i){//寻找右边逆序区边界
            if(nums[i-1]<nums[i]){
                boarder = i-1;
                break;
            }
        }
        if(nums[boarder]<nums[boarder + 1]){
            for(int i = n - 1;i>boarder;--i){
                if(nums[i]>nums[boarder]){
                    swap(nums[i],nums[boarder]);
                    break;
                }
            }
            int start = boarder + 1,end = n - 1;
            while(start<end)
                swap(nums[start++],nums[end--]);
        }else{
            for(int i = 0;i<n/2;++i)
                swap(nums[i],nums[n-i-1]);
        }
    }
};

LeetCode【55】【跳跃游戏】：https://leetcode-cn.com/problems/jump-game/
【回溯超时】
class Solution {
public:
    bool jump(vector<int>&nums,int location,int target){
        if(location == target)//跳到
            return true;
        if(!nums[location])//遇0
            return false;
        bool flag = true;
        for(int i = 1;i<=nums[location];++i){//回溯
            flag = jump(nums,location+i,target);
            if(flag)
                return flag;
        }
        return false;
    }
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        return jump(nums,0,n - 1);
    }
};
【贪心】：
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int rightmost = 0;
        for(int i = 0;i<n;++i){
            if(i<=rightmost){
                rightmost = max(rightmost, i + nums[i]);
            if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
};

LeetCode【113】【路径总和】：https://leetcode-cn.com/problems/path-sum-ii/
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(TreeNode* root,int targetSum){
        if(!root)
            return;
        path.push_back(root->val);
        targetSum-=root->val;
        if(!root->left && !root->right && !targetSum)
            res.push_back(path);
        dfs(root->left,targetSum);
        dfs(root->right,targetSum);
        path.pop_back();
        targetSum+=root->val;
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root,targetSum);
        return res;
    }
};

LeetCode【496】【下一个更多元素I】：https://leetcode-cn.com/problems/next-greater-element-i/
【暴力解法】
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res;
        int n1 = nums1.size();
        int n2 = nums2.size();
        for(int i = 0;i<n1;++i){
            int cur = nums1[i];
            int j = 0;
            while(j<n2 && nums2[j]!=cur)
                ++j;
            ++j;
            while(j<n2 && nums2[j]<cur)
                ++j;
            j>=n2?res.push_back(-1):res.push_back(nums2[j]);
        }
        return res;
    }
};

LeetCode【503】【下一个更大元素II】：https://leetcode-cn.com/problems/next-greater-element-ii/
【暴力解法】：
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> res;
        int n = nums.size();
        for(int i = 0;i<n;++i){
            int cur = nums[i];
            int rearindex = i+1;
            int preindex = 0;
            while(preindex<i && nums[preindex]<=cur)
                ++preindex;
            while(rearindex<n&&nums[rearindex]<=cur)
                ++rearindex;
            int target = rearindex<n?nums[rearindex]:preindex<i?nums[preindex]:-1;
            res.push_back(target);
        }
        return res;
    }
};

LeetCode【46】【全排列】：https://leetcode-cn.com/problems/permutations/
【回溯】
class Solution {
public:
    vector<vector<int>> res;
    vector<int> tmp;
    void swap(int& a,int& b){
        int x = a;
        a = b;
        b = x;
    }
    void DP(vector<int>&nums,int index,int& SZ){
        if(index == SZ){
            res.push_back(tmp);
            return;
        }
        for(int i = index;i<SZ;++i){
            tmp.push_back(nums[i]);
            swap(nums[index],nums[i]);
            DP(nums,index+1,SZ);
            tmp.pop_back();
            swap(nums[index],nums[i]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        int SZ = nums.size();
        DP(nums,0,SZ);
        return res;
    }
};
【方法2：标志数组】：
class Solution {
public:
    vector<vector<int>> res;
    vector<int> tmp;
    void helper(vector<int>&nums,int& SZ,vector<int>& used){
        if(tmp.size() == SZ){
            res.push_back(tmp);
            return;
        }
        for(int i = 0;i<SZ;++i){
            if(used[i]==1)
                continue;
            used[i] = 1;
            tmp.push_back(nums[i]);
            helper(nums,SZ,used);
            used[i] = 0;
            tmp.pop_back();
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        int SZ = nums.size();
        vector<int> used(SZ,0);
        helper(nums,SZ,used);
        return res;
    }
};

LeetCode【51】【N皇后】：https://leetcode-cn.com/problems/n-queens/
class Solution {
public:
    vector<vector<string>> res;
    bool IsValid(const vector<string>& tmp,const int& row,const int& col,const int& n){
        for(int i = row - 1;i>=0;--i){//上方
            if(tmp[i][col] == 'Q')
                return false;
        }
        for(int i = row - 1,j = col + 1;i>=0&&j<n;--i,++j){//右上方
            if(tmp[i][j]=='Q')
                return false;
        }
        for(int i = row - 1,j = col - 1;i>=0&&j>=0;--i,--j){//左上方
            if(tmp[i][j]=='Q')
                return false;
        }
        return true;
    }
    void BackTrack(vector<string>& tmp,int row,const int& n){
        if(row == n){
            res.push_back(tmp);
            return;
        }
        for(int col = 0;col<n;++col){
            if(!IsValid(tmp,row,col,n))
                continue;
            tmp[row][col] = 'Q';
            BackTrack(tmp,row+1,n);
            tmp[row][col] = '.';
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> tmp(n,string(n,'.'));
        BackTrack(tmp,0,n);
        return res;
    }
};

LeetCode【52】【N皇后II】：https://leetcode-cn.com/problems/n-queens-ii/
class Solution {
public:
    bool IsValid(const vector<int>& tmp,const int& row,const int& col){
        for(int i = row - 1;i >= 0;--i)//上方
            if(tmp[i] == col)
                return false;
        for(int i = row - 1;i >= 0;--i)//左上方
            if(tmp[i] == col - row + i)
                return false;
        for(int i = row - 1;i >= 0;--i)//右上方
            if(tmp[i] == col + row - i)
                return false;
        return true;
    }
    void BackTrack(vector<int>& tmp,int row,int& cnt,const int& n){
        if(row == n){
            ++cnt;
            return;
        }
        for(int col = 0;col<n;++col){
            if(!IsValid(tmp,row,col))
                continue;
            tmp[row] = col;
            BackTrack(tmp,row+1,cnt,n);
        }
    }
    int totalNQueens(int n) {
        vector<int> tmp(n);
        int cnt = 0;
        BackTrack(tmp,0,cnt,n);
        return cnt;
    }
};

LeetCode【322】【零钱兑换】：https://leetcode-cn.com/problems/coin-change/
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1,amount+1);//初始化
        dp[0] = 0;//0值初始化
        int num = coins.size();
        for(int i = 1;i<=amount;++i){
            for(int j = 0;j<num;++j)
                if (coins[j] <= i) 
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
};

LeetCode【518】【零钱兑换】：https://leetcode-cn.com/problems/coin-change-2/
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1,0);
        int len = coins.size();
        dp[0] = 1;
        for(int i = 0;i<len;++i)
            for(int j = coins[i];j<=amount;++j){
                dp[j] += dp[j-coins[i]];
        }
        return dp[amount];
    }
};

LeetCode【59】【螺旋矩阵II】：https://leetcode-cn.com/problems/spiral-matrix-ii/
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> ans(n,vector(n,0));
        int num = 1;
        int Max_num = n*n;
        int left = 0,top = 0,right = n - 1,bottom = n-1;
        while(num<= Max_num){
            int l = left,r =right,b = bottom,t = top;
            while(l<=right)//上
                ans[top][l++] = num++;
            ++t;
            while(t<=bottom)
                ans[t++][right] = num++;
            --r;
            while(r>=left)
                ans[bottom][r--] = num++;
            --b;
            while(b>top)
                ans[b--][left] = num++;
            ++left;
            --right;
            ++top;
            --bottom;
        }
        return ans;
    }
};

LeetCode【299】【猜数字游戏】：https://leetcode-cn.com/problems/bulls-and-cows/
class Solution {
public:
    char* helper(int num){
        int tmp = num;
        int cnt = 1;
        while(tmp/=10)
            ++cnt;
        tmp = 1;
        for(int i = 1;i<cnt;++i)
            tmp*=10;
        char* ans = new char[cnt+1];
        ans[cnt] ='\0';
        for(int i = 0;i<cnt;++i){
            ans[i] = num/tmp+'0';
            num%=tmp;
            tmp/=10;
        }
        return ans;
    }
    string getHint(string secret, string guess) {
        int len = secret.size();
        vector<int> cnt_s(10,0);
        vector<int> cnt_g(10,0);
        int cnt_A = 0;
        for(int i = 0;i<len;++i){
            if(secret[i]==guess[i])
                ++cnt_A;
            cnt_s[secret[i]-'0']++;
            cnt_g[guess[i]-'0']++;
        }
        int cnt_B = 0;
        for(int i = 0;i<10;++i)
            cnt_B += cnt_s[i]<cnt_g[i]?cnt_s[i]:cnt_g[i];
        cnt_B-=cnt_A;
        char* A = helper(cnt_A),*B =helper(cnt_B);
        string ans;
        ans.append(A);
        ans.append("A");
        ans.append(B);
        ans.append("B");
        delete[] A,delete[] B;
        return ans;
    }
};

LeetCode【43】【字符串相乘】：https://leetcode-cn.com/problems/multiply-strings/
class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1 == "0" ||num2 == "0")
            return "0";
        int len1 =num1.size(),len2 = num2.size();
        string ans(len1+len2,'0');
        for(int i =len1-1;i>=0;--i){
            for(int j = len2 - 1;j>=0;--j){
                int cur = (num1[i] - '0') * (num2[j] - '0') + (ans[i+j+1] - '0');
                ans[i+j+1] = cur % 10 + '0';  
                ans[i+j] += cur / 10;  
            }
        }
        if (ans[0]=='0')
            ans.erase(ans.begin());
        return ans;        
    }
};

LeetCode【47】【全排列】：https://leetcode-cn.com/problems/permutations-ii/
class Solution {
public:
    vector<vector<int>> res;
    vector<int> tmp;
    void helper(vector<int>&nums,int& SZ,vector<int>& used){
        if(tmp.size() == SZ){
            res.push_back(tmp);
            return;
        }
        for(int i = 0;i<SZ;++i){
            if(used[i] || (i>0 && nums[i]==nums[i-1] && !used[i-1]))
                continue;
            used[i] = 1;
            tmp.push_back(nums[i]);
            helper(nums,SZ,used);
            used[i] = 0;
            tmp.pop_back();
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        int SZ = nums.size();
        sort(nums.begin(),nums.end());
        vector<int> used(SZ,0);
        helper(nums,SZ,used);
        return res;
    }
};

LeetCode【117】【填充每个节点的下一个右侧右侧节点指针】：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/
class Solution {
public:
    Node* connect(Node* root) {
        if(!root)
            return root;
        queue<Node*> Q;
        Q.push(root);
        Node* t = nullptr;
        while(!Q.empty()){
            int sz = Q.size();
            for(int i = 0;i<sz;++i){
                Node* tmp = Q.front();
                Q.pop();
                if(Q.empty()|| i == sz-1)
                    t = nullptr;
                else
                    t = Q.front();
                tmp->next = t; 
                if(tmp->left)
                    Q.push(tmp->left);
                if(tmp->right)
                    Q.push(tmp->right);
            }
        }
        return root;
    }
};

LeetCode【589】【N叉树的前序遍历】：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/
【迭代法】
class Solution {
public:
    vector<int> preorder(Node* root) {
        vector<int> ans;
        if(!root)
            return ans;
        stack<Node*> s;
        s.push(root);
        while(!s.empty()){
            Node* tmp = s.top();
            ans.push_back(tmp->val);
            s.pop();
            for(int i = tmp -> children.size()-1; i >= 0; --i)
                s.push(tmp->children[i]);
        }
        return ans;
    }
};
【递归法】：
class Solution {
public:
    void dfs(Node* root,vector<int>& ans){
        if(!root)
            return;
        ans.push_back(root->val);
        int sz = root->children.size();
        for(int i = 0;i<sz;++i)
            dfs(root->children[i],ans);
    }
    vector<int> preorder(Node* root) {
        vector<int> ans;
        dfs(root,ans);
        return ans;
    }
};

LeetCode【590】【N叉树的后序遍历】：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/
【递归法】：
class Solution {
public:
    void bfs(Node* root,vector<int>& ans){
        if(!root)
            return;
        int sz = root->children.size();
        for(int i = 0;i<sz;++i)
            bfs(root->children[i],ans);
        ans.push_back(root->val);
    }
    vector<int> postorder(Node* root) {
        vector<int> ans;
        bfs(root,ans);
        return ans;
    }
};
【迭代法】：
class Solution {
public:
    vector<int> postorder(Node* root) {
        vector<int> ans;
        if(!root)
            return ans;
        stack<Node*> s;
        s.push(root);
        while(!s.empty()){
            Node* tmp = s.top();
            ans.push_back(tmp->val);
            s.pop();
            int sz = tmp->children.size();
            for(int i=0;i<sz;++i)
                s.push(tmp->children[i]);
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};

LeetCode【559】【N叉树的最大深度】:https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/
class Solution {
public:
    int maxDepth(Node* root) {
        if(!root)
            return 0;
        int sz = root->children.size();
        int max =0,tmp = 0; 
        for(int i = 0;i<sz;++i){
            tmp = maxDepth(root->children[i]);
            max = tmp>max?tmp:max;
        }
        return max + 1;
    }
};

LeetCode【429】【N叉树的层序遍历】：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> ans;
        if(!root)
            return ans;
        queue<Node*> Q;
        Q.push(root);
        while(!Q.empty()){
            vector<int> tmp;
            int sz = Q.size();
            for(int i = 0;i<sz;++i){
                Node* node = Q.front();
                Q.pop();
                tmp.push_back(node->val);
                int SZ = node->children.size();
                for(int i = 0;i<SZ;++i){
                    if(node->children[i])
                        Q.push(node->children[i]);
                }
            }
            ans.push_back(tmp);
        }
        return ans;
    }
};

LeetCode【49】【丑数】：https://leetcode-cn.com/problems/chou-shu-lcof/
class Solution {
public:
    int nthUglyNumber(int n) {
        int* dp = new int[n];
        dp[0] = 1;
        int a=0,b=0,c=0;
        for(int i = 1;i<n;++i){
            int n1 = 2*dp[a],n2=3*dp[b],n3=5*dp[c];
            dp[i] = min(min(n1,n2),n3);
            if(dp[i]==n1) ++a;
            if(dp[i]==n2) ++b;
            if(dp[i]==n3) ++c;
        }
        return dp[n-1];
    }
};

LeetCode【784】【字母大小全排列】：https://leetcode-cn.com/problems/letter-case-permutation/
class Solution {
public:
    vector<string> res;
    void BackTrack(string& tmp,int index,const int& sz){
        if(index == sz){
            res.push_back(tmp);
            return;
        }
        BackTrack(tmp,index+1,sz);
        if(tmp[index]>'9'){
            tmp[index]^=32;
            BackTrack(tmp,index+1,sz);
        }
    }
    vector<string> letterCasePermutation(string S) {
        string tmp(S);
        int sz = S.size();
        BackTrack(tmp,0,sz);
        return res;
    }
};

LeetCode【500】【键盘行】：https://leetcode-cn.com/problems/keyboard-row/
class Solution {
public:
    vector<string> res;
    vector<string> findWords(vector<string>& words) {
        vector<vector<int>> comp(3,vector(26,0));
        char* s1 = "qwertyuiop";
        char* s2 = "asdfghjkl";
        char* s3 = "zxcvbnm";
        int len[3] = {10,9,7};
        for(int i = 0;i<len[0];++i){
            comp[0][s1[i]-'a'] = 1;
            if(i<len[1])
                comp[1][s2[i]-'a'] = 1;
            if(i<len[2])
                comp[2][s3[i]-'a'] = 1;
        }
        int n = words.size();
        for(int i = 0;i<n;++i){
            int sz = words[i].size();
            for(int j = 0;j<3;++j)
                Add(comp[j],words[i],len[j],sz);
        }
        return res;
    }
    void Add(const vector<int>& comp,const string& word,const int& compsz,const int& wordsz){
        for(int i = 0;i<wordsz;++i){
            char tmp = tolower(word[i]);
            if(comp[tmp-'a']!=1)
                return;
        }
        res.push_back(word);
    }
};

LeetCode【205】【同构字符串】：https://leetcode-cn.com/problems/isomorphic-strings/
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int* cnt_s = new int[128];
        int* cnt_t = new int[128];
        int len = s.size();
        for(int i = 0;i<len;++i){
            if(cnt_s[s[i]]!=cnt_t[t[i]])
                return false;
            cnt_s[s[i]]=cnt_t[t[i]]=i;
        }
        return true;
    }
};

LeetCode【238】【除自身以外数组的乘积】：https://leetcode-cn.com/problems/product-of-array-except-self/
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int sz = nums.size();
        vector<int> res(sz);
        vector<int> left(sz,1);
        vector<int> right(sz,1);
        for(int i = 1;i<sz;++i)
            left[i] = nums[i-1]*left[i-1];
        for(int i = sz-2;i>=0;--i)
            right[i] =nums[i+1]*right[i+1];
        for(int i = 0;i<sz;++i)
            res[i] = left[i]*right[i];
        return res;
    }
};

LeetCode【1464】【数组中两元素的最大乘积】：https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int sz = nums.size();
        int max1,max2;
        max1 = max(nums[0],nums[1]);
        max2 = max1==nums[0]?nums[1]:nums[0];
        for(int i = 2;i<sz;++i){
            if(nums[i]>max2){
                max2 = min(nums[i],max1);
                max1 = max(nums[i],max1);
            }  
        }
        return (max1-1)*(max2-1);
    }
};

牛客【栈的压入弹出】：https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        stack<int> S;
        int index_pop = 0;
        int sz = popV.size();
        for(int i = 0;i<sz;++i){
           S.push(pushV[i]);
           while(!S.empty() && S.top() == popV[index_pop])
               S.pop(),++index_pop;
        }
        if(S.empty())
            return true;
        return false;
    }
};

牛客【斐波那契数列】：https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    int Fibonacci(int n) {
        if(n<2)
            return n;
        int first = 0;
        int second = 1;
        int third = 0;
        --n;
        while(n>0){
            third = first+second;
            first = second;
            second = third;
            n--;
        }
        return third;
    }
};

牛客【跳台扩展问题】：https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    int jumpFloorII(int number) {
        int res = 1;
        while(--number)
            res<<=1;
        return res;
    }
};

LeetCode【232】【用对列模拟栈】：https://leetcode-cn.com/problems/implement-stack-using-queues/
class MyStack {
public:
    queue<int> q1;
    queue<int> q2;
    /** Initialize your data structure here. */
    MyStack() {} 
    /** Push element x onto stack. */
    void push(int x) {
        q2.push(x);
        while(!q1.empty()){
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1,q2);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int tmp = q1.front();
        q1.pop();
        return tmp;
    }
    
    /** Get the top element. */
    int top() {
        return q1.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty();
    }
};

LeetCode【232】【用栈实现队列】：https://leetcode-cn.com/problems/implement-queue-using-stacks/
class MyQueue {
public:
    stack<int> sin;
    stack<int> sout;
    /** Initialize your data structure here. */
    MyQueue() {    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        sin.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(sout.empty()){
            while(!sin.empty()){
                sout.push(sin.top());
                sin.pop();
            }
        }
        int tmp = sout.top();
        sout.pop();
        return tmp;
    }
    
    /** Get the front element. */
    int peek() {
        if(sout.empty()){
            while(!sin.empty()){
                sout.push(sin.top());
                sin.pop();
            }
        }
        return sout.top(); 
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return sin.empty()&&sout.empty();
    }
};

LeetCode【155】【最小栈】：https://leetcode-cn.com/problems/min-stack/
class MinStack {
public:
    stack<int> smin;
    stack<int> st;
    /** initialize your data structure here. */
    MinStack() {    }
    
    void push(int val) {
        st.push(val);
        if(smin.empty() ||smin.top()>=val)
            smin.push(val);
    }
    
    void pop() {
         if(st.top()==smin.top())
            smin.pop();
        st.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return smin.top();
    }
};

LeetCode【15】【三数之和】：https://leetcode-cn.com/problems/3sum/
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int sz = nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int i = 0;i<sz;++i){
            if(nums[i]>0)
                return ans;
            if(i>0 && nums[i]==nums[i-1])
                continue;
            int left = i+1,right = sz-1;
            while(left<right){
                if(nums[left] + nums[right] > -nums[i])
                    --right;
                else if (nums[left] + nums[right]<-nums[i])
                    ++left;
                else{
                    ans.push_back(vector<int>{nums[i],nums[left],nums[right]});
                    while(left<right && nums[right]==nums[right-1]) --right;
                    while(left<right && nums[left]==nums[left+1]) ++left;
                    ++left,--right;
                }
            }
        }
        return ans;
    }
};

LeetCode【18】【四数之和】：https://leetcode-cn.com/problems/4sum/
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int sz = nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int i = 0;i<sz;++i){
            if(i>0 && nums[i] == nums[i-1])
                continue;
            int res = target - nums[i];
            for(int j = i+1;j<sz;++j){
                if(j>i+1 && nums[j] == nums[j-1])
                    continue;
                int left = j + 1,right = sz - 1;
                int res1 = res - nums[j];
                while(left<right){
                    if(nums[left]+nums[right]<res1)
                        ++left;
                    else if(nums[left]+nums[right]>res1)
                        --right;
                    else{
                        ans.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});
                        while(left<right&&nums[right] == nums[right-1])--right;
                        while(left<right&&nums[left]==nums[left+1])++left;
                        ++left,--right;
                    }
                }
            }
        }
        return ans;
    }
};

LeetCode【606】【根据二叉树创建字符串】：https://leetcode-cn.com/problems/construct-string-from-binary-tree/
class Solution {
public:
    string res;
    void dfs(TreeNode* t){
        if(!t)
            return;
        char* buf = new char[10];
        memset(buf,'\0',10);
        sprintf(buf,"%d",t->val);
        res.append(buf);
        if(!t->left){
            if(!t->right)
                return;
            else
                res.append("()");
        }else{
            res.append("(");
            dfs(t->left);
            res.append(")");
        }
        if(t->right){
            res.append("(");
            dfs(t->right);
            res.append(")");
        }
    }
    string tree2str(TreeNode* t) {
        dfs(t);
        return res;
    }
};

剑指offer【37】【序列化二叉树】：https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/
class Codec {
public:
    string res;
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root)
            return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int sz = q.size();
            for(int i = 0;i<sz;++i){
                TreeNode* t = q.front();
                q.pop();
                if(t){
                    res += to_string(t->val);
                    res+=",";
                    q.push(t->left);
                    q.push(t->right);
                }
                else
                    res+="$,";
            }
        }
        return res;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data){
        split(data);
        int sz = seq.size();
        int start = 0;
        return Creat(start,sz);
    }
    private:
    vector<string> seq;
    void split(string& data){
        char* start = (char*)data.c_str();
        char* send = start;
        while(*send){
            if(*send == ','){
                string tmp;
                for(char* r = start;r!=send;++r)
                    tmp.push_back(*r);
                seq.push_back(tmp);
                start = send + 1;
                send = start;
            }else
                ++send;
        }
    }
    int to_num(const string& str){
        int res = 0;
        int flag = 1;
        int index = 0;
        if(str[index] =='-'){
            flag = -1;
            ++index;
        }
        int sz = str.size();
        for(int i = index;i<sz;i++)
            res = res*10 + (str[i]-'0');
        return flag*res;
    }
    TreeNode* Creat(int index,const int& sz){
        if(index>=sz || seq[index][0] == '$')
            return nullptr;
        int cnt = 0;
        for(int i = 0;i<index;++i)
            if(seq[i][0]=='$')
                ++cnt;
        TreeNode* t = new TreeNode(to_num(seq[index]));
        t->left = Creat(2*(index-cnt)+1,sz);
        t->right = Creat(2*(index-cnt)+2,sz);
        return t;
    }
};
