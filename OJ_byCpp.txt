LeetCode【1】:https://leetcode-cn.com/problems/two-sum/
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int left = 0;
    int right = 0;
    *returnSize = 2;
    int *res = (int *)malloc(sizeof(int)*2);
    for(left = 0;left<numsSize-1;left++){
        for(right=left+1;right<numsSize;right++){
           if(target - nums[left] == nums[right] )
           {
               res[0] = left,res[1] = right;
               return res; 
           }
        }
    }
    return res;
}

LeetCode【27】：https://leetcode-cn.com/problems/remove-element/
int removeElement(int* nums, int numsSize, int val){
    int k = 0,i;
	for (i = 0; i < numsSize; i++) {
		if (nums[i] != val) { //不等的数字覆盖
			nums[k++] = nums[i];
		}
	}
	return k;
}

LeetCode【709】:https://leetcode-cn.com/problems/to-lower-case/
char * toLowerCase(char * str){
    int len = strlen(str);      
    char* dst = (char*)malloc(len + 1);
    char* st = dst;   //保存起始位置
    if (NULL != dst) {
        memset(dst, '\0', len + 1); 
        while (*str) {
            if ((*str >= 'A') && (*str <= 'Z')) {  //只将大写转小写
                *dst = *str + 32;
            }
            else {
                *dst = *str;
            }
            str++;
            dst++;
        }
    }
    return st;
}

LeetCode【189】:https://leetcode-cn.com/problems/rotate-array/
void Reverse(int* nums, int start, int end)
{
    while (start < end) {
        int tmp = nums[end];
        nums[end] = nums[start];
        nums[start] = tmp;
        end--, start++;
    }
}
void rotate(int* nums, int numsSize, int k){
    k %= numsSize;
    Reverse(nums, 0, numsSize - 1);
    Reverse(nums, 0, k - 1);
    Reverse(nums, k, numsSize - 1);
}

LeetCode【35】:https://leetcode-cn.com/problems/search-insert-position/
int searchInsert(int* nums, int numsSize, int target){
    int left = 0;
	int right = numsSize - 1;
	int mid, flag;
	while (left <= right) {
		mid = (left + right) / 2;
		if (nums[mid] > target) {
			right = mid - 1;
			flag = 0; //说明:最后一次right减小引发的循环条件不满足,此时target>nums[right]
		}
		else if (nums[mid] < target) {
			left = mid + 1;
			flag = 1;//说明:最后一次left增大引起的循环条件不满足,此时target<nums[left]
		}
		else {
			return mid;//target存在与nums中且被找到
		}
	}
	return  flag == 0 ? right + 1 : left; //target比nums[left-1]大，但比nums[left]小，所以插的位置就是left
}

LeetCode【383】:https://leetcode-cn.com/problems/ransom-note/
bool canConstruct(char* ransomNote, char* magazine) {
    int num1[26] = {0};
    int num2[26] = {0};
    int k1 = strlen(ransomNote);
    int k2 = strlen(magazine);
    for(int i=0;i<k1;i++){
        num1[ransomNote[i]-'a']++;
    }
    for(int i=0;i<k2;i++){
        num2[magazine[i]-'a']++;
    }
    for(int i = 0;i<26;i++){
        if(num1[i]>num2[i]){
            return false;
        }
    }
    return true;
}

LeetCode【9】:https://leetcode-cn.com/problems/palindrome-number/
int LenofNum(int x)
{
    int cnt = 1;
    while (x /= 10) {
        cnt++;
    }
    return cnt;
}
int isPalindrome(int x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) { //负数及个位为0的非0数必不是回文数
        return false;
    }
    int k = LenofNum(x);
    for (int i = 0; i < k / 2; i++) {//计算一半就行
        int h = x / (int)pow(10, k - i - 1) % 10;  //获取高位数字
        int l = x / (int)pow(10, i) % 10;//获取低位数字
            if (h != l) {
                return false;
            }
    }
    return true;
}

LeetCode【58】:https://leetcode-cn.com/problems/length-of-last-word/
int lengthOfLastWord(char * s){
   int len = strlen(s), lastWordLen = 0;
    if (len == 0) return 0;

    for (int i = len - 1; i >= 0; i--) {
        if (s[i] != ' ') lastWordLen++;
        if (s[i] == ' ' && lastWordLen > 0) break;
    }

    return lastWordLen;
}

LeetCode【88】:https://leetcode-cn.com/problems/merge-sorted-array/
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    m--;
    n--; 
    for (int t = nums1Size - 1; t >= 0 && n >= 0 ; t--) {
        if (m < 0) { 
            nums1[t] = nums2[n--];
        }
        else{
            nums1[t] = nums2[n] > nums1[m] ? nums2[n--] : nums1[m--];
        }
    }
}

LeetCode【217】:https://leetcode-cn.com/problems/contains-duplicate/
int Cmp(const void* a,const void* b)
{
    return *(int*)a-*(int*)b;
}
bool containsDuplicate(int* nums, int numsSize){
    if(numsSize<=1)
        return false;
    else{
        qsort(nums,numsSize,sizeof(int),Cmp);
        for(int i = 0;i<numsSize-1;i++){
            if(nums[i]==nums[i+1])
            return true;
        }
    }
    return false;
}

LeetCode【925】:https://leetcode-cn.com/problems/long-pressed-name/
bool isLongPressedName(char * name, char * typed){
    int n = strlen(name);
    int m = strlen(typed);
    int i=0,j=0;
     while (j < m) {
        if (i < n && name[i] == typed[j]) {//一样则同时后移
            i++;
            j++;
        } else if (j > 0 && typed[j] == typed[j - 1]) {//不一样，但属于长按导致1
            j++;
        } else {//不对
            return false;
        }
    }
    return i == n;
}

LeetCode【977】:https://leetcode-cn.com/problems/squares-of-a-sorted-array/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    int* p =(int*)malloc(sizeof(int)*numsSize);
    int end = numsSize - 1;
    int start = 0;
    int i = end;
    while(start<=end){
        if(abs(nums[start])>=abs(nums[end]))
            p[i--] = pow(nums[start++],2);
        else
            p[i--] = pow(nums[end--],2);
    }
    *returnSize = numsSize;
    return p;
}

LeetCode【917】:https://leetcode-cn.com/problems/reverse-only-letters/
char * reverseOnlyLetters(char * S){
        int len = strlen(S);
    if (len <= 1)
        return S;
    char* str = (char*)malloc(len + 1);
    str[len] = '\0';
    char* stack = (char*)malloc(len + 1);
    int top = 0;
    int i = 0;
    while (i < len) {
        if (isalpha(S[i])) {
            stack[top++] = S[i];
        }
        i++;
    }
    i = 0;
    while (i < len) 
        str[i++] = isalpha(S[i]) ? stack[--top] : S[i];
    return str;
}

LeetCode【905】:https://leetcode-cn.com/problems/sort-array-by-parity/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortArrayByParity(int* A, int ASize, int* returnSize) {
    int left = 0;
    int right = ASize - 1;
    while (left <= right) {
        while (left<=right && !(A[left] % 2))
            left++;
        while (left<=right && A[right] % 2)
            right--;
        if (left <= right) {
            int tmp = A[left];
            A[left] = A[right];
            A[right] = tmp;
        }
    }
    *returnSize = ASize;
    return A;
}
LeetCode【724】:https://leetcode-cn.com/problems/find-pivot-index/
int pivotIndex(int* nums, int numsSize) {
    int sum = 0;
    int sumleft = 0;
    for (int i = 0; i < numsSize; i++) 
        sum += nums[i];
    for(int i = 0;i<numsSize;i++){
        if(2*sumleft+nums[i]==sum)
            return i;
        sumleft+=nums[i];
    }
    return -1;
}

LeetCode【66】:https://leetcode-cn.com/problems/plus-one/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* plusOne(int* digits, int digitsSize, int* returnSize){
    int * res = (int *)malloc(sizeof(int)*(digitsSize+1));
    int flag = 0;
    res[0] = 0;
    for(int i = digitsSize - 1;i>=0;i--){
        if(i==digitsSize - 1)
            res[i+1] = digits[i] + 1;
        else
            res[i+1] = digits[i]+flag;
        res[i+1]>9?(res[i+1]%=10,flag = 1):(res[i+1],flag=0);
    }
    res[0]+=flag;
    *returnSize = res[0]==0?digitsSize:digitsSize+1;
    return res[0]==0?res+1:res;
}

LeetCode【414】:https://leetcode-cn.com/problems/third-maximum-number/
int thirdMax(int* nums, int numsSize){
    if(1 == numsSize)
        return nums[0];
    else if(2 == numsSize)
        return nums[0]>nums[1]?nums[0]:nums[1];
    else{
        long first = LONG_MIN,second = LONG_MIN,third = LONG_MIN;
        for(int i = 0;i<numsSize;i++){
            if(nums[i]==third||nums[i]==second||nums[i]==first)
                continue;
            if(nums[i]>first){
                third = second;
                second = first;
                first = nums[i];
            }else if(nums[i]>second&&nums[i]<first){
                third = second;
                second = nums[i];
            }else if(nums[i]>third&&nums[i]<second)
                third = nums[i];
        }     
        return third==LONG_MIN?first:third;
    }
}

LeetCode【8】【字符串转数字】：https://leetcode-cn.com/problems/string-to-integer-atoi/
int myAtoi(char * s){
	char *ptr = s;
    int flag = 1;
    long int res = 0;
    while((*ptr) == ' ')
        ptr++;
    if(*ptr == '-'){
        flag = -1;
        ptr++;
    }else if(*ptr == '+'){
        flag = 1;
        ptr++;
    }
    while(isdigit(*ptr)){
        res=(res*10+*ptr-'0');
        if((int)res != res)
            break;
        ptr++;
    }
    if(isdigit(*ptr))
        if(flag == -1)
            return INT_MIN;
        else
            return INT_MAX;
    return res*flag;
}

LeetCode【34】【寻找目标数字的索引】：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
int* searchRange(int* nums, int numsSize, int target, int* returnSize){
    *returnSize = 2;
    int* res =(int*)malloc(sizeof(int)*2);
    res[0]=res[1]=-1;
    int left = 0,right = numsSize - 1;
    while(left<=right){//先找到target
        int mid = (left+right)>>1;
        if(nums[mid]>target)
            right = mid - 1;
        else if(nums[mid]<target)
            left = mid + 1;
        else{
            left = right = mid;//向两边找
            while(left - 1>=0 && !(nums[left-1]^target))
                left--;
             while(right + 1<=numsSize - 1 && !(nums[right+1]^target))
                right++;
            res[0] = left,res[1] = right;
            break;
        }
    }
    return res;
}

LeetCode【125】【验证回文字符串】:https://leetcode-cn.com/problems/valid-palindrome/
bool isPalindrome(char * s){
    int n = strlen(s);
    int left = 0;
    int right = n-1;
    while(left<=right){
        if(!isalnum(s[left])){
            left++;
            continue;
        }
        while(!isalnum(s[right])){
            right--;
            continue;
        }
        if(tolower(s[left]) != tolower(s[right]))
            return false;
        left++,right--;
    }
    return true;
}

LeetCode【443】【压缩字符串】：https://leetcode-cn.com/problems/string-compression/
static int _len(int k)
{
    int cnt = 1;
    while(k/=10)
        cnt++;
    return cnt;
}
int compress(char* chars, int charsSize){
    if(charsSize<2)//不需要压缩
        return charsSize;
    int follow = 0;
    int pre = 0;
    int t = 0;
    while(pre<charsSize){
        while(pre<charsSize&&chars[follow]==chars[pre])//出此循环说明pre已到下一个字符
            pre++;
        chars[t] = chars[follow];//将字符填入
        t++;
        int k = pre - follow;//计算与chars[follow]相同字符的数目
        int nums = _len(k);//获取k的位数
        while(k>1&&nums)//只有个数大于1才能填入计数
            chars[t++] = k/(int)pow(10,--nums)%10+'0';//分数位填入
        if(pre<charsSize)//字符数组未遍历完
            follow = pre;
        else //遍历完
            break;
    }
    return t;
}
LeetCode【150】【根据逆波兰表示法，求表达式的值】：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/
int evalRPN(char ** tokens, int tokensSize){
    int* stack = (int*)malloc((tokensSize/2+1)*sizeof(int));
    int top = -1;
    int n1 = 0,n2 = 0;
    for(int i = 0;i<tokensSize;i++){
        if(!strcmp(tokens[i],"+")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 + n2; 
        }
        else if(!strcmp(tokens[i],"*")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 * n2; 
        }    
        else if(!strcmp(tokens[i],"-")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n2 - n1; 
        }     
        else if(!strcmp(tokens[i],"/")){
             n1 = stack[top--],n2 = stack[top--];
             stack[++top] = n2 / n1; 
        }
        else
            stack[++top] = atoi(tokens[i]);//字符转数字
    }
    return stack[top];
}

LeetCode【38】【外观数列】：https://leetcode-cn.com/problems/count-and-say/
char * countAndSay(int n){
    int size = 10000;
    char* strold = (char*)malloc(size);
    char* strnew = (char*)malloc(size);
    memset(strold,'\0',size),memset(strnew,'\0',size);
    strold[0] = '1';
    int cnt = 0;
    int k = 0;
    char *ptr = strold;
    while(--n){
        while(*ptr){
            cnt = 0;
            char key = *ptr;
            while(*ptr && *ptr == key)
                cnt++,ptr++;
            strnew[k++] = cnt + '0';
            strnew[k++] = key;
        }
        memcpy(strold,strnew,strlen(strnew));
        memset(strnew,'\0',strlen(strnew));
        ptr = strold;
        k = 0;
    }
    return strold;
}

【剑指Offer21】【调整数组顺序使奇数位于偶数之前】：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/
int* exchange(int* nums, int numsSize, int* returnSize){
    int left = 0,right = numsSize - 1;
    *returnSize = numsSize;
    while(left < right){
        while(left < right && nums[left]%2)
            left++;
        while(right>left && !(nums[right]%2))
            right--;
        int tmp = nums[left];
        nums[left] = nums[right];
        nums[right] = tmp;
    }
    return nums;
}

LeetCode【167】【两数之和】：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/
int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(2*sizeof(int));
    res[0]=-1,res[1]=-1;
    int left = 0,right = numbersSize - 1;
    while(left<right){
        if(numbers[left]+numbers[right]>target)
            right--;
        else if(numbers[left]+numbers[right]<target)
            left++;
        else{
            res[0]=left+1,res[1]=right+1;
            break;
        }
    }
    return res;
}

LeetCode【168】【Excel表列名称】：https://leetcode-cn.com/problems/excel-sheet-column-title/
char * convertToTitle(int n){
    int size = 10000;
    char* res = (char*)malloc(size);
    int i = 0;
    memset(res,'\0',size);
    while(n){
        n-=1;
        int c = n%26;
        res[i++] = c  + 'A';
        n/=26;
    } 
    int len = strlen(res);
    int half = len/2;
    i = 0;
    while(i<half){
        char tmp = res[len - i - 1];
        res[len - i - 1] = res[i];
        res[i] = tmp;
        i++;
    }
    return res;
}

LeetCode【171】【Excel表列序号】：https://leetcode-cn.com/problems/excel-sheet-column-number/
int titleToNumber(char * s){
    int res = 0;
    int len = strlen(s);
    int i = len - 1;
    while(i > -1){
        res += (int)(*s - 64)*(int)pow(26,i);
        s++;
        i--;
    }
    return res;
}

LeetCode【112】【路径总和】：https://leetcode-cn.com/problems/path-sum/
bool IsEuqal(struct TreeNode* root,int target,int sum){
    if(NULL == root)
        return false;
    sum += root->val;
    if(sum == target && root->left == NULL && root->right == NULL)
        return true;
    return IsEuqal(root->left,target,sum) || IsEuqal(root->right,target,sum);
}
bool hasPathSum(struct TreeNode* root, int targetSum){
    int sum = 0;
    return IsEuqal(root,targetSum,0);
}

LeetCode【121】【买卖股票的最佳时机I】：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int buy = 0;
    int profit =0;
    int i = 0;
    while(i < pricesSize){
        buy = prices[i]<prices[buy]?i:buy;
        profit = profit>(prices[i]-prices[buy])?profit:prices[i]-prices[buy];
        i++;
    }
    return profit;
}

LeetCode【122】【买卖股票的最佳时机II】
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int profit = 0;
    for(int i = 1;i<pricesSize;i++){
        profit += fmax(0,prices[i]-prices[i-1]);
    }
    return profit;
}

LeetCode【258】【各位相加】：https://leetcode-cn.com/problems/add-digits/
int addDigits(int num){
    if(num < 10)
        return num;
    else{
        int res = 0;
        while(num){
            res += (num%10);
            num/=10;
        }
        num = addDigits(res);
        return num; 
    }
}

【剑指Offer58-II】【左旋转字符串】：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/
char* reverseLeftWords(char* s, int n){
    int len = strlen(s);
    char* res = (char*)malloc(len + 1);
    char* p = res;
    memset(res,'\0',len + 1);
    n = n % len;
    char* tmp = s + n;
    strcpy(p,tmp);
    while(*p)
        p++;
    while(n--){
        *p = *s;
        s++,p++;
    }
    return res;
}

【剑指Offer28】【对称的二叉树】：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/
bool _Issymmetric(struct TreeNode* p,struct TreeNode* q)
{
    if(NULL == p && NULL == q)
        return true;
    if(NULL == p || NULL == q)
        return false;
    return (p->val == q->val) && _Issymmetric(p->left,q->right) && _Issymmetric(p->right,q->left);
}
bool isSymmetric(struct TreeNode* root){
    if(NULL == root)
        return true;
    return _Issymmetric(root->left,root->right);
}

【剑指Offer52】【两个链表的第一个公共节点】：https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode* A = headA;
    struct ListNode* B = headB;
    while(A != B){
        if(A == NULL)
            A = headB;
        else
            A = A->next;
        if(B == NULL)
            B = headA;
        else
            B = B->next;
    }
    return A;
}

【剑指Offer26】【树的子结构】：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
bool IsSame(struct TreeNode* p,struct TreeNode* q){
    if(q == NULL)
        return true;
    if(p == NULL)
        return false;
    return (p->val == q->val) && IsSame(p->left,q->left) && IsSame(p->right,q->right);
}
bool isSubStructure(struct TreeNode* A, struct TreeNode* B){
    if(A == NULL || B == NULL)
        return false;
    if(IsSame(A,B))
        return true;
    return isSubStructure(A->left,B) || isSubStructure(A->right,B);
}

【剑指offer22】【链表中倒数第K个节点】：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
【方法1】
int LenofList(struct ListNode* head){
    int n = 0;
    while(head){
        head = head->next;
        n++;
    }
    return n;
}
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    int len = LenofList(head);
    if(k > len)
        return NULL;
    while(len != k){
        head = head->next;
        len--;
    }
    return head;
}
【方法2】：双指针
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    struct ListNode* pre = head;
    while(k && pre != NULL){
        pre = pre->next;
        k--;
    }
    while(pre != NULL){
        pre = pre->next;
        head = head->next;
    }
    return k==0?head:pre;
}

【LCP01】【猜数字】：https://leetcode-cn.com/problems/guess-numbers/
int game(int* guess, int guessSize, int* answer, int answerSize){
    int cnt = 0;
    for(int i = 0;i<guessSize;i++)
       cnt += (guess[i]==answer[i]?1:0);
    return cnt;
}

【LCP18】【早餐组合】：https://leetcode-cn.com/problems/2vYnGI/
void ShellInsert(int *a,int dk,int size){
    for(int i = dk;i < size;i++){
        int temp = a[i];
        int j = 0;
        for(j = i - dk;j >= 0 && temp < a[j];j-=dk)
            if(temp < a[j])
                a[j+dk] = a[j];
        a[j+dk] = temp;
    }
}
void Sort(int* a,int size){
    int dk = size;
    while(dk/=2)
        ShellInsert(a,dk,size);
}
int breakfastNumber(int* staple, int stapleSize, int* drinks, int drinksSize, int x){
   Sort(drinks,drinksSize);
   int cnt = 0;
   for(int i = 0;i < stapleSize; i++){
        int left = 0,right = drinksSize - 1,mid = 0;
        while(left <= right){
            mid = (left+right)>>1;
            int tmp = staple[i]+drinks[mid];
            if(tmp>x)
                right = mid - 1;
            else
                left = mid + 1;
        }
        cnt += left;
        cnt %= 1000000007; 
   }
   return cnt;
}

LeetCode【107】【二叉树的层序遍历】：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/
int Height(struct TreeNode* root){
     if(NULL == root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r; 
 }
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
        if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = Height(root);//树深
    int** levelorder = (int**)malloc(sizeof(int*)*h);//开辟空间，存储数组指针
    *returnSize = h;//数组指针的数目 = 树深
    *returnColumnSizes =  (int *)malloc(sizeof(int)*h);//
    
    struct TreeNode*q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root;
    q1_size++;
    int level = 0;
    while(level<h){
        levelorder[h-1-level] = (int *)malloc(sizeof(int)*q1_size);
        for(int i = 0;i<q1_size;i++)
            levelorder[h-1-level][i] = q1[i]->val;
        (*returnColumnSizes)[h-1-level] = q1_size;
        for(int i = 0;i<q1_size;i++){//q1里的左右孩子存入q2，获得下一层数据
            if(q1[i]->left != NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right != NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        level++;
    }
    return levelorder;
}

LCP【16】【速算机器人】：https://leetcode-cn.com/problems/nGK0Fy/
int calculate(char* s){
    int x = 1,y = 0;
    while(*s){
        if(*s == 'A')
            x = 2*x + y;
        else
            y = 2*y + x;
        s++;
    }
    return x+y;
}

LCP【11】【期望个数统计】：https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji/
void Sort(int* scores,int num){
    int dk = num;
    while(dk/=2){
        for(int i = dk;i<num;i++){
            int tmp = scores[i];
            if(tmp<scores[i-dk]){
                int j = 0;
                for(j=i-dk;j>=0&&tmp<scores[j];j-=dk)
                    scores[j+dk]=scores[j];
                scores[j+dk] = tmp;
            }
        }
    }
}
int expectNumber(int* scores, int scoresSize){
    int cnt = 1;
    Sort(scores,scoresSize);
    for(int i = 1;i<scoresSize;i++){
        if(scores[i]!=scores[i-1])
            cnt+=1;
    } 
    return cnt;
}

LCP【06】【拿硬币】：https://leetcode-cn.com/problems/na-ying-bi/
int minCount(int* coins, int coinsSize){
    int cnt = 0;
    for(int i = 0;i<coinsSize;i++)
        cnt += coins[i]%2?(coins[i]/2+1):(coins[i]/2);
    return cnt;
}

LCP【02】【分式化简】：https://leetcode-cn.com/problems/deep-dark-fraction/
int* fraction(int* cont, int contSize, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    int son = 1; //最后一分数，分子为1
    int mother = cont[contSize-1];//分母为数组最后一个元素
    int tmp = 0;//提供交换功能
    for(int i = contSize - 2;i>=0;i--){
        tmp = mother;//保存上次分母
        mother = mother*cont[i]+son;//计算新分母
        son = tmp;//分子继承tmp
    }
    res[0] = mother;//因为数组首元素计算完成后未发生分子分母交换,此处存储时反序即可
    res[1] = son;
    return res;
}

【剑指offer15】【二进制中1的个数】https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
int hammingWeight(uint32_t n) {
    int cnt = 0;
    for(int i = 0;i<32;i++){
        if((n>>i)&1)
            cnt++;
    }
    return cnt;
}

【剑指offer17】：打印从1到最大的n位数
int* printNumbers(int n, int* returnSize){
    int max = pow(10,n) - 1;
    *returnSize = max;
    int* res = (int*)malloc(sizeof(int)*max);
    for(int i = 0;i < max;i++)
        res[i] = i + 1;
    return res;
}

【LCP22】【黑白方格画】：https://leetcode-cn.com/problems/ccw6C7/
int factorail(int n,int m){
    int son = 1,mother = 1; 
    for(int k = n;k>n-m;k--)
        son*=k;
    for(int k = 1;k<=m;k++)
        mother*=k;
    return son/mother;
}
int paintingPlan(int n, int k){
    if(k==n){
        if(k==1)//n=k=1
            return 1;
        else//n==k!=1
            return 2*n;
    }
    if(k==n*n || k==0)//白板或者黑板
        return 1;
    if(k<n)//一行都画不满，不让进循环，否则浪费空间时间
        return 0;
    int cnt = 0;
    for(int i = 1;i<n;i++){
        int res = k - i*n;
        if(res>0){
            int flag = res%(n-i)==0?res/(n-i)<n?res/(n-i):0:0;
            if(flag)
                cnt+=factorail(n,i)*factorail(n,flag);
        }
        else if(res == 0)
            cnt += 2*factorail(n,i);
        else
            continue;
    }
    return cnt;
}

【剑指Offer18】【删除链表的节点】：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/
struct ListNode* deleteNode(struct ListNode* head, int val){
    if(NULL == head)
        return head;
    struct ListNode* p = head;
    struct ListNode* pre = NULL;
    while(p){
        if(p->val == val && p == head)
            head = p->next;
        else if(p->val == val)
            pre->next = p->next;
        pre = p;
        p=p->next;
    }
    return head;
}

【剑指offer27】【二叉树的镜像】：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/
struct TreeNode* mirrorTree(struct TreeNode* root){
    if(NULL == root)
        return NULL;
    struct TreeNode* tmp = root->right;
    root->right = root->left;
    root->left = tmp;
    mirrorTree(root->left);
    mirrorTree(root->right);
    return root;
}

【剑指offer32】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
int height(struct TreeNode* root){
    if(NULL == root)
        return 0;
    int h_l = height(root->left)+1;
    int h_r = height(root->right)+1;
    return h_l>h_r?h_l:h_r;
 }
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = height(root);
    int** res = (int**)malloc(sizeof(int*)*h);
    *returnSize = h;
    *returnColumnSizes = (int*)malloc(sizeof(int)*h);

    struct TreeNode* q1[1000],*q2[1000];
    int q1_size =0,q2_size=0;
    q1[0]=root;
    q1_size++;
    int layer = 0;
    while(layer<h){
        res[layer] = (int*)malloc(sizeof(int)*q1_size);
        for(int i= 0;i<q1_size;i++)
            res[layer][i] = q1[i]->val;
        (*returnColumnSizes)[layer] = q1_size;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left!=NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right!=NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode *)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        layer++;
    }
    return res;
}

【剑指offer42】:最大子序和
int maxSubArray(int* nums, int numsSize){
    int submax = nums[0];
    int max = nums[0];
    for(int i= 1;i<numsSize;i++){  
        if(submax<0)
            submax = nums[i];
        else  
            submax += nums[i];
        max = submax>max?submax:max; 
    }
    return max;
}

【LeetCode151】【剑指offer58】【翻转单词顺序】：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/
int len = strlen(s);
    if (len == 0)
        return s;
    char* res = (char*)malloc(len + 1);
    memset(res, ' ', len + 1);
    int i = len;
    char* pre = s;
    char* help = NULL;
    char* target = NULL;
    while (*pre) {
        while (*pre && *pre == ' ')//跳空格
            pre++;
        help = pre;//help指向单词首字母
        while (*pre && *pre != ' ')
            pre++;
        target = pre;//target指向单词右侧
        if (*pre == '\0') {//最后一个单词，pre会指向'\0'
            res[i--] = ' ';
            pre--;
        }
        while (help-1 != pre) {//后退式复制带空格
            res[i--] = *pre;
            pre--;
        }
        pre = target;//复制完成pre回到空格处，寻找下一个单词
    }
    res[len] = '\0';//原本此处被放空格
    while (*res == ' ')
        res++;
    return res;
}

LeetCode【202】【快乐数】:https://leetcode-cn.com/problems/happy-number/
int helper(int n){
    int res = 0;
    while(n){
        int tmp = n%10;
        res += tmp*tmp;
        n/=10;
    }
    return res;
}
bool isHappy(int n){
    int slow = n,fast = n;
    do{
        slow = helper(slow);
        fast = helper(helper(fast));
    }while(slow!=fast);
    return slow==1;
}

LeetCode【461】【汉明距离】：https://leetcode-cn.com/problems/hamming-distance/
int hammingDistance(int x, int y){
    int n = x^y;
    int res = 0;
    for(int i = 0;i<32;i++)
        if((n>>i)&1)
            res++;
    return res;
}

LeetCode【415】【字符串相加】：https://leetcode-cn.com/problems/add-strings/
char * addStrings(char * num1, char * num2){
    int len1 = strlen(num1);
    int len2 = strlen(num2);
    char* long_s,*short_s;
    len1>len2?(long_s = num1,short_s = num2):(long_s = num2,short_s = num1);
    len1 = strlen(long_s),len2 = strlen(short_s);
    char* res = (char*)malloc(sizeof(char)*(len1+2));//预留结束符与前导位置
    memset(res,'0',len1+2);
    res[len1+1] = '\0';
    int flag = 0;
    for(int i = len1-1;i>=0;i--){
        int tmp = 0;
        if(i-len1+len2>=0)
            tmp = flag + (long_s[i]-'0')+(short_s[i-len1+len2]-'0');
        else
            tmp = flag + long_s[i]-'0';
        res[i+1]= tmp % 10 + '0';
        if(tmp>9)
            flag = 1;
        else
            flag = 0;
    }
    if(flag == 1)
        res[0]='1';
    else 
        return res + 1;
    return res; 
}

LeetCode【412】【Fizz Buzz】：https://leetcode-cn.com/problems/fizz-buzz/
char ** fizzBuzz(int n, int* returnSize){
    int cnt = 0;
    *returnSize = n;
    char** res = (char**)malloc(sizeof(char*)*n);
    for(int i =1;i<=n;i++){
        if(i%5==0&&i%3==0){
            char* tmp = (char*)malloc(sizeof(char)*9);
            memset(tmp,'\0',9);
            strcat(tmp,"FizzBuzz");
            res[i-1] = tmp;
        }else if(i%5==0){
            char* tmp = (char*)malloc(sizeof(char)*5);
            memset(tmp,'\0',5);
            strcat(tmp,"Buzz");
            res[i-1] = tmp;
        }else if(i%3==0){
            char* tmp = (char*)malloc(sizeof(char)*5);
            memset(tmp,'\0',5);
            strcat(tmp,"Fizz");
            res[i-1] = tmp;
        }else{
            int cnt = 0;
            int num = i;
            while(num){
                cnt++;
                num/=10;
            }
            char* tmp = (char*)malloc(sizeof(char)*(cnt+1));
            memset(tmp,'\0',cnt+1);
            for(int j =0;j<cnt;j++){
                tmp[j] = i/(int)pow(10,cnt-j-1)%10+'0';
            }
            res[i-1] = tmp;
        }
    }
    return res;
}

LeetCode【434】【字符串中的单词数】：https://leetcode-cn.com/problems/number-of-segments-in-a-string/
int countSegments(char * s){
    int cnt = 0;
    char* pre = s;
    while(*pre){
        while(*pre && *pre == ' ')//越过空格
            pre++;
        while(*pre && *pre != ' ')//寻找单词后的空格
            pre++;
        if (*(pre-1)!=' ')
            cnt++;
    }
    return cnt;
}

LeetCode【441】【排列硬币】：https://leetcode-cn.com/problems/arranging-coins/
int arrangeCoins(int n){
    int cnt=0;
    for(int i=1;n>=0;i++){
        n-=i;
        cnt++;
    }
    return cnt-1;
}

LeetCode【448】【找到所有数组中消失的数字】：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){
    int* res = (int*)malloc(sizeof(int)*(numsSize/2));
    int cnt = 0;
    for(int i = 0;i<numsSize;i++){
      if(nums[abs(nums[i])-1]>0)
        nums[abs(nums[i])-1] *= -1;
    }
    for(int i = 0;i<numsSize;i++){
      if(nums[i]>0)
        res[cnt++] = i + 1;
    }    
    *returnSize = cnt;
    return res;
}

LeetCode【409】【最长回文串】：https://leetcode-cn.com/problems/longest-palindrome/
int longestPalindrome(char * s){
    int cnt[128]={0},res = 0;
    for(int i = 0;i<strlen(s);i++)
        cnt[s[i]]++;
    for(int i =0;i<128;i++)
        res += cnt[i]/2*2;
    return res<strlen(s)?res+1:res;
}

LeetCode【404】【左叶子之和】：https://leetcode-cn.com/problems/sum-of-left-leaves/
bool isleaf(struct TreeNode* root){
    return !root->left && !root->right;
}
int dfs(struct TreeNode* root){
    int ans = 0;
    if(root->left)
        ans += isleaf(root->left)?root->left->val:dfs(root->left);
    if(root->right && !isleaf(root->right))
        ans += dfs(root->right);
    return ans;
}
int sumOfLeftLeaves(struct TreeNode* root){
    return root?dfs(root):0; 
}

LeetCode【405】【数字转化为十六进制数】：https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/
char * toHex(int num){
    if(0 == num)
        return "0";
    char *s = "0123456789abcdef";
    int index = 0;
    char* res = (char*)malloc(9);
    memset(res,'0',9);
    res[8] = '\0';
    for(int i = 0;i < 8; i++)
        res[7-i] = s[((unsigned int)num>>4*i)&(0xf)];
    while(*res == '0')
        res++;
    return res;
}

LeetCode【401】【二进制手表】：https://leetcode-cn.com/problems/binary-watch/
int bitnum(int n){
     int cnt = 0;
     while(n){
        if(n&1)
            cnt++;
        n>>=1;
     }
     return cnt;
 }
char ** readBinaryWatch(int num, int* returnSize){
    *returnSize = 0;
     for(int h = 0;h < 12; h++){
        for(int m = 0;m < 60; m++){
            int k = bitnum(h) + bitnum(m);
            if(k == num)
                (*returnSize)++;
        }
    }
    char** res = (char**)malloc(sizeof(char*)*(*returnSize));
    int i = 0;
    for(int h = 0;h < 12; h++){
        for(int m = 0;m < 60; m++){
            int k = bitnum(h) + bitnum(m);
            if(k == num){
                res[i] = (char*)malloc(6);
                sprintf(res[i++],"%d:%02d",h,m);
            }
        }
    }
    return res;
}

LeetCode【231】【2的幂】：https://leetcode-cn.com/problems/power-of-two/
bool isPowerOfTwo(int n){
    return n > 0 && !(n & (n-1));
}

LeetCode【326】【3的幂】：https://leetcode-cn.com/problems/power-of-three/
bool isPowerOfThree(int n){
    if (n < 1)
        return false;
    while(n%3 == 0)
        n/=3;
    return n==1?true:false;
}

LeetCode【342】【4的幂】：https://leetcode-cn.com/problems/power-of-four/
bool isPowerOfFour(int n){
    if(n<1)
        return false;
    while(n%4==0)
        n/=4;
    return n==1?true:false;
}

LeetCode【371】【两整数之和】：https://leetcode-cn.com/problems/sum-of-two-integers/
int getSum(int a, int b){
    while(b!=0){
        int tmp = a^b;
        b = ((unsigned int)(a&b) << 1);
        a = tmp;
    }
    return a;
}

LeetCode【374】【猜数字大小】：https://leetcode-cn.com/problems/guess-number-higher-or-lower/
int guessNumber(int n){
	int low = 1;
    int high = n;
    while(low<=high){
        int mid = low+(high-low)/2;
        int res = guess(mid);
        if(res == 0)
            return mid;
        else if(res < 0)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return -1;
}

LeetCode【389】【找不同】：https://leetcode-cn.com/problems/find-the-difference/
char findTheDifference(char * s, char * t){
    int sn[26]={0};
    int ls = strlen(s),lt = strlen(t);
    for(int i = 0;i<ls;i++)
        sn[s[i]-'a']++;
    for(int i = 0;i<lt;i++){
        sn[t[i]-'a']--;
        if (sn[t[i] - 'a'] < 0) {
            return t[i];
        }
    }
    return ' ';
}

面试题【01.01】【判定字符串是否唯一】：https://leetcode-cn.com/problems/is-unique-lcci/
bool isUnique(char* astr){
    int num[26] = {0};
    int len = strlen(astr);
    for(int i=0;i<len;i++)
        num[astr[i]-'a']++;
    for(int i=0;i<26;i++)
        if(num[i]>1)
            return false;
    return true;
}

面试题【01.02】【判定是否为字符重排】：https://leetcode-cn.com/problems/check-permutation-lcci/
bool CheckPermutation(char* s1, char* s2){
    int nums[26]={0};
    int ls1 = strlen(s1),ls2 = strlen(s2);
    for(int i = 0;i<ls1;i++)
        nums[s1[i]-'a']++;
    for(int i = 0;i<ls2;i++)
        nums[s2[i]-'a']--;
    for(int i = 0;i<26;i++)
        if(nums[i]!=0)
            return false;
    return true;
}

面试题【01.06】【字符串压缩】：https://leetcode-cn.com/problems/compress-string-lcci/
static int _len(int k)
{
    int cnt = 1;
    while(k/=10)
        cnt++;
    return cnt;
}
char* compressString(char* S){
    int charsSize = strlen(S);
    int size = 100000;
    char* chars = (char*)malloc(1000001);
    memset(chars,'\0',size+1);
    int follow = 0;
    int pre = 0;
    int t = 0;
    while(pre<charsSize){
        while(pre<charsSize&&S[follow]==S[pre])//出此循环说明pre已到下一个字符
            pre++;
        chars[t] = S[follow];//将字符填入
        t++;
        int k = pre - follow;//计算与chars[follow]相同字符的数目
        int nums = _len(k);//获取k的位数
        while(nums)//只有个数大于1才能填入计数
            chars[t++] = k/(int)pow(10,--nums)%10+'0';//分数位填入
        if(pre<charsSize)//字符数组未遍历完
            follow = pre;
        else //遍历完
            break;
    }
    return strlen(chars)>=charsSize?S:chars;
}

LeetCode【268】【丢失的数字】：https://leetcode-cn.com/problems/missing-number/
int missingNumber(int* nums, int numsSize){
    int tmp=0;
    for(int i = 0;i<numsSize;i++)
        tmp^=nums[i],tmp^=i;
    for(int i = 0;i<=numsSize;i++)
        tmp ^= i;
    return tmp;
}

LeetCode【242】【有效的字母异位词】：https://leetcode-cn.com/problems/valid-anagram/
bool isAnagram(char * s, char * t){
    int lens = strlen(s);
    int lent = strlen(t);
    if(lens != lent)
        return false;
    int num[26]={0};
    for(int i = 0;i<lens;i++){
            num[s[i]-'a']++;
            num[t[i]-'a']--;
    }
    for(int i = 0;i<26;i++)
        if(num[i]>0)
            return false;
    return true;
}

LeetCode【153】【寻找旋转排序数组的最小值】：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/
int findMin(int* nums, int numsSize){
    int left = 0,right = numsSize - 1;
    while(left<right){
        int mid = left+(right-left)/2;
        if(nums[mid]>nums[right])
            left = mid + 1;
        else
            right = mid;
    }
    return nums[left];
}

剑指offer/LeetCode【11/154】【旋转数组的最小数字】：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/
int minArray(int* numbers, int numbersSize){
    int left = 0,right = numbersSize-1;
    while(left<right){
        int mid=left+(right-left)/2;
        if(numbers[mid]>numbers[right])
            left = mid + 1;
        else if(numbers[mid] == numbers[right])
            right--;
        else
            right = mid;
    }
    return numbers[left];
}

LeetCode【367】【有效的完全平方数】：https://leetcode-cn.com/problems/valid-perfect-square/
bool isPerfectSquare(int num){
    int i = -1;
    while(num>0){
        i+=2;
        num-=i;
    }
    return num==0?true:false;
}

剑指offer【06】【从头到尾打印链表】：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/
int* reversePrint(struct ListNode* head, int* returnSize){
    int len = 0;
    struct ListNode* p = head;
    while(p){
        p = p->next;
        len++;
    }
    *returnSize = len;
    p = head;
    int* res = (int*)malloc(sizeof(int)*len);
    for(int i = len - 1;i>=0;i--){
        res[i] = p->val;
        p = p->next;
    }
    return res;
}

剑指offer【16】【数值的整数次方】：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/
double myPow(double x, int n){
    double res = 1.0;
    long int y = (long int)n;
    if(n<0){
        x= 1.0/x;
        y=-y;
    }
    while(y){
        if(y&1)
            res*=x;
        x*=x;
        y/=2;
    }
    return res;
}

剑指offer【05】【替换空格】：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/
char* replaceSpace(char* s){
    int len = strlen(s);
    char*res = (char*)malloc(sizeof(char)*3*len+1);
    memset(res,'\0',3*len+1);
    int cnt = 0;
    for(int i = 0;i<len;i++){
        if(s[i] == ' '){
            strcat(res,"%20");
            cnt+=3;
        }
        else
            res[cnt++] = s[i];
    }
    return res;
}

剑offer【09】【用两个栈实现队列】：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/
#define NUM 10000
typedef struct {
    int *s1 ;
    int len_s1;
    int *s2;
    int len_s2;
} CQueue;

CQueue* cQueueCreate() {
    CQueue* Q = (CQueue*)malloc(sizeof(CQueue));
    Q->s1 = (int*)malloc(sizeof(int)*NUM);
    Q->s2 = (int*)malloc(sizeof(int)*NUM);
    Q->len_s1 = -1;
    Q->len_s2 = -1;
    return Q;
}

void cQueueAppendTail(CQueue* obj, int value) {
    if(obj->len_s1>=10000)
        return;
    obj->s1[++obj->len_s1] = value;
}

int cQueueDeleteHead(CQueue* obj) {
    if(obj->len_s2 == -1 && obj->len_s1 == -1)
        return;
    if(obj->len_s2 == -1){
        while(obj->len_s1 != -1)
            obj->s2[++obj->len_s2] = obj->s1[obj->len_s1--];
    }
    return obj->s2[obj->len_s2--];
}

void cQueueFree(CQueue* obj) {
    free(obj->s1);
    free(obj->s2);
    obj->s1 = NULL;
    obj->s2 = NULL;
    obj->len_s1 = -1;
    obj->len_s2 = -1;
}

剑指offer【29】【顺时针打印矩阵】：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/
int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    if(matrixSize == 0 || matrixColSize[0] == 0){
        *returnSize = 0;
        return NULL;
    }
    int all = matrixSize*matrixColSize[0];
    int* res = (int*)malloc(sizeof(int)*all);
    *returnSize = all;
    int left = 0,right = matrixColSize[0]-1 ;
    int top = 0,bottom = matrixSize-1;
    int cnt = 0;
    while(cnt<all){
        int l = left,r = right,t = top,b = bottom;
       while(cnt<all && l<=right)
           res[cnt++]=matrix[top][l++];
        t++;
        while(cnt<all && t<=bottom)
            res[cnt++]=matrix[t++][right];
        r--;
        while(cnt<all && r>=left)
            res[cnt++]=matrix[bottom][r--];
        b--;
        while(cnt<all && b>top)
            res[cnt++]=matrix[b--][left];
        left++;
        right--;
        top++; 
        bottom--;
    }
    return res;      
}

LeetCode【392】【判断子序列】：https://leetcode-cn.com/problems/is-subsequence/
bool isSubsequence(char * s, char * t){
    if(NULL == t && NULL == s)
        return true;
    if(NULL == s)
        return true;
    if(NULL == t)
        return false;
    while(*t){
        if(*t == *s)
            s++;
        t++;
    }
    return *s == '\0';
}

LeetCode【400】【第N位数字】：https://leetcode-cn.com/problems/nth-digit/
int helper(long int n){
    int cnt = 0;
    while(n>0){
        n -= 9*(long int)pow(10,cnt)*(cnt+1);
        cnt++;
    }
    return cnt;
}
int findNthDigit(int n){
    int pos = helper(n);//确定处于几位数范围
    int cnt = 0;
    while(cnt < pos - 1)//计算剩余的部分,刨去位数<pos的区间
        n-=(9*(int)pow(10,cnt++)*cnt);
    int start = (int)pow(10,pos-1);//最小的pos位数
    int count = n / pos,res = n % pos; //计算第n个数字位置之前有多少整数及余数
    int flag = res>=1?1:0; 
    int num = start + count - 1 + flag;//计算第n个数字位于哪个数字上
    res = n - (num-start)*pos; //计算位于num的第几位
    return (num/(int)pow(10,pos-res))%10;
}

LeetCode【397】【整数替换】：https://leetcode-cn.com/problems/integer-replacement/
int integerReplacement(int n){
    int cnt = 0;
    while(n>1){
        if(n == INT_MAX)//上界单独处理
            n--,n/=2,n++,cnt++;
        else if(!(n%2))//偶数
            n>>=1;
        else //奇数
            n += ((n & 2) == 0 || n == 3)?-1:1;//0x？？？？？？？[??01]及0x11减1，其他++1；
        cnt++;
    }
    return cnt;
}

LeetCode【2】【两数相加】：https://leetcode-cn.com/problems/add-two-numbers/
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode* addres = NULL;
    struct ListNode* p = addres;
    int flag = 0;
    while(l1||l2){
        int n1 = l1?l1->val:0;
        int n2 = l2?l2->val:0;
        int tmp = n1 + n2 + flag;
        flag = tmp>9?1:0;
        if (!addres){
            p = addres = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->val = tmp%10;
            p->next = NULL; 
        }
        else{
            p->next = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->next->val = tmp%10;
            p->next->next = NULL;
            p = p->next;
        }
        if(l1)
            l1=l1->next;
        if(l2)
            l2=l2->next;
    }
    if(flag > 0){
         p->next = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->next->val = flag;
            p->next->next = NULL;
    }
    return addres;
}

LeetCode【492】【构造矩形】：https://leetcode-cn.com/problems/construct-the-rectangle/
int* constructRectangle(int area, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    int l = sqrt(area);
    while(area%l)
        l++;
    int w = area/l;
    res[0] = l>w?l:w;
    res[1] = l>w?w:l;
    return res;
}

LeetCode【344】【反转字符串】：https://leetcode-cn.com/problems/reverse-string/
void reverseString(char* s, int sSize){
    for(int i = 0;i<sSize/2;i++){
        char tmp = s[sSize-1-i];
        s[sSize-i-1]=s[i];
        s[i] = tmp;
    }
}

LeetCode【263】【丑数】：https://leetcode-cn.com/problems/ugly-number/
bool isUgly(int num){
    if(num<1)
        return false;
    if(1 == num)
        return true;
    while((num != 2) && (num != 3) && (num != 5)){
        if(num%2==0)
        num/=2;
        else if(num%3==0)
            num/=3;
        else if(num%5==0)
            num/=5;
        else
            return false;
    }
    return true;
}

LeetCode【283】【移动0】：https://leetcode-cn.com/problems/move-zeroes/
void moveZeroes(int* nums, int numsSize){
    int left = 0,right = left;
    while(right<numsSize){
        while(left < numsSize - 1  && nums[left] != 0)
            left++;
        right = left + 1;
        while(right < numsSize && nums[right] == 0)
            right++;
        if(right<numsSize){
            nums[left] = nums[right];
            nums[right] = 0;
            left++;
        }
    }
}

LeetCode【303】【区域和检索-数组不可变】：https://leetcode-cn.com/problems/range-sum-query-immutable/
typedef struct {
    int *num;
    int *sum;
} NumArray;

NumArray* numArrayCreate(int* nums, int numsSize) {
    NumArray* res = (NumArray*)malloc(sizeof(NumArray));
        return NULL;
    res->num = nums;
    res->sum = (int *)malloc(sizeof(int)*numsSize);
    int tmp = 0;
    for(int i = 0;i<numsSize;i++){
        res->sum[i] = tmp + res->num[i];
        tmp+=res->num[i];
    }
    return res;
}

int numArraySumRange(NumArray* obj, int i, int j) {
    if(i==0)
        return obj->sum[j];
    return obj->sum[j]-obj->sum[i-1];
}

void numArrayFree(NumArray* obj) {
    free(obj);
}

/**
 * Your NumArray struct will be instantiated and called as such:
 * NumArray* obj = numArrayCreate(nums, numsSize);
 * int param_1 = numArraySumRange(obj, i, j);
 
 * numArrayFree(obj);
*/

剑指offer【14-1】【减绳子】：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/
int cuttingRope(int n){
    if(n==2)
        return 1;
    if(n==3)
        return 2;
    int res = 1;
    while(n){
        if(n==1)
            return res/3*4;
        else if(n==2)
            return res*2;
        else{
            n-=3;
            res*=3;
        }
    }
    return res;
}

LeetCode【349】【两个数组的交集】：https://leetcode-cn.com/problems/intersection-of-two-arrays/
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    Sort(nums1,0,nums1Size);
    Sort(nums2,0,nums2Size);
    int len = nums1Size<nums2Size?nums1Size:nums2Size;
    int * res = (int*)malloc(sizeof(int)*len);
    int cnt =  0;
    int index1 = 0,index2 = 0;
    while(index1<nums1Size&&index2<nums2Size){
        int num1 = nums1[index1],num2 = nums2[index2];
        if(num1 == num2){
            if(cnt == 0 || nums1[index1] != res[cnt-1])
                res[cnt++] = nums1[index1]; 
            index1++;
            index2++;
        }else if(num1<num2)
            index1++;
        else
            index2++;
    }
    *returnSize = cnt;
    return res;
}


LeetCode【350】【l两个数组的交集II】：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/
int QkPass(int* a,int left,int right){
     int low = left,high = right - 1;
     int key = a[low];
     while(low<high){
        while(low<high && a[high]>=key)
            high--;
        a[low] = a[high];
        while(low<high && a[low]<key)
            low++;
        a[high] = a[low];
     }
    a[low] = key;
    return low;
 }
 void Sort(int* a,int left,int right){
     if(left<right){
         int pos = QkPass(a,left,right);
         Sort(a,left,pos);
         Sort(a,pos+1,right);
     }
 }
int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    Sort(nums1,0,nums1Size);
    Sort(nums2,0,nums2Size);
    int len = nums1Size<nums2Size?nums1Size:nums2Size;
    int * res = (int*)malloc(sizeof(int)*len);
    int cnt =  0;
    int index1 = 0,index2 = 0;
    while(index1<nums1Size&&index2<nums2Size){
        int num1 = nums1[index1],num2 = nums2[index2];
        if(num1<num2)
            index1++;
        else if(num1>num2)
            index2++;
        else{
            res[cnt++] = nums1[index1]; 
            index1++;
            index2++;
        }
    }
    *returnSize = cnt;
    return res;
}

剑指offer【48】【最长不含重复字符的子字符串】：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/
int lengthOfLongestSubstring(char* s){
    int len = strlen(s);
    int alpha[128]={0};//标志数组
    char* front = s,*rear = s;
    int cnt = 0;
    int max = 0;
    while(*front){
        if(alpha[*front]==0){//未出现过
            alpha[*front] = 1;
            cnt++;
        }else{
            while(*rear != *front){//出现重复字符
                alpha[*rear]=0;
                rear++;
                cnt--; 
            }
            rear++;
        }
        front++;
        max = max>cnt?max:cnt;
    }
    return max;
}

LeetCode【48】【旋转图像】：https://leetcode-cn.com/problems/rotate-image/
void rotate(int** matrix, int matrixSize, int* matrixColSize){
    for(int i = 0;i<matrixSize/2;i++){
        for(int j = 0;j<(matrixSize+1)/2;j++){
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[matrixSize-1-j][i];
            matrix[matrixSize-1-j][i] = matrix[matrixSize-1-i][matrixSize-1-j];
            matrix[matrixSize-1-i][matrixSize-1-j] = matrix[j][matrixSize-1-i];
            matrix[j][matrixSize-1-i] = tmp;
        }
    }
}

剑指offer【62】【圆圈中最后剩下的数字】：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/
int f(int n,int m){
    int  x = 0;
    if(n == 1)//长度为1，索引为00
        return 0;
    else
        x = f(n-1,m);
    return (m + x) % n; //每次删除一个，0索引处于m+x处，溢出取模 
}
int lastRemaining(int n, int m) {
    return f(n,m);  
}

剑指offer【59-I】【滑动窗口的最大值】：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    if(numsSize == 0){
        *returnSize = 0;
        return NULL;
    }
    *returnSize = numsSize - k + 1;//返数字数目可推导得到
    int* res = (int*)malloc(sizeof(int)*(*returnSize));
    int left = 0,right = k - 1;
    int count = 0;
    int maxindex = 0;
    while(right<numsSize){
        if(maxindex == 0 || maxindex < left){//第一个窗口 || 最大值索引已不在新窗口内
            int j = left;
            maxindex = left;
            while(j<=right){//寻找新的最大值索引
                if(nums[maxindex]<nums[j])
                    maxindex=j;
                j++;
            }
        }else{//最大值索引仍在窗口内
            if(nums[right]>nums[maxindex])//新进窗口的值最大
                maxindex = right;
        }
        res[count++] = nums[maxindex];//最大值写入
        left++,right++; //窗口移动
    }
    return res;
}

【单调队列解法】：
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    if(k == 1){
        *returnSize = numsSize;
        return nums;
    }
    if(numsSize == 0){
        *returnSize = 0;
        return NULL;
    }
    *returnSize = numsSize + 1 - k;
    int* res = (int*)malloc(sizeof(int)*(*returnSize));
    int* deque = (int*)malloc(sizeof(int)*numsSize);//单调队列
    int ql = 0,qr = 0;//队列索引
    int left = 0;//数组索引
    int cnt = 0;
    while(left<numsSize){
        while(ql != qr && nums[left] > nums[deque[qr-1]])//栈尾元素小于将入队元素
            qr--;//之所以是>而不>=，原因在于尽可能令最大值的索引小
        deque[qr++] = left;//入队
        if(left >= k - 1){//窗口
            res[cnt++] = nums[deque[ql]];
            if(ql != qr && deque[ql] <= left -k + 1)
                ql++;
        }
        left++;
    }
    return res;
}

剑指offer【61】【扑克牌中的顺子】：https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/
bool isStraight(int* nums, int numsSize){
    for(int i = 1;i<numsSize;i++){
        if(nums[i]<nums[i-1]){
            int key = nums[i];
            int j = i - 1;
            for( ;j>=0&&nums[j]>key;j--)
                nums[j+1]=nums[j];
            nums[j+1] = key;
        }
    }
    int left = 0;
    for(int i = 0;i<numsSize - 1;i++){
        if(nums[i]==0)//跳过0，并将left定在最小值的索引处
            left++;
        else if(nums[i] == nums[i+1])//前两个重复
            return false;
        else{}
    }
    return nums[numsSize-1]-nums[left]<5?true:false;
}

剑指offer【64】【求1+2+……+n】:https://leetcode-cn.com/problems/qiu-12n-lcof/
int sumNums(int n){
    //-1 & x = x
    //10000的二进制：10 0111 0001 0000，最高位对应2^13
    int n1 = (n&-((n+1)>>0&1))<<0;//n+1的最低位是否为1，为1说明结果里含n
    int n2 = (n&-((n+1)>>1&1))<<1;//n+1的次低位是否位1，为1说明结果里含有2*n
    int n3 = (n&-((n+1)>>2&1))<<2;//n+1的较低位是否位1，为1说明结果里含有4*n
    int n4 = (n&-((n+1)>>3&1))<<3;
    int n5 = (n&-((n+1)>>4&1))<<4;
    int n6 = (n&-((n+1)>>5&1))<<5;
    int n7 = (n&-((n+1)>>6&1))<<6;
    int n8 = (n&-((n+1)>>7&1))<<7;//eg,n=5,result=5*6/2=15
    int n9 = (n&-((n+1)>>8&1))<<8;//6 = 2^1 + 2^2
    int n10 = (n&-((n+1)>>9&1))<<9;//result = (5^1 + 5^2)/2 
    int n11 = (n&-((n+1)>>10&1))<<10;
    int n12 = (n&-((n+1)>>11&1))<<11;
    int n13 = (n&-((n+1)>>12&1))<<12;
    int n14 = (n&-((n+1)>>13&1))<<13;
    //上述过程即把n+1拆分为2的幂和，之后分别与n相乘
    return (n1+n2+n3+n4+n5+n6+n7+n8+n9+n10+n11+n12+n13+n14)>>1;//n*(n+1)/2
}

剑指offer【66】【构建乘积数组】：https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/
int* constructArr(int* a, int aSize, int* returnSize){
    if(aSize==0){
        *returnSize = 0;
        return NULL;
    }
    *returnSize = aSize;
    int* res = (int*)malloc(sizeof(int)*aSize);
    int* left = (int*)malloc(sizeof(int)*aSize);
    int* right = (int*)malloc(sizeof(int)*aSize);
    left[0]=1,right[aSize-1]=1;
    for(int i = 1;i<aSize;i++)
        left[i]=a[i-1]*left[i-1];
    for(int i = aSize - 2;i>=0;i--)
        right[i]=right[i+1]*a[i+1];
    for(int i = 0;i<aSize;i++)
        res[i]=left[i]*right[i];
    return res;
}

面试题【01.04】【回文排列】：https://leetcode-cn.com/problems/palindrome-permutation-lcci/
bool canPermutePalindrome(char* s){
    int cnt[128]={0};
    for(int i = 0;i<strlen(s);i++)
        cnt[s[i]]++;
    int flag = 0;
    for(int i = 0;i<128;i++){
        if(cnt[i]%2)
            flag++;
        if(flag > 1)
            return false;
    }
    return true;   
}

LeetCode【537】【复数乘法】：https://leetcode-cn.com/problems/complex-number-multiplication/
char * complexNumberMultiply(char * a, char * b){
    int x1 = atoi(a),x2 = atoi(b);
    while(*a!='+')
        a++;
    a++;
    while(*b!='+')
        b++;
    b++;
    int y1 = atoi(a),y2=atoi(b);
    int x = x1*x2-y1*y2;//实部
    int y = x1*y2+x2*y1;//虚部
    char *res = (char*)malloc(15);//-10000+-10000i
    sprintf(res,"%d+%di",x,y);
    return res;
} 

LeetCode【520】【检测大写字母】：https://leetcode-cn.com/problems/detect-capital/
bool detectCapitalUse(char * word){
    if('a' <= *word && *word<='z'){//首字母小写
        while(*word){//纯小写
            if('A'<=*word && *word <= 'Z')//出现大写
                return false;
            word++;
        }
    }else{//首字母大写
        word++;//第二个字母
        if('a' <= *word && *word <= 'z'){//第二个字母小写
            while(*word){//纯小写
                if('A' <= *word && *word <= 'Z')//出现大写
                    return false;
                word++;
            }
        }else{//第二个字母大写
            while(*word){//要求纯大写
                if(islower(*word))
                    return false;
                word++;
            }
        }
    }
    return true;
}

LeetCode【540】【有序数组中的单一元素】：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/
int singleNonDuplicate(int* nums, int numsSize){
    int left = 0,right = numsSize-1;
    while(left<right){
        int mid = left + ((right-left)>>1);
        if(mid%2)
            mid--;
        if(nums[mid] == nums[mid+1])
            left = mid + 2;
        else
            right = mid;
    }
    return nums[left];
}

LeetCode【485】【最大连续 1 的个数】：https://leetcode-cn.com/problems/max-consecutive-ones/
int findMaxConsecutiveOnes(int* nums, int numsSize){
    int cnt = 0;
    int max = 0;
    for(int i = 0;i<numsSize;i++){
        if(nums[i]==0){
            max = max>cnt?max:cnt;
            cnt = 0;
        }else
            cnt++;
    }
    return max >cnt?max:cnt;
}

LeetCode【面试题01.08】【零矩阵】：https://leetcode-cn.com/problems/zero-matrix-lcci/
void setZeroes(int** matrix, int matrixSize, int* matrixColSize){
    if(matrixSize == 0 || matrixColSize[0] == 0)
        return;
    int* row = (int*)malloc(sizeof(int)*matrixSize);
    int* col = (int*)malloc(sizeof(int)*matrixColSize[0]);
    memset(row,0,sizeof(int)*matrixSize);
    memset(col,0,sizeof(int)*matrixColSize[0]);
    for(int i = 0;i<matrixSize;i++){
        for(int j = 0;j<matrixColSize[0];j++)
            if(matrix[i][j]==0){
                row[i] = 1;
                col[j] = 1;
            }
    }
    int tmp =0;
    while(tmp<matrixSize){
        if(row[tmp] == 1){
            int j = 0;
            while(j<matrixColSize[0])
                matrix[tmp][j++] = 0;
        }
        tmp++;
    }
    tmp = 0;
    while(tmp<matrixColSize[0]){
        if(col[tmp] == 1){
            int i = 0;
            while(i<matrixSize)
                matrix[i++][tmp] = 0;
        }
        tmp++;
    }
}

剑指offer【56-II】【数组中数字出现的次数II】：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/
int singleNumber(int* nums, int numsSize){
    int dk = numsSize;
    while(dk/=2){
        for(int i = dk;i<numsSize;i++){
            if(nums[i]<nums[i-dk]){
                int tmp = nums[i];
                int j = 0;
                for(j = i-dk;j>=0&&tmp<nums[j];j-=dk)
                    nums[j+dk] = nums[j];
                nums[j+dk] = tmp; 
            }
        }
    }
    for(int i = 0;i<numsSize-1;i+=3)
        if(nums[i]!=nums[i+1])
            return nums[i];
    return nums[numsSize-1];
}

面试题【01.05】【一次编辑】：https://leetcode-cn.com/problems/one-away-lcci/
bool oneEditAway(char* first, char* second){
    int len1 = strlen(first);
    int len2 = strlen(second);
    if(fabs(len1-len2)>1)//三个操作使得两字符串长度差不大于1
        return false;
    if(len1 == len2){//换 or 不变
        int cnt = 0;
        for(int i = 0;i<len1;i++){
            if(first[i]!=second[i])
                cnt++;
            if(cnt>1)
                return false;
        }
    }else{//删
        char* longs = len1>len2?first:second;
        char* shorts = len1>len2?second:first;
        int len = strlen(longs);
        int flag = 1;
        int index1 = 0,index2 = 0;
        while(index1<len){
            if(longs[index1]!=shorts[index2]){
                if(flag){
                    flag = 0;
                    index1++;
                }else
                    return false;
            }else
                index1++,index2++;
        }
    } 
    return true;
}

面试题【01.09】【字符串轮转】：https://leetcode-cn.com/problems/string-rotation-lcci/
bool isFlipedString(char* s1, char* s2){
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    if(len1!=len2)
        return false;
    if((!len1) && len1 == len2)
        return true;
    char *a =(char*)malloc(2*len1+1);
    memset(a,'\0',2*len1+1); 
    strcat(a,s1);
    strcat(a,s1);
    int i = 0;
    while(i<len1){
        if(a[i]==s2[0]){//遇见与s2首字母相同的字母
            char tmp = a[i+len1];//只比较len1长度
            a[i+len1] = '\0';
            if(strcmp(a+i,s2)==0)//是
                return true;
            a[i+len1] = tmp;//否则将字母放回
        }
        i++;//继续向后
    }
    return false;
}

面试题【02.03】【删除中间节点】：https://leetcode-cn.com/problems/delete-middle-node-lcci/
void deleteNode(struct ListNode* node) {
    struct ListNode *p = node->next;
    node->val = p->val;
    node->next = p->next;
    free(p);
}
 
面试题【02.01】【移除重复节点】：https://leetcode-cn.com/problems/remove-duplicate-node-lcci/
struct ListNode* removeDuplicateNodes(struct ListNode* head){
    if(head == NULL || head->next == NULL)//空表或单节点
        return head;
    struct ListNode* rear = head;
    struct ListNode* front = rear->next;
    struct ListNode* t=rear;;
    while(rear){
        while(front&&front->val != rear->val){//出此循环：front == NULL or front->val = rear->val
            t = t->next;
            front = front->next;
        }
        if(front){//重复节点
            t->next = front->next;
            free(front);
            front = t->next;
            continue;//继续向后查找
        }
        rear = rear->next;
        if(rear){
            front = rear->next;
            t = rear;
        }
    }
    return head;
}

面试题【02.02】【返回倒数第k个节点】：https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/
int kthToLast(struct ListNode* head, int k){
    struct ListNode* front = head;
    struct ListNode* rear = head;
    while(k--)
        front = front->next;
    while(front){
        front = front->next;
        rear = rear->next;
    }
    return rear->val;
}

LeetCode【36】【有效的数独】：https://leetcode-cn.com/problems/valid-sudoku/
bool isValidSudoku(char** board, int boardSize, int* boardColSize){
    int* row = (int*)malloc(sizeof(int)*9);
    int* col = (int*)malloc(sizeof(int)*9);
    for(int i = 0;i <9 ;i++){
        memset(row,0,sizeof(int)*9);
        memset(col,0,sizeof(int)*9);
        for(int  j = 0;j<9;j++){//统计数字出现次数
            if(board[i][j]!='.')
                row[board[i][j]-'0'-1]++;
            if(board[j][i]!='.')
                col[board[j][i]-'0'-1]++;
        }
        for(int k = 0;k<9;k++)//检测同一行/同一列是否有重复数字
            if(row[k]>1||col[k]>1)
                return false;
    }
    for(int i = 0;i<9;i++){//i代表子九宫的编号
        int r_min = i/3*3,c_min = i%3*3; //从编号解出子九宫的行列初始值
        memset(row,0,sizeof(int)*9);
        for(int k = r_min;k<r_min+3;k++)//统计子九宫数字出现次数
            for(int t = c_min;t<c_min+3;t++)
                if(board[k][t]!='.')
                    row[board[k][t]-'0'-1]++;
        for(int k = 0;k<9;k++)
            if(row[k]>1)
                return false;
    }
    return true;
}

LeetCode【7】【整数反转】：https://leetcode-cn.com/problems/reverse-integer/
int reverse(int x){
    int res = 0;
    while(x/10){
        res = res*10+x%10;
        x/=10;
    }
    if((res>INT_MAX/10)||((res==INT_MAX/10)&&(x>7)))   
        return 0;
    else if((res<INT_MIN/10)||((res==INT_MIN/10)&&(x<-8)))  
        return 0;
    else    
        return res*10+x;
}

LeetCode【387】【字符串中的第一个唯一字符】：https://leetcode-cn.com/problems/first-unique-character-in-a-string/
int firstUniqChar(char * s){
    int count[26]={0};
    for(int i = 0;i<strlen(s);i++)
        count[s[i]-'a']++;
    char* str = s;
    while(*str){
        if(count[*str-'a']==1)
            return str-s;
        str++;
    }
    return -1;
}

LeetCode【19】【删除链表的倒数第N个节点】：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    int shift = n - 1;
    struct ListNode* pre = head;
    struct ListNode* rear = head;
    struct ListNode* t = head;
    while(shift--)
        pre=pre->next;
    if(!pre->next){
        t = head->next;
        free(head);
        return t;
    }
    while(pre->next){
        pre = pre->next;
        t = rear;
        rear = rear->next;
    }
    t->next=rear->next;
    free(rear);
    return head;
}

LeetCode【278】【第一个错误的版本】：https://leetcode-cn.com/problems/first-bad-version/
int firstBadVersion(int n) {
    int left = 1,right = n;
    while(left<right){
        int mid = left +(right-left)/2;
        if(isBadVersion(mid))
            right = mid;
        else
           left = mid + 1;
    }
    return left;
}

LeetCode【198】【打家劫舍】：https://leetcode-cn.com/problems/house-robber/
int rob(int* nums, int numsSize){
    if(numsSize == 0)
        return 0;
    if(numsSize == 1)
        return nums[0];
    int res[3] = {nums[0],fmax(res[0],nums[1]),0};
    if(numsSize == 2)
        return res[1];
    for(int i = 2;i<numsSize;i++){
        res[2] = fmax(res[1],nums[i]+res[0]);
        res[0]=res[1];
        res[1] = res[2];
    }
    return res[2];
}

LeetCode【213】【打家劫舍II】：https://leetcode-cn.com/problems/house-robber-ii/
int rob(int* nums, int numsSize){
    if(numsSize==1)
        return nums[0];
    if(numsSize==2)
        return nums[0]>nums[1]?nums[0]:nums[1];
    int dp1[3] = {nums[0],fmax(nums[0],nums[1]),0};//不打劫最后一家 0：numsSize-2
    int dp2[3] = {nums[1],fmax(nums[1],nums[2]),0};//不打劫第一家   1：numsSize-1
    if(numsSize==3)//3家人偷不到dp[2]
        return dp1[1]>dp2[1]?dp1[1]:dp2[1];
    for(int i = 2;i<numsSize;i++){
        if(i<numsSize-1){//[2,numsSize-2]
            dp1[2] = fmax(dp1[1],nums[i]+dp1[0]);
            dp1[0] = dp1[1];
            dp1[1] = dp1[2];
        }
        if(i>2){//[3,numsSize-1]
            dp2[2] = fmax(dp2[1],nums[i]+dp2[0]);
            dp2[0] = dp2[1];
            dp2[1] = dp2[2];
        }
    }
    return dp1[2]>dp2[2]?dp1[2]:dp2[2];
}

LeetCode【337】【打家劫舍III】：https://leetcode-cn.com/problems/house-robber-iii/submissions/
int rob(struct TreeNode* root){
    if(!root)
        return 0;
    int RobSum = root->val;//偷父节点
    if(root->left)//偷左孩子的孩子
        RobSum += rob(root->left->left) + rob(root->left->right);
    if(root->right)//偷右孩子的孩子
        RobSum += rob(root->right->left) + rob(root->right->right);
    int NorRob = rob(root->left)+rob(root->right);//不偷父节点，偷孩子
    return RobSum>NorRob?RobSum:NorRob;
}

剑指offer【03】【数组中重复的数字】：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/
int findRepeatNumber(int* nums, int numsSize){
    int* count = (int*)malloc(sizeof(int)*numsSize);
    memset(count,0,sizeof(int)*numsSize);
    int i = 0;
    for(;i<numsSize;i++){
        if(count[nums[i]]==0)
            count[nums[i]]++;
        else
            break;
    } 
    return nums[i];
}

LeetCode【384】【打乱数组】：https://leetcode-cn.com/problems/shuffle-an-array/
typedef struct {
    int* src;
    int* record;
    int size;
} Solution;


Solution* solutionCreate(int* nums, int numsSize) {
    Solution* obj = (Solution*)malloc(sizeof(Solution));
    obj->src = (int*)malloc(sizeof(int)*numsSize);
    obj->record = (int*)malloc(sizeof(int)*numsSize);
    obj->size = numsSize;
    for(int i = 0;i<numsSize;i++){
        obj->record[i] = nums[i];
        obj->src[i] = nums[i];
    }
    return obj;
}

/** Resets the array to its original configuration and return it. */
int* solutionReset(Solution* obj, int* retSize) {
    *retSize = obj->size;
    for(int i = 0;i<obj->size;i++)
        obj->src[i] = obj->record[i];
    return obj->src;
}

/** Returns a random shuffling of the array. */
int* solutionShuffle(Solution* obj, int* retSize) {
    *retSize = obj->size;
    for(int i = 0;i<obj->size;i++){
        int x = rand()%(obj->size - i) + i;
        int tmp = obj->src[i];
        obj->src[i] = obj->src[x];
        obj->src[x] = tmp;
    }
    
    return obj->src;
}

void solutionFree(Solution* obj) {
    free(obj->src);
    free(obj->record);
    obj->size = 0;
    obj->src = NULL;
    obj->record = NULL;
}

/**
 * Your Solution struct will be instantiated and called as such:
 * Solution* obj = solutionCreate(nums, numsSize);
 * int* param_1 = solutionReset(obj, retSize);
 
 * int* param_2 = solutionShuffle(obj, retSize);
 
 * solutionFree(obj);
*/

面试题【03.02】【栈的最小值】：https://leetcode-cn.com/problems/min-stack-lcci/
typedef struct LinkNode{
    int val;
    struct LinkNode* next;
}LinkNode;
typedef struct LinkStack{
    LinkNode* head;
}LinkStack;

bool IsEmpty(LinkStack*pt);
void LinkStackInit(LinkStack* pt);
void LinkStackPush(LinkStack* pt,int x);
void LinkStackPop(LinkStack* pt);
int LinkStackTop(LinkStack* pt);
void LinkStackDestory(LinkStack* pt);

bool IsEmpty(LinkStack* pt)
{return pt->head == NULL;}
void LinkStackInit(LinkStack* pt)
{pt->head = NULL;}
void LinkStackPush(LinkStack* pt, int x){
    LinkNode* p = (LinkNode*)malloc(sizeof(LinkNode));
    p->val = x;
    p->next = pt->head;
    pt->head = p;
}

void LinkStackPop(LinkStack* pt){
    if(!IsEmpty(pt)){
        LinkNode* p = pt->head;
        pt->head = p->next;
        free(p);        
    }
}

void LinkStackDestory(LinkStack* pt){
    while(pt->head){
        LinkNode* p = pt->head;
        pt->head = p->next;
        free(p);
    }
}

int LinkStackTop(LinkStack* pt){
    return pt->head->val;
}

typedef struct {
    LinkStack s;
    LinkStack sm;
} MinStack;

/** initialize your data structure here. */

MinStack* minStackCreate() {
    MinStack* obj = (MinStack*)malloc(sizeof(MinStack));
    LinkStackInit(&(obj->s));
    LinkStackInit(&(obj->sm));
    return obj;
}

void minStackPush(MinStack* obj, int x) {
    LinkStackPush(&(obj->s),x);
    if(IsEmpty(&(obj->sm)) || LinkStackTop(&(obj->sm))>=x)
        LinkStackPush(&(obj->sm),x);
}

void minStackPop(MinStack* obj) {
    if(LinkStackTop(&(obj->s))==LinkStackTop(&(obj->sm)))
        LinkStackPop(&(obj->sm));
    LinkStackPop(&(obj->s));
}

int minStackTop(MinStack* obj) {
    return LinkStackTop(&(obj->s));
}

int minStackGetMin(MinStack* obj) {
    return LinkStackTop(&(obj->sm));
}

void minStackFree(MinStack* obj) {
    LinkStackDestory(&(obj->s));
    LinkStackDestory(&(obj->sm));
    obj= NULL;
}

/**
 * Your MinStack struct will be instantiated and called as such:
 * MinStack* obj = minStackCreate();
 * minStackPush(obj, x);
 
 * minStackPop(obj);
 
 * int param_3 = minStackTop(obj);
 
 * int param_4 = minStackGetMin(obj);
 
 * minStackFree(obj);
*/

LeetCode【13】【罗马数字转整数】：https://leetcode-cn.com/problems/roman-to-integer/
int romanToInt(char * s){
    int i = 0;
    int res = 0;
    while(s[i]){
        switch(s[i]){
            case 'I':
                res+=1;
                switch(s[++i]){
                    case 'V':res+=3;break;
                    case 'X':res+=8;break;
                    default:i--;break;
                }
                break;
            case 'V':res+=5;break;
            case 'X':
                res+= 10;
                switch(s[++i]){
                    case 'L':res+=30;break;
                    case 'C':res+=80;break;
                    default:i--;break;
                }
                break;
            case 'L':res+=50;break;
            case 'C':
                res+=100;
                switch(s[++i]){
                    case 'D':res+=300;break;
                    case 'M':res+=800;break;
                    default:i--;break;
                }
                break;
            case 'D':res+=500;break;
            case 'M':res+=1000;break;
            default:break;
        }
        i++;
    }
    return res;
}

LeetCode【98】【验证二叉搜索树】：https://leetcode-cn.com/problems/validate-binary-search-tree/
int TreeNodeCount(struct TreeNode* root){
    if(!root)
        return 0;
    return TreeNodeCount(root->left) + TreeNodeCount(root->right)+1;
    
}
void MidOrder(struct TreeNode* root,int* nums,int* index){
    if(!root)
        return;
    MidOrder(root->left,nums,index);
    nums[(*index)++] = root->val;
    MidOrder(root->right,nums,index);
}
bool isValidBST(struct TreeNode* root){
    int cnt = TreeNodeCount(root);    
    int* nums = (int*)malloc(sizeof(int)*cnt);
    cnt = 0;
    MidOrder(root,nums,&cnt);
    for(int i = 1;i<cnt;i++)
        if(nums[i]<=nums[i-1])
            return false;
    return true;
}

面试题【16.15】【珠玑妙算】：https://leetcode-cn.com/problems/master-mind-lcci/
int* masterMind(char* solution, char* guess, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    res[0] = 0, res[1] = 0;
    for(int i = 0; i < 4; i++){
        if(solution[i] == guess[i])
            res[0]++;
    }
    int cnt_R[2] = {0},cnt_Y[2] = {0},cnt_G[2] = {0},cnt_B[2] = {0};
    for(int i = 0; i < 4; i++){
        if(solution[i]=='R')
            cnt_R[0]++;
        else if(solution[i] == 'Y')
            cnt_Y[0]++;
        else if(solution[i] == 'G')
            cnt_G[0]++;
        else
            cnt_B[0]++;
    }
    for(int i = 0; i < 4; i++){
        if(guess[i]=='R')
            cnt_R[1]++;
        else if(guess[i] == 'Y')
            cnt_Y[1]++;
        else if(guess[i] == 'G')
            cnt_G[1]++;
        else
            cnt_B[1]++;
    }
    res[1] = fmin(cnt_R[0],cnt_R[1])+fmin(cnt_Y[0],cnt_Y[1])+fmin(cnt_G[0],cnt_G[1])+fmin(cnt_B[0],cnt_B[1]);
    res[1]-=res[0];
    return res;
}

剑指offer【32-III】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/
int Height(struct TreeNode* root){
        if(!root)
            return 0;
        int h_l = Height(root->left)+1;
        int h_r = Height(root->right)+1;
        return h_l>h_r?h_l:h_r;
    }
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
        if(NULL == root){
            *returnSize = 0;
            return NULL;
        }
        int level = Height(root);
        int** res = (int**)malloc(sizeof(int*)*level);
        *returnColumnSizes = (int*)malloc(sizeof(int)*level);
        *returnSize = level;
        struct TreeNode *q1[1000],*q2[1000];
        int q1_size = 0,q2_size = 0;
        q1[0] = root,q1_size++;
        int h = 0;
        while(h<level){
            res[h] = (int*)malloc(sizeof(int)*q1_size);
            for(int i = 0;i<q1_size;i++)
                res[h][i] = q1[i]->val;
            (*returnColumnSizes)[h] = q1_size;
            for(int i = 0;i<q1_size;i++){
                if(q1[i]->left)
                    q2[q2_size++] = q1[i]->left;
                if(q1[i]->right)
                    q2[q2_size++] = q1[i]->right;
            }
            memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
            q1_size = q2_size;
            q2_size = 0;
            h++;
        } 
        for(int i = 1;i<level;i+=2){
            int top = (*returnColumnSizes)[i];
            for(int j = 0;j<top/2;j++){
                int tmp = res[i][j];
                res[i][j] = res[i][top-j-1];
                res[i][top-j-1] = tmp;
            }
        }
        return res;
}

LeetCode【515】【在每个树行中找最大值】：https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/
int Height(struct TreeNode* root){
        if(!root)
            return 0;
        int h_l = Height(root->left)+1;
        int h_r = Height(root->right)+1;
        return h_l>h_r?h_l:h_r;
    } 
int* largestValues(struct TreeNode* root, int* returnSize){
    int layer = Height(root);
    *returnSize = layer;
    int* res = (int*)malloc(sizeof(int)*layer);
    struct TreeNode *q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root,++q1_size;

    int h = 0;
    while(h < layer){
        int max = q1[0]->val;
        for(int i = 1;i<q1_size;i++)
            if(q1[i]->val>max)
                max = q1[i]->val;
        res[h] = max;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
    }
    return res;
}

剑指offer【21-I】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/
int Height(struct TreeNode* root){
        if(!root)
            return 0;
        int h_l = Height(root->left)+1;
        int h_r = Height(root->right)+1;
        return h_l>h_r?h_l:h_r;
}
int NumofNode(struct TreeNode* root){
    if(!root)
        return 0;
    return NumofNode(root->left)+NumofNode(root->right)+1;
}
int* levelOrder(struct TreeNode* root, int* returnSize){
    if(NULL == root){
            *returnSize = 0;
            return NULL;
    }
    int level = Height(root);
    int num = NumofNode(root);
    int* res = (int*)malloc(sizeof(int*)*num);
    *returnSize = num;
    struct TreeNode *q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root,q1_size++;
    int h = 0;
    int cnt = 0;
    while(h<level){
        for(int i = 0;i<q1_size;i++)
            res[cnt++] = q1[i]->val;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        h++;
    } 
    return res;
}

LeetCode【637】【二叉树的层平均值】：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/
int Height(struct TreeNode* root){
    if(!root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r;
}
double* averageOfLevels(struct TreeNode* root, int* returnSize){
    int layer = Height(root);
    double* res = (double*)malloc(sizeof(double)*layer);
    *returnSize = layer;
    struct TreeNode* q1[1000],*q2[1000];
    int q1_size = 1,q2_size = 0;
    q1[0] = root;
    int h  = 0;
    double sum = 0.0;
    while(h<layer){
        for(int i = 0;i<q1_size;i++)
            sum += q1[i]->val;
        res[h] = sum/q1_size;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
        sum = 0; 
    }
    return res;
}

LeetCode【513】【找树左下角的值】：https://leetcode-cn.com/problems/find-bottom-left-tree-value/
int Height(struct TreeNode* root){
    if(!root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r;
}
int findBottomLeftValue(struct TreeNode* root){
    int layer = Height(root);
    struct TreeNode* q1[1000],*q2[1000];
    int q1_size = 1,q2_size = 0;
    q1[0] = root;
    int h  = 0;
    int res;
    while(h<layer){
        if(h == layer - 1){
            res = q1[0]->val;
            break;
        }
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
    }
    return res;
}

LeetCode【1302】【层数最深叶子节点的和】：https://leetcode-cn.com/problems/deepest-leaves-sum/
int Height(struct TreeNode* root){
    if(!root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r;
}
int deepestLeavesSum(struct TreeNode* root){
    int layer = Height(root);
    struct TreeNode* q1[10000],*q2[10000];
    int q1_size = 1,q2_size = 0;
    q1[0] = root;
    int h  = 0;
    int sum = 0;
    while(h<layer){
        if(h == layer - 1){
            for(int i = 0;i<q1_size;i++)
                sum+=q1[i]->val;
            break;
        }
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
    }
    return sum;
}

LeetCode【501】【二叉树中的众数】：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/
int* res;
int resSize;
int base, count, maxCount;
void update(int num){
    if(num == base)
        ++count;
    else
        count = 1,base = num;
    if(count == maxCount)
        res[resSize++] = num;
    if (count > maxCount) {
        maxCount = count;
        resSize = 0;
        res[resSize++] = base;
    }
}  
void dfs(struct TreeNode* root){
    if(!root)
        return;
    dfs(root->left);
    update(root->val);
    dfs(root->right);
} 
int* findMode(struct TreeNode* root, int* returnSize){
    base = count = maxCount = 0;
    res = malloc(sizeof(int) * 4001);
    resSize = 0;
    dfs(root);
    *returnSize = resSize;
    return res;
}

LeetCode【530】【二叉搜索书的最小绝对差】：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/
void dfs(struct TreeNode* root,int* res,int* index){
    if(!root)
        return;
    dfs(root->left,res,index);
    res[*index] = root->val;
    (*index)++;
    dfs(root->right,res,index);
}
int getMinimumDifference(struct TreeNode* root){
    int* res = (int*)malloc(sizeof(int)*10000);
    int index = 0;
    dfs(root,res,&index);
    int Min = INT_MAX;
    for(int i = 1;i<index;i++){
        int tmp = res[i] - res[i-1];
        if(tmp<Min)
            Min = tmp;
    }
    return Min;
}

LeetCode【832】【翻转图像】：https://leetcode-cn.com/problems/flipping-an-image/
int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){
    *returnSize = imageSize;
    *returnColumnSizes = imageColSize;
    int top = imageSize%2?imageSize/2 + 1:imageSize/2;
    for(int i = 0;i<imageSize;i++){
        for(int j = 0;j < top;j++){
            int tmp = image[i][j];
            image[i][j] = 1^image[i][imageSize-1-j];
            image[i][imageSize-1-j] = 1^tmp;
        }
    }
    return image;
}

LeetCode【257】【二叉树的所有路径】：https://leetcode-cn.com/problems/binary-tree-paths/
class Solution {
public:
    vector<string> res;
    vector<string> binaryTreePaths(TreeNode* root) {
       string tmp;
       DFS(root,tmp);
       return res;
    }
    void DFS(TreeNode* root,string tmp){
        if(!root)
            return;
        tmp += to_string(root->val);
        if(!root->left && !root->right)
            res.push_back(tmp);
        else{
            tmp += "->";
            DFS(root->left,tmp);
            DFS(root->right,tmp);
        }
    }
};

牛客【矩形覆盖】：https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tab=answerKey
class Solution {
public:
    int rectCover(int number) {
        vector<int> dp(3);
        dp[0] = 1,dp[1]=1;
        for(int i = 2;i<=number;++i){
            dp[2]=dp[0]+dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return number>1?dp[2]:number>=0?number:0;
    }
};

LeetCode【139】【单词拆分】：https://leetcode-cn.com/problems/word-break/
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        if(s.empty())
            return false;
        if(wordDict.empty())
            return false;
        auto wordDictSet = unordered_set <string> ();
        for (auto word: wordDict) {
            wordDictSet.insert(word);
        }
        int sz = s.size();
        vector<bool> dp(sz+1,false);
        dp[0] = true;
        for(int i = 1;i<=sz;++i){
            for(int j = 0;j<i;++j){
                if(dp[j]&&wordDictSet.find(s.substr(j,i-j))!=wordDictSet.end()){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[sz];
    }
};

牛客【三角形】：https://www.nowcoder.com/practice/2b7995aa4f7949d99674d975489cb7da?tpId=46&tqId=29060&tPage=2&rp=2&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-rankin&tab=answerKey
【自底向上】
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        if(triangle.empty())
            return 0;
        int sz = triangle.size();
        vector<vector<int>> dp(triangle);
        for(int i = 1;i<sz;++i){
            for(int j = 0;j<=i;++j){
                if(j==0)
                    dp[i][j] = dp[i-1][j];
                else if(j==i)
                    dp[i][j] = dp[i-1][j-1];
                else 
                    dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]);
                dp[i][j]+=triangle[i][j];
            }
        }
        int res = dp[sz-1][0];
        for(int i = 1;i<sz;++i)
            res = res<dp[sz-1][i]?res:dp[sz-1][i];
        return res;
    }
};
【自顶向下】：
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        if(triangle.empty())
            return 0;
        int sz = triangle.size();
        vector<vector<int>> dp(triangle);
        for(int i = sz-2;i>=0;--i){
            for(int j = 0;j<=i;++j)
                dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j];
        }
        return dp[0][0];
    }
};

牛客【求路径】：https://www.nowcoder.com/practice/166eaff8439d4cd898e3ba933fbc6358?tpId=46&tqId=29117&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param m int整型 
     * @param n int整型 
     * @return int整型
     */
    int uniquePaths(int m, int n) {
        if(n<0||m<0)
            return 0;
        vector<vector<int>> path(m,vector<int> (n,1));
        for(int i = 1;i<m;++i)
            for(int j = 1;j<n;++j)
                path[i][j] = path[i-1][j]+path[i][j-1];
        return path[m-1][n-1];
    }
};

牛客【求路径2】：https://www.nowcoder.com/practice/3cdf08dd4e974260921b712f0a5c8752?tpId=46&tqId=29116&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param obstacleGrid int整型vector<vector<>> 
     * @return int整型
     */
    int uniquePathsWithObstacles(vector<vector<int> >& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(n<0||m<0)
            return 0;
        vector<vector<int>> path(m,vector<int> (n,0));
        for(int i = 0;i<m;++i){
            if(obstacleGrid[i][0])
                break;
            else
                path[i][0]=1;
        }
        for(int i = 0;i<n;++i){
            if(obstacleGrid[0][i])
                break;
            else
                path[0][i]=1;
        }
        for(int i = 1;i<m;++i)
            for(int j = 1;j<n;++j)
                path[i][j] = obstacleGrid[i][j]?0:path[i-1][j]+path[i][j-1];
        return path[m-1][n-1];
    }
};

牛客【带权值的最小路径和】：https://www.nowcoder.com/practice/23462ed010024fcabb7dbd3df57c715e?tpId=46&tqId=29115&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param grid int整型vector<vector<>> 
     * @return int整型
     */
    int minPathSum(vector<vector<int> >& grid) {
        int m = grid.size();
        int n = grid[0].size();
        if(!m || !n)
            return 0;
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0] = grid[0][0];
        for(int i = 1;i<m;++i)
            dp[i][0] = grid[i][0]+dp[i-1][0];
        for(int i = 1;i<n;++i)
            dp[0][i] = grid[0][i]+dp[0][i-1];
        for(int i = 1;i<m;++i){
            for(int j = 1;j<n;++j)
                dp[i][j] = min(dp[i][j-1],dp[i-1][j])+grid[i][j];
        }
        return dp[m-1][n-1];
    }
};

LeetCode【209】【长度最小的子数组】：https://leetcode-cn.com/problems/minimum-size-subarray-sum/
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX;
        int sz = nums.size();
        int left = 0,right = 0;
        int sum = 0;
        while(right<sz){
            sum+=nums[right];
            while(sum>=target){
                res = min(res,right-left+1);
                sum-=nums[left++];
            }
            ++right;
        }
        return res==INT_MAX?0:res;
    }
};

【746】【使用最小花费爬楼梯】：https://leetcode-cn.com/problems/min-cost-climbing-stairs/
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int sz = cost.size();
        vector<int> dp(sz+1,0);
        dp[0] = 0,dp[1] = 0;
        for(int i = 2;i<=sz;++i)
            dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        return dp[sz];
    }
};

LeetCode【908】【最小差值】：https://leetcode-cn.com/problems/smallest-range-i/
class Solution {
public:
    int smallestRangeI(vector<int>& A, int K) {
        int n = A.size();
        int max_A = A[0];
        int min_A = A[0];
        for(int i = 1;i<n;++i){
            if(A[i]>max_A)
                max_A = A[i];
            else if(A[i]<min_A)
                min_A = A[i];
        }
        int tmp = max_A-min_A - 2*K;
        return tmp>0?tmp:0;
    }
};

LeetCode【910】【最小差值II】：https://leetcode-cn.com/problems/smallest-range-ii/
class Solution {
public:
    int smallestRangeII(vector<int>& A, int K) {
        int n = A.size();
        sort(A.begin(),A.end());
        int res = A[n-1]-A[0];
        for(int i = 0;i<n-1;++i){
            int tmp1 = max(A[n-1]-K,A[i]+K);
            int tmp2 = min(A[i+1]-K,A[0]+K);
            int tmp3 = tmp1-tmp2;
            res = min(res,tmp3);
        }
        return res;
    }
};

LeetCode【931】【下降路径最小和】：https://leetcode-cn.com/problems/minimum-falling-path-sum/
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0] = matrix[0]; 
        for(int i = 1;i<m;++i){
            for(int j = 0;j<n;++j){
                if(j==n-1)
                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]);
                else if(!j)
                    dp[i][j] = min(dp[i-1][j],dp[i-1][j+1]);
                else
                    dp[i][j] = min(min(dp[i-1][j-1],dp[i-1][j]),dp[i-1][j+1]);
                dp[i][j]+=matrix[i][j];
            }
        }
        int res = dp[m-1][0];
        for(int i = 1;i<n;++i)
            res = res<dp[m-1][i]?res:dp[m-1][i];
        return res;
     }
};

LeetCode【292】【Nim游戏】：https://leetcode-cn.com/problems/nim-game/
class Solution {
public:
    bool canWinNim(int n) {
        return n%4!=0;
    }
};

剑指offer【37】【序列化二叉树】：https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/
class Codec {
public:
    string res;
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root)
            return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int sz = q.size();
            for(int i = 0;i<sz;++i){
                TreeNode* t = q.front();
                q.pop();
                if(t){
                    res += to_string(t->val);
                    res+=",";
                    q.push(t->left);
                    q.push(t->right);
                }
                else
                    res+="$,";
            }
        }
        return res;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data){
        split(data);
        int sz = seq.size();
        int start = 0;
        return Creat(start,sz);
    }
    private:
    vector<string> seq;
    void split(string& data){
        char* start = (char*)data.c_str();
        char* send = start;
        while(*send){
            if(*send == ','){
                string tmp;
                for(char* r = start;r!=send;++r)
                    tmp.push_back(*r);
                seq.push_back(tmp);
                start = send + 1;
                send = start;
            }else
                ++send;
        }
    }
    int to_num(const string& str){
        int res = 0;
        int flag = 1;
        int index = 0;
        if(str[index] =='-'){
            flag = -1;
            ++index;
        }
        int sz = str.size();
        for(int i = index;i<sz;i++)
            res = res*10 + (str[i]-'0');
        return flag*res;
    }
    TreeNode* Creat(int index,const int& sz){
        if(index>=sz || seq[index][0] == '$')
            return nullptr;
        int cnt = 0;
        for(int i = 0;i<index;++i)
            if(seq[i][0]=='$')
                ++cnt;
        TreeNode* t = new TreeNode(to_num(seq[index]));
        t->left = Creat(2*(index-cnt)+1,sz);
        t->right = Creat(2*(index-cnt)+2,sz);
        return t;
    }

剑指offer【12】【矩阵中的路径】：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        _rows = board.size();
        _cols = board[0].size();
        for(int i = 0;i<_rows;++i)
            for(int j = 0;j<_cols;++j)
                if(dfs(i,j,0,word,board))
                    return true;
        return false;
    }
    private:
    int _rows,_cols;
    bool dfs(int row,int col,int index,const string& word,vector<vector<char>>& board){
        char c = word[index];
        if(row>=_rows || row<0 || col<0 || col>=_cols || board[row][col]!=c)
            return false;
        if(index == word.size()-1)
            return true;
        board[row][col] = '\0';
        bool res = dfs(row,col+1,index+1,word,board)||dfs(row,col-1,index+1,word,board)||
            dfs(row+1,col,index+1,word,board)||dfs(row-1,col,index+1,word,board);
        board[row][col] = word[index];
        return res;
    }
};

剑指offer【13】【机器人的运行范围】：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/
class Solution {
public:
    int movingCount(int m, int n, int k) {
        if(k<0 || m<=0 || n<= 0)
            return 0;
        vector<vector<bool>> visited(m,vector<bool> (n,false));
        int cnt = CheckCore(0,0,k,visited,m,n);
        return cnt; 
    }
    private:
    int CheckCore(const int& row,const int& col,const int& k,vector<vector<bool>>& visited,const int& m,const int& n){
        int cnt = 0;
        if(Check(row,col,k,visited,m,n)){
            visited[row][col] = true;
            cnt = 1+CheckCore(row-1,col,k,visited,m,n)+CheckCore(row+1,col,k,visited,m,n)+
                CheckCore(row,col-1,k,visited,m,n)+CheckCore(row,col+1,k,visited,m,n);
        }
        return cnt;
    }
    bool Check(const int& row,const int& col,const int& k,vector<vector<bool>>& visited,const int& m,const int& n){
        if(row>=0&&row<m&&col>=0&&col<n&&GetAdd(row,col,k)&&!visited[row][col])
            return true;
        return false;
    }
    bool GetAdd(int row,int col,const int& k){
        int res = 0;
        while(row){
            res+=row%10;
            row/=10;
        }
        while(col){
            res+=col%10;
            col/=10;
        }
        return res<=k;
    }
};

LeetCode【657】【机器人能否返回原点】：https://leetcode-cn.com/problems/robot-return-to-origin/
class Solution {
public:
    bool judgeCircle(string moves) {
        int sz = moves.size();
        int x = 0,y = 0;
        for(int i = 0;i<sz;i++){
            if(moves[i] == 'U')
                ++y;
            else if(moves[i] == 'D')
                --y;
            else if(moves[i] == 'L')
                --x;
            else
                ++x;
        }
        return !x && !y;
    }
};

LeetCode【1041】【困于环中的机器人】：https://leetcode-cn.com/problems/robot-bounded-in-circle/
class Solution {
public:
    bool isRobotBounded(string instructions) {
        int x = 0,y = 0;
        int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};//右上左下
        int sz = instructions.size();
        int d = 0;
        for(int i = 0;i < sz; ++i){
            if(instructions[i] == 'L')
                d += 1;
            else if(instructions[i] == 'R')
                d += 3;
            else{
                d %= 4;
                x += dir[d][0];
                y += dir[d][1];
            }
        }
        return d%4 || !x && !y;
    }
};

面试题【08.02】【迷路的机器人】：https://leetcode-cn.com/problems/robot-in-a-grid-lcci/
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> pathWithObstacles(vector<vector<int>>& obstacleGrid) {
        r = obstacleGrid.size(),c = obstacleGrid[0].size();
        if(!r || !c || obstacleGrid[r-1][c-1])
            return res;
        vector<vector<bool>> vis(r,vector<bool>(c,true));
        BackTrack(0,0,obstacleGrid,vis);
        return res;
    }
    private:
    int r,c;
    bool BackTrack(int row,int col,const vector<vector<int>>& ob,vector<vector<bool>>& vis){
        int sz = res.size();
        if(sz>0 && res[sz-1][0]==r-1 && res[sz-1][1]==c-1)//已到终点
            return true; 
        if(row>=r || col>=c || ob[row][col] || !vis[row][col])//剪枝
            return false;
        res.push_back(vector<int> ({row,col}));
        if(BackTrack(row+1,col,ob,vis) || BackTrack(row,col+1,ob,vis))//一个方向即可
            return true;
        vis[row][col] = false;//此路不通
        res.pop_back();
        return false;
    }
};

剑指offer【47】【礼物的最大价值】：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid);
        int m = grid.size();
        int n = grid[0].size();
        for(int i = 1;i<n;++i)
            dp[0][i] = dp[0][i-1] + grid[0][i];
        for(int i = 1;i<m;++i)
            dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int i = 1;i<m;++i)
            for(int j = 1;j<n;++j)
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + grid[i][j];
        return dp[m-1][n-1];
    }
};

面试题【08.01】【三步问题】：https://leetcode-cn.com/problems/three-steps-problem-lcci/
class Solution {
public:
    int waysToStep(int n) {
        int r = 1000000007;
        vector<int> dp({1,2,4,0});
        for(int i = 4;i<=n;++i){
            dp[3] = ((dp[0]+dp[1])%r+dp[2])%r;
            dp[0] = dp[1];
            dp[1] = dp[2];
            dp[2] = dp[3];
        }
        return n<4?dp[n-1]:dp[3];
    }
};

面试题【08.11】【硬币】：https://leetcode-cn.com/problems/coin-lcci/
class Solution {
public:
    int waysToChange(int n) {
        int r = 1000000007;
        vector<int> coins({25,10,5,1});
        vector<int> dp(n+1,0);
        dp[0] = 1;
        for(int i = 0;i<4;++i)
            for(int j = coins[i];j<=n;++j)
               dp[j] = (dp[j]+dp[j-coins[i]])%r;
        return dp[n];
    }
};

LeetCode【96】【不同的二叉搜索树】：https://leetcode-cn.com/problems/unique-binary-search-trees/
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0] = 1,dp[1] = 1;
        for(int i = 2;i<=n;++i)
            for(int j =1;j<=i;++j)
                dp[i]+=dp[j-1]*dp[i-j];
        return dp[n];
    }
};

LeetCode【1832】【判断句子是否为全字母句】：https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/
class Solution {
public:
    bool checkIfPangram(string sentence) {
        int cnt[26] = {0};
        int sz = sentence.size();
        for(int i = 0;i<sz;++i)
            cnt[sentence[i]-'a']=1;
        for(int i = 0; i < 26;++i)
            if(!cnt[i])
                return false;
        return true;
    }
};

面试题【10.01】【合并排序的数组】：https://leetcode-cn.com/problems/sorted-merge-lcci/
class Solution {
public:
    void merge(vector<int>& A, int m, vector<int>& B, int n) {
        int szB = B.size();
        for(int i = 0;i<szB;++i){
            int szA = A.size();
            int j = m - 1;
            for(;j>=0 && B[i]<A[j];--j)
                A[j+1] = A[j];
            A[j+1] = B[i];
            ++m;
        }
    }
};

LintCode【125】【背包问题II】：https://www.lintcode.com/problem/backpack-ii/
class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @param V: Given n items with value V[i]
     * @return: The maximum value
     */
    int backPackII(int m, vector<int> &A, vector<int> &V) {
        // write your code here
        int n = A.size();//物品数量
        if(!m || !n)
            return 0;
        vector<vector<int>> maxV(n+1,vector<int>(m+1,0));//横向为背包容量
        for(int i = 1;i<=n;++i){
            for(int j = 1;j<=m;++j)
                if(A[i-1] <= j)//放的下，分两种：直接放，拿出一部分再放
                    maxV[i][j] = max(maxV[i-1][j],maxV[i-1][j-A[i-1]]+V[i-1]);
                else//背包放不下
                    maxV[i][j] = maxV[i-1][j];
        }
        return maxV[n][m];
    }
};

class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @param V: Given n items with value V[i]
     * @return: The maximum value
     */
    int backPackII(int m, vector<int> &A, vector<int> &V) {
        // write your code here
        int n = A.size();//物品数量
        if(!m || !n)
            return 0;
        vector<int> maxV(m+1,0);//横向为背包容量
        for(int i = 1;i<=n;++i){
            for(int j = m;j>=0;--j)
                if(A[i-1] <= j)//放的下，分两种：直接放，拿出一部分再放
                    maxV[j] = max(maxV[j],maxV[j-A[i-1]]+V[i-1]);
                else//背包放不下
                    maxV[j] = maxV[j];
        }
        return maxV[m];
    }
};
LeetCode【132】【分割回文串】：https://leetcode-cn.com/problems/palindrome-partitioning-ii/
class Solution {
public:
    int minCut(string s) {
        int sz = s.size();
        vector<int> dp(sz+1,0);
        for(int i = 0;i<=sz;++i)
            dp[i] = i - 1;
        for(int i = 2;i<=sz;++i){
            for(int j = 0;j<i;++j)//
                if(IsPal(s,j,i-1))
                    dp[i] = min(dp[i],dp[j]+1);
        }
        return dp[sz];
    }
    bool IsPal(const string& s,int start,int end){
        while(start < end){
            if(s[start] != s[end])
                return false;
            ++start,--end;
        }
        return true;
    }
};

牛客【编辑距离】：https://www.nowcoder.com/practice/81d7738f954242e5ade5e65ec40e5027?tpId=46&tqId=29106&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param word1 string字符串 
     * @param word2 string字符串 
     * @return int整型
     */
    int minDistance(string word1, string word2) {
        int sz1 = word1.size();
        int sz2 = word2.size();
        vector<vector<int>> minD(sz1+1,vector<int>(sz2+1,0));
        for(int i = 0;i<=sz1;++i)
            minD[i][0] = i;
        for(int i = 0;i<=sz2;++i)
            minD[0][i] = i;
        for(int i = 1;i<=sz1;++i){
            for(int j = 1;j<=sz2;++j){
                //插入，删除
                minD[i][j] = min(minD[i][j-1],minD[i-1][j])+1;
                //替换
                if(word1[i-1] == word2[j-1])
                    minD[i][j] = min(minD[i][j],minD[i-1][j-1]);
                else
                    minD[i][j] = min(minD[i][j],minD[i-1][j-1]+1);
            }
        }
        return minD[sz1][sz2];
    }
};

LeetCode【690】【员工的重要性】：https://leetcode-cn.com/problems/employee-importance/
class Solution {
public:
    map<int, Employee *> m;
    int getImportance(vector <Employee*> es, int id) {
        int n = es.size();
        for (int i = 0; i < n; i++) 
            m.insert({es[i]->id, es[i]});
        return getVal(id);
    }
    int getVal(int id){
        Employee* master = m[id];
        int imp =master->importance;
        for(auto& p:master->subordinates)
            imp+=getVal(p);
        return imp;
    }
};
【BFS】：
class Solution {
public:
    map<int, Employee *> m;
    int getImportance(vector <Employee*> es, int id) {
        int n = es.size();
        for (int i = 0; i < n; i++) 
            m.insert({es[i]->id, es[i]});
        queue<int> q;
        q.push(id);
        int sum = 0;
        while(!q.empty()){
            int cur = q.front();
            q.pop();
            sum+=m[cur]->importance;
            for(auto& e:m[cur]->subordinates)
                q.push(e);

        }
        return sum;
    }
};

LeetCode【733】【图像渲染】：https://leetcode-cn.com/problems/flood-fill/
class Solution {
public:
    int change[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int oldcolor = image[sr][sc];
        if(oldcolor!=newColor)
            DFS(image,sr,sc,oldcolor,newColor);
        return image;
    }
    void DFS(vector<vector<int>>& image, int x, int y,const int& oldcolor,const int& newColor){
        if(x>=image.size() || x<0 || y>=image[0].size() || y<0 || image[x][y]!=oldcolor)
            return;
        image[x][y] = newColor;
        for(int i = 0;i<4;++i)
            DFS(image,x+change[i][0],y+change[i][1],oldcolor,newColor);
    }
};

LeetCode【130】【被围绕的区域】：https://leetcode-cn.com/problems/surrounded-regions/
class Solution {
public:
    int dir[4][2] ={{1,0},{0,1},{-1,0},{0,-1}};
    void solve(vector<vector<char>>& board) {
        int m = board.size();
        int n = board[0].size();
        for(int i = 0;i<m;++i){
            if(board[i][0] == 'O')//第0列
                DFS(board,i,0,m,n);
            if(board[i][n-1] == 'O')//第n-1列
                DFS(board,i,n-1,m,n);
        }
        for(int i = 0;i<n;++i){
            if(board[0][i] == 'O')//第0行
                DFS(board,0,i,m,n);
            if(board[m-1][i] == 'O')//第m-1行
                DFS(board,m-1,i,m,n);
        }
        for(int i = 0;i<m;++i)
            for(int j=0;j<n;++j){
                if(board[i][j]=='O')
                    board[i][j] = 'X';
                else if(board[i][j] == 'A')
                    board[i][j] = 'O';
            }
    }
    void DFS(vector<vector<char>>& board,int x,int y,const int& m,const int& n){
        if(x<0||y<0||x>=m||y>=n||board[x][y]!='O')
            return;
        board[x][y] = 'A';
        for(int i = 0;i<4;++i)
            DFS(board,x + dir[i][0],y + dir[i][1],m,n);
    }
};

LeetCode【200】【岛屿数量】：https://leetcode-cn.com/problems/number-of-islands/
class Solution {
public:
    int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        int res = 0;
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j)
                if(grid[i][j]=='1' && !visited[i][j]){
                    ++res;
                    DFS(grid,i,j,m,n,visited);
                }
        }
        return res;
    }
    void DFS(vector<vector<char>>& grid,int x,int y,const int& m,const int&n,vector<vector<bool>>& visited){
        visited[x][y] = true;
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<m && nx>=0 && ny>=0 && ny<n && !visited[nx][ny] && grid[x][y] == '1')
                DFS(grid,nx,ny,m,n,visited);
        }
    }
};

LeetCode【994】【腐烂的橘子】：https://leetcode-cn.com/problems/rotting-oranges/
class Solution {
public:
    int dir[4][2] ={{1,0},{0,1},{-1,0},{0,-1}};
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<int,int>> q;
        int row = grid.size();
        int col =grid[0].size();
        for(int i = 0;i<row;++i)
            for(int j = 0;j<col;++j)
                if(grid[i][j] == 2)
                    q.push(make_pair(i,j));
        int minTime = 0;
        while(!q.empty()){
            int sz = q.size();
            int flag = 0;
            for(int i = 0;i<sz;++i){
                pair<int,int> curPos = q.front();
                q.pop();
                for(int i = 0;i<4;++i){
                    int nx = curPos.first + dir[i][0];
                    int ny = curPos.second + dir[i][1];
                    if(nx<0 || ny<0
                        || nx>=row || ny >= col)
                        continue;
                    if(grid[nx][ny] == 1){
                        flag = 1;
                        grid[nx][ny] = 2;
                        q.push(make_pair(nx,ny));
                    }
                }
            }
            if(flag)
                ++minTime;
        }
        for(int i = 0;i<row;++i)
            for(int j = 0;j<col;++j)
                if(grid[i][j] == 1)
                    return -1;
        return minTime;
    }
};

LeetCode【695】【岛屿的最大面积】：https://leetcode-cn.com/problems/max-area-of-island/
class Solution {
public:
    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int area = 0;
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        for(int i = 0;i<m;++i)
            for(int j = 0;j<n;++j){
                if(grid[i][j] && !visited[i][j]){
                    int cur = 1;
                    DFS(grid,i,j,m,n,visited,area,cur);
                }
            }
        return area;
    }
    void DFS(vector<vector<int>>& grid,int x,int y,const int& m,const int& n,vector<vector<bool>>& visited,int& res,int& cur){
        if(cur>res)
            res = cur;
        visited[x][y] = true;
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0 || ny<0 || nx>=m || ny>=n)
                continue;
            if(grid[nx][ny] && !visited[nx][ny]){
                ++cur;
                DFS(grid,nx,ny,m,n,visited,res,cur);
            }
        }
    }
};

LeetCode【463】【岛屿的周长】：https://leetcode-cn.com/problems/island-perimeter/
class Solution {
public:
    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; 
    int islandPerimeter(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int res = 0;
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j){
                if(grid[i][j]){
                    int cnt = 0;
                    for(int k = 0;k<4;++k){
                        int nx = i + dir[k][0];
                        int ny = j + dir[k][1];
                        if(nx<0||ny<0||nx>=m||ny>=n||!grid[nx][ny])
                            ++cnt;
                    }
                    res+=cnt;
                }
            }
        }
        return res;
    }
};
【DFS】：
class Solution {
public:
    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}}; 
    int DFS(int x, int y, vector<vector<int>> &grid, int n, int m) {
        if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 0) {
            return 1;
        }
        if (grid[x][y] == 2) {
            return 0;
        }
        grid[x][y] = 2;
        int res = 0;
        for (int i = 0; i < 4; ++i) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            res += DFS(tx, ty, grid, n, m);
        }
        return res;
    }
    int islandPerimeter(vector<vector<int>> &grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    ans += DFS(i, j, grid, n, m);
                }
                if(ans)
                    break;
            }
        }
        return ans;
    }
};

LeetCode【1254】【统计封闭岛屿的数目】：https://leetcode-cn.com/problems/number-of-closed-islands/
class Solution {
public: 
    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int closedIsland(vector<vector<int>>& grid) {
       int m = grid.size();
       int n = grid[0].size();
       int res = 0;
       vector<vector<bool>> visited(m,vector<bool>(n,false));
       for(int i = 0;i<m;++i){
            if(!grid[i][0])//第0列
                DFS(grid,i,0,m,n,visited);
            if(!grid[i][n-1])//最后一列
                DFS(grid,i,n-1,m,n,visited);
        }
        for(int i = 0;i<n;++i){
            if(!grid[0][i])//第0行
                DFS(grid,0,i,m,n,visited);
            if(!grid[m-1][i])//最后一行
                DFS(grid,m-1,i,m,n,visited);
        }
       for(int i = 0;i<m;++i) {
           for(int j = 0;j<n;++j){
               if(!grid[i][j] && !visited[i][j]){
                   ++res;
                   DFS(grid,i,j,m,n,visited);
               }
           }
       }
       return res;
    }
    void DFS(vector<vector<int>>& grid,int x,int y,const int& m,const int&n,vector<vector<bool>>& visited){
        visited[x][y] = true;
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0 || ny<0 || nx>=m || ny>=n || grid[nx][ny] || visited[nx][ny])
                continue;
            DFS(grid,nx,ny,m,n,visited);
        }
    }
};

LeetCode【329】【矩阵中的最长递增路径】：https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/
class Solution {
public:
    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        m = matrix.size();
        n = matrix[0].size();
        int res = 0;
        vector<vector<int>> memo(m,vector<int>(n,0));
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j)
                res = max(res,DFS(matrix,i,j,memo));
        }
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j)
                cout<<memo[i][j]<<" ";
            cout<<endl;
        }
        return res;
    }
    int DFS(vector<vector<int>>& matrix,int x,int y,vector<vector<int>>& memo){
        if(memo[x][y])
            return memo[x][y];
        ++memo[x][y];
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0||ny<0||nx>=m||ny>=n||matrix[nx][ny]<=matrix[x][y])
                continue;
            memo[x][y] = max(memo[x][y],DFS(matrix,nx,ny,memo)+1);
        }
        return memo[x][y];
    }
    private:
        int n;
        int m;
};

LeetCode【874】【模拟行走机器人】：https://leetcode-cn.com/submissions/detail/174103319/testcase/
class Solution {
public:
    int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};//上右下左--顺时针方向转 
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        int distance = 0;
        int x = 0,y = 0;
        int sz = commands.size();
        int pt = 0;
        set<pair<int, int>> obstacleSet;
        for(int i=0;i<obstacles.size();i++)
            obstacleSet.insert(make_pair(obstacles[i][0], obstacles[i][1]));
        for(int i = 0;i<sz;++i){
            if(commands[i] == -1)
                pt = pt == 3?0:pt+1;
            else if(commands[i] == -2)
                pt = (!pt)?3:pt-1;
            else{
                for(int k = 0;k<commands[i];k++){
                    int nx = x + dir[pt][0];
                    int ny = y + dir[pt][1];
                    if (obstacleSet.find(make_pair(nx, ny)) == obstacleSet.end()) {
                        x = nx;
                        y = ny;
                        distance = max(distance, x*x + y*y);
                    }
                    else
                        break;
                }  
            }
        }
        return distance;
    }
};

LeetCode【LCP03】【机器人大冒险】：https://leetcode-cn.com/problems/programmable-robot/
class Solution {
public:
    bool robot(string command, vector<vector<int>>& obstacles, int x, int y) {
        int n = command.size(), m = obstacles.size(), cX = 0, cY = 0;
        for(int i = 0; i < n; ++i){ // O(n)，统计一个循环需要x和y能走多远
            if(command[i] == 'U') cY++;
            else cX++;
        }
        for(int i = 0; i < m; ++i){ // O(m)，计算每一个障碍物会不会碰到
            int oX = obstacles[i][0], oY = obstacles[i][1];
            if(oX > x || oY > y) continue; // 障碍物在终点之外
            int cnt = min(oX / cX, oY / cY); // 到障碍物至少需要多少个完整循环
            oX -= cnt * cX, oY -= cnt * cY;
            if(oX == 0 && oY == 0) return false; // 刚好cnt个完整循环到障碍物
            for(int j = 0; j < n; ++j){ // O(n)
                if(command[j] == 'U') oY--;
                else oX--;
                if(oX == 0 && oY == 0) return false; // 碰到障碍物
                if(oX < 0 || oY < 0) break; // 碰不到障碍物的情况
            }
        }
        int cycle = min(x/ cX, y / cY); // 到终点至少需要多少个循环
        x -= cycle * cX, y -= cycle * cY;
        if(x == 0 && y == 0) return true; // 刚好cycle个完整循环可以到终点
        for(int i = 0; i < n; ++i){ // O(n)
            if(command[i] == 'U') y--;
            else x--;
            if(x==0 && y == 0) return true; // 能到终点
            if(x < 0 || y < 0) return false; // 不能到终点
        }
        return true;
    }
};

LeetCode【445】【两数相加】：https://leetcode-cn.com/problems/add-two-numbers-ii/
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1,s2;
        while(l1){
            s1.push(l1->val);
            l1 = l1->next;
        }
        while(l2){
            s2.push(l2->val);
            l2 = l2->next; 
        }
        ListNode* h = nullptr;
        int flag = 0;
        while(!s1.empty() || !s2.empty() || flag){
            int n1 = s1.empty()?0:s1.top();
            int n2 = s2.empty()?0:s2.top();
            if(!s1.empty()) s1.pop();
            if(!s2.empty()) s2.pop();
            int tmp = n1 + n2 + flag;
            flag = tmp/10;
            tmp%=10;
            ListNode* p = new ListNode(tmp);
            p->next = h;
            h = p;
        }
        return h;
    }
};

LeetCode【447】【汉明距离总和】：https://leetcode-cn.com/problems/total-hamming-distance/
class Solution {
public:
    int totalHammingDistance(vector<int>& nums) {
        int res = 0;
        int sz = nums.size();
        for(int i = 0;i<32;i++){
            int cnt = 0;
            for(int j = 0;j<sz;++j)
                cnt += (nums[j]>>i&1);
            res += cnt*(sz - cnt);
        }
        return res;
    }
};

LeetCode【39】【组合总和】：https://leetcode-cn.com/problems/combination-sum/
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> tmp;
        int sz = candidates.size();
        sort(candidates.begin(),candidates.end());
        BackTrack(candidates,tmp,0,0,target,sz);
        return res;
    }
    void BackTrack(vector<int>& candidates,vector<int> tmp,int index,int cursum,const int& target,const int& sz){
        if(cursum>target)
            return;
        if(cursum==target){
            res.push_back(tmp);
            return;
        }
        for(int i = index;i<sz;++i){
            if(cursum+candidates[i]>target)
                return;
            cursum += candidates[i];
            tmp.push_back(candidates[i]);
            BackTrack(candidates,tmp,i,cursum,target,sz);
            cursum -= candidates[i];
            tmp.pop_back();
        }    
    }
};

面试题【16.17】【连续数列】：https://leetcode-cn.com/problems/contiguous-sequence-lcci/
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int pre = 0,maxres = nums[0];
        for(int i = 0;i < n; ++i){
            pre = max(nums[i],pre+nums[i]);
            maxres = max(maxres,pre);
        }
        return maxres;
    }
};

LeetCode【419】【甲板上的战舰】：https://leetcode-cn.com/problems/battleships-in-a-board/submissions/
class Solution {
public:
    int countBattleships(vector<vector<char>>& board) {
        int cnt = 0;
        m = board.size();
        n = board[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j){
                if(board[i][j]=='X'&&!visited[i][j]){
                    ++cnt;
                    DFS(board,visited,i,j);
                }
            }
        }
        return cnt;
    }
    void DFS(vector<vector<char>>& board,vector<vector<bool>>& visited,int x,int y){
        visited[x][y] = true;
        for(int i = 0;i<2;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx>=m || ny>=n || board[nx][ny]!='X' || visited[nx][ny])
                continue;
            DFS(board,visited,nx,ny);
        }
    }
    private:
        int m;
        int n;
        int dir[2][2] = {{1,0},{0,1}};
};
——————————————————为参加比赛练习基本知识—————————————————
——————————————————不注意编程风格，只重结果————————————————
【CSP-J入门组】【21984】：https://ac.nowcoder.com/acm/problem/21984
#include <iostream>
using namespace std;

int main(){
    cout<<"hello nowcoder"<<endl;
    return 0;
}

【CSP-J入门组】【21985】：https://ac.nowcoder.com/acm/problem/21985
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    cout<<n<<endl;
    return 0;
}
【CSP-J入门组】【21986】：https://ac.nowcoder.com/acm/problem/21986
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
    double n;
    cin>>n;
    cout<<fixed<<setprecision(3)<<n<<endl;
    return 0;
}
【CSP-J入门组】【21987】：https://ac.nowcoder.com/acm/problem/21987
#include <iostream>
using namespace std;

int main(){
    int a,b;
    cin>>a>>b;
    cout<<a+b<<endl;
    return 0;
}
【CSP-J入门组】【21988】：https://ac.nowcoder.com/acm/problem/21988
#include <iostream>
using namespace std;

int main(){
    int a,b;
    cin>>a>>b;
    cout<<a/b<<endl;
    return 0;
}
【CSP-J入门组】【21989】：https://ac.nowcoder.com/acm/problem/21989
#include <iostream>
using namespace std;

int main(){
    int a,b;
    cin>>a>>b;
    cout<<a%b<<endl;
    return 0;
}
【CSP-J入门组】【21990】：https://ac.nowcoder.com/acm/problem/21990
#include <iostream>
using namespace std;

int main(){
    int a;
    cin>>a;
    cout<<a%10<<endl;
    return 0;
}
【CSP-J入门组】【21991】：https://ac.nowcoder.com/acm/problem/21991
#include <iostream>
using namespace std;

int main(){
    int a;
    cin>>a;
    cout<<a/10%10<<endl;
    return 0;
}
【CSP-J入门组】【21992】：https://ac.nowcoder.com/acm/problem/21992
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
    int a,b;
    cin>>a>>b;
    cout<<fixed<<setprecision(3)<<(double)a/(double)b<<endl;
    return 0;
}
【CSP-J入门组】【21993】：https://ac.nowcoder.com/acm/problem/21993
#include <iostream>
using namespace std;

int main(){
    int a,b,c;
    cin>>a>>b>>c;
    cout<<c<<" "<<b<<" "<<a<<endl;
    return 0;
}
【CSP-J入门组】【21994】：https://ac.nowcoder.com/acm/problem/21994
#include <iostream>
using namespace std;

int main(){
    int h1,h2,m1,m2;
    cin>>h1>>m1>>h2>>m2;
    cout<<(h2-h1)*60+m2-m1<<endl;
    return 0;
}
【CSP-J入门组】【21995】：https://ac.nowcoder.com/acm/problem/21995
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
    int a,b,h;
    cin>>a>>b>>h;
    cout<<fixed<<setprecision(3)<<(a+b)*h/2.0<<endl;
    return 0;
}
【CSP-J入门组】【21997】：https://ac.nowcoder.com/acm/problem/21997
#include <iostream>
#include <iomanip>
#define pi 3.14159
using namespace std;


int main(){
    double a;
    cin>>a;
    cout<<2*pi*a<<endl;
    cout<<pi*a*a<<endl;
    return 0;
}
【CSP-J入门组】【21998】：https://ac.nowcoder.com/acm/problem/21998
#include <iostream>
#include <iomanip>
using namespace std;


int main(){
    int a,b;
    cin>>a>>b;
    cout<<2*(a+b)<<endl;
    cout<<a*b<<endl;
    return 0;
}
【CSP-J入门组】【21999】：https://ac.nowcoder.com/acm/problem/21999
#include <iostream>
#include <iomanip>
using namespace std;


int main(){
    int a,b,h;
    cin>>a>>b>>h;
    cout<<2*(a*b+b*h+a*h)<<endl;
    cout<<a*b*h<<endl;
    return 0;
}
【CSP-J入门组】【22000】：https://ac.nowcoder.com/acm/problem/22000
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    while(n){
        cout<<n%10;
        n/=10;
    }
    return 0;
}
【CSP-J入门组】【22001】：https://ac.nowcoder.com/acm/problem/22001
#include <iostream>
#include <cmath>
using namespace std;
int main(){
    double a;
    cin>>a;
    cout<<floor(a)<<endl;
    cout<<ceil(a)<<endl;
    return 0;
}
【CSP-J入门组】【22002】：https://ac.nowcoder.com/acm/problem/22002
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
    int a,b,c;
    cin>>a>>b>>c;
    double ave = (a+b+c)/3.0;
    cout<<fixed<<setprecision(6)<<ave<<endl;
    return 0;
}
【CSP-J入门组】【22003】：https://ac.nowcoder.com/acm/problem/22003
#include <iostream>
#include <cmath>
using namespace std;

int main(){
    int n;
    cin>>n;
    cout<<floor(sqrt(n))<<endl;
    return 0;
}
【CSP-J入门组】【22004】：https://ac.nowcoder.com/acm/problem/22004
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
    double f;
    cin>>f;
    cout<<fixed<<setprecision(3)<<5.0/9.0*(f-32)<<endl;
    return 0;
}
【CSP-J入门组】【22005】：https://ac.nowcoder.com/acm/problem/22005
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    cout<<n*1024*256<<endl;
    return 0;
}
【CSP-J入门组】【22006】：https://ac.nowcoder.com/acm/problem/22006
#include <iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    if(n%10<5)
       n-=(n%10);
    else
       n+=(10-n%10);
    cout<<n<<endl;
    return 0;
}
【CSP-J入门组】【22007】：https://ac.nowcoder.com/acm/problem/22007
#include <iostream>
using namespace std;

int main(){
    int a,b;
    cin>>a>>b;
    printf("%d+%d=%d\n",a,b,a+b);
    printf("%7d\n",a);
    printf("+%6d\n",b);
    printf("-------\n");
    printf("%7d\n",a+b);
    return 0;
}
【CSP-J入门组】【22008】：https://ac.nowcoder.com/acm/problem/22008
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    if(n&1)
        cout<<"odd"<<endl;
    else
        cout<<"even"<<endl;
    return 0;
}
【CSP-J入门组】【22009】：https://ac.nowcoder.com/acm/problem/22009
#include <iostream>
using namespace std;

int main(){
    int x,y;
    cin>>x>>y;
    int tmp;
    if(x>y){
       cout<<x<<endl;
       cout<<y<<endl;
    }
    else{
        tmp = y;
        y = x;
        x = tmp;
        cout<<x<<endl;
        cout<<y<<endl;
    }
    return 0;
}
【CSP-J入门组】【22010】：https://ac.nowcoder.com/acm/problem/22010
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    if(!(n&1)&& n>50)
        cout<<"yes"<<endl;
    else
        cout<<"no"<<endl;
    return 0;
}
【CSP-J入门组】【22011】：https://ac.nowcoder.com/acm/problem/22011
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    if(!(n&1) || n>50)
        cout<<"yes"<<endl;
    else
        cout<<"no"<<endl;
    return 0;
}
【CSP-J入门组】【22012】：https://ac.nowcoder.com/acm/problem/22012
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    if(!(n%400))
        cout<<"yes"<<endl;
    else if(!(n%4) && n%100)
        cout<<"yes"<<endl;
    else
        cout<<"no"<<endl;
    return 0;
}
【CSP-J入门组】【22014】：https://ac.nowcoder.com/acm/problem/22014
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    if(n>2 && !(n&1))
        cout<<"YES, you can divide the watermelon into two even parts."<<endl;
    else
        cout<<"NO, you can't divide the watermelon into two even parts."<<endl;
    return 0;
}
【CSP-J入门组】【22015】：https://ac.nowcoder.com/acm/problem/22015
#include <iostream>
#include <cmath>
using namespace std;
int main(){
    int a,b,c;
    cin>>a>>b>>c;
    cout<<"The maximum number is : "<<max(a,max(b,c))<<endl;
    cout<<"The minimum number is : "<<min(a,min(b,c))<<endl;
    return 0;
}
【CSP-J入门组】【22156】：https://ac.nowcoder.com/acm/problem/22156
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    int res = 0;
    for(int i = 1;i<=n;++i)
       if(i&1)
           res+=i;
       else
           res-=i;
    cout<<res<<endl;
}    
【CSP-J入门组】【22157】：https://ac.nowcoder.com/acm/problem/22157
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
    int n;
    cin>>n;
    double res;
    for(int i = 1;i<=n;++i)
        res+=1.0/i;
    cout<<fixed<<setprecision(6)<<res<<endl;
    return 0;
}
【CSP-J入门组】【22158】：https://ac.nowcoder.com/acm/problem/22158
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
    int n;
    cin>>n;
    double res=0.0;
    int tmp = 0;
    int flag = 1;
    for(int i = 1;i<=n;++i){
        if(i&1)
            flag = 1;
        else
            flag = -1;
        tmp += flag*(2*i-1);
        res+=1.0/tmp;
    }
    cout<<fixed<<setprecision(3)<<res<<endl;
    return 0;
}
【CSP-J入门组】【22159】：https://ac.nowcoder.com/acm/problem/22159
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    int cur = 0;
    int res = 0;
    for(int i = 1;i<=n;++i){
        cur+=i;
        res+=cur;
    }
    cout<<res<<endl;
    return 0;
}
【CSP-J入门组】【22160】：https://ac.nowcoder.com/acm/problem/22160
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n;
    cin>>n;
    if(n == 1 || n == 2){
        cout<<1<<endl;
        return 0;
    }
    vector<int> dp(3,1);
    n-=2;
    while(n--){
        dp[2] = dp[1] + dp[0];
        dp[0] = dp[1];
        dp[1] = dp[2];
    }
    cout<<dp[2]<<endl;
    return 0;
}
【CSP-J入门组】【220161】：https://ac.nowcoder.com/acm/problem/22161
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n;
    cin>>n;
    vector<int> dp(4,1);
    dp[0] = 0;
    if(n<4){
        cout<<dp[n-1]<<endl;
        return 0;
    }
    for(int i = 4;i<=n;++i){
        dp[3] = dp[0]+2*dp[1]+dp[2];
        dp[0] = dp[1];
        dp[1] = dp[2];
        dp[2] = dp[3];
    }
    cout<<dp[3]<<endl;
    return 0;
}
【CSP-J入门组】【22162】：https://ac.nowcoder.com/acm/problem/22162
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    int res = 0;
    for(int i = 0;i<=n;i+=7)
        res+=i;
    cout<<res<<endl;
    return 0;
}
【CSP-J入门组】【22163】：https://ac.nowcoder.com/acm/problem/22163
#include <iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int step = 0;
    while(n!=1){
        if(n&1)
            n=n*3+1;
        else
            n/=2;
        ++step;
    }
    cout<<step<<endl;
    return 0;
}
【CSP-J入门组】【22164】：https://ac.nowcoder.com/acm/problem/22164
#include <iostream>
using namespace std;

int main(){
    int a,b;
    cin>>a>>b;
    while(a!=b){
        if(a>b)
            a = a - b;
        else
            b = b - a;
    }    
    cout<<a<<endl;
    return 0;
}
【CSP-J入门组】【22165】：https://ac.nowcoder.com/acm/problem/22165
#include <iostream>
using namespace std;

int main(){
    int a,b;
    while(cin>>a>>b)
        cout<<a+b<<endl;
    return 0;
}
【CSP-J入门组】【22166】：https://ac.nowcoder.com/acm/problem/22166
#include <iostream>
using namespace std;

int main(){
    int n,a,b;
    cin>>n;
    while(n--){
        cin>>a>>b;
        cout<<a+b<<endl;
    }
    return 0;
}
【CSP-J入门组】【22167】：https://ac.nowcoder.com/acm/problem/22167
#include <iostream>
using namespace std;

int main(){
    int a,b;
    while(cin>>a>>b,a!=0&&b!=0)
        cout<<a+b<<endl;
    return 0;
}
【CSP-J入门组】【22168】：https://ac.nowcoder.com/acm/problem/22168
#include <iostream>
using namespace std;

int main(){
    int cnt = 0;
    int x,y;
    cin>>x>>y;
    for(int i = x;i<=y;++i){
        int tmp = i;
        int sum = 0;
        while(tmp){
            sum += tmp%10;
            tmp/=10;
        }
        cnt += !(sum%5)?1:0;
    }
    cout<<cnt<<endl;
    return 0;
}
【CSP-J入门组】【22169】：https://ac.nowcoder.com/acm/problem/22169
#include <iostream>
#include <vector>
using namespace std;
bool IsP(int n){
    int tmp = n;
    int cnt = 1;
    while(tmp/=10)
        ++cnt;
    vector<int> bit(cnt,0);
    for(int i = cnt-1;i>=0;--i){
        bit[i] = n%10;
        n/=10;
    }
    for(int i = 0;i<cnt/2;++i){
        if(bit[i] != bit[cnt-i-1]){
            return false;
        }
    }
    return true;
}
int main(){
    int n;
    cin>>n;
    for(int i = 1;i<n;++i){
        if(IsP(i))
            cout<<i<<endl;
    }
    return 0;
}
【CSP-J入门组】【22189】：https://ac.nowcoder.com/acm/problem/22189
#include  <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    for(int i = 15;i<=n;i+=3){
        int tmp = i;
        while(tmp){
            int bit = tmp%10;
            if(bit==5){
                cout<<i<<endl;
                break;
            }
            tmp/=10;
        }
    }
    return 0;
}
【CSP-J入门组】【22192】：https://ac.nowcoder.com/acm/problem/22192
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    for(int i = 23;i<=n;++i){
        if(i%3==2 && i%5==3 && i%7==2)
            cout<<i<<endl;
    }
    return 0;
}
【CSP-J入门组】【22194】：https://ac.nowcoder.com/acm/problem/22194
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    for(int i = 1000;i<=n;++i){
        int AB = i/100;
        int CD = i%100;
        if((AB+CD)*(AB+CD)==i)
            cout<<i<<endl;
    }
    return 0;
}
【CSP-J入门组】【22196】：https://ac.nowcoder.com/acm/problem/22196
#include <iostream>
#include <cmath>
using namespace std;

int main(){
    int n;
    cin>>n;
    int sum = 1 + n;
    for(int i = sqrt(n);i>=2;--i){
        if(n%i==0)
            sum +=(n/i + i); 
    }
    cout<<sum<<endl;
    return 0;
}
【CSP-J入门组】【22197】：https://ac.nowcoder.com/acm/problem/22197
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n;
    cin>>n;
    vector<int> dp(n+1,0);
    vector<int> coins({1,2,5});
    dp[0] = 1;
    for(int i = 0;i < 3;++i){
       for(int j = coins[i];j<=n;++j){
           dp[j] += dp[j-coins[i]];
       }
    }
    cout<<dp[n]<<endl;
    return 0;
}
【CSP-J入门组】【22198】：https://ac.nowcoder.com/acm/problem/22198
#include <iostream>
#include <vector>
using namespace std;

int main(){
    vector<int> vote(3,0);
    int n;
    int cnt = 0;
    int tot = 0;
    while(cin>>n,n!=-1){
        ++tot;
        if(n>=1 &&n<=3){
            ++cnt;
            ++vote[n-1];
        }
    }
    cout<<"A="<<vote[0]<<endl;
    cout<<"B="<<vote[1]<<endl;
    cout<<"C="<<vote[2]<<endl;
    cout<<"Tot="<<cnt<<endl;
    if(vote[0]>tot/2)
        cout<<"A-yes"<<endl;
    else if(vote[1]>tot/2)
        cout<<"B-yes"<<endl;
    else if(vote[2]>tot/2)
        cout<<"C-yes"<<endl;
    else
        cout<<"all-NO"<<endl;    
    return 0;
}
【CSP-J入门组】【22199】：https://ac.nowcoder.com/acm/problem/22199
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    int res = 0;
    while(n){
        res+=n%10;
        n/=10;
    }
    cout<<res<<endl;
    return 0;
}
【CSP-J入门组】【22200】：https://ac.nowcoder.com/acm/problem/22200
#include <iostream>
#include <cmath>
using namespace std;

void Judge(int n){
    if(n==2){
        cout<<"Yes"<<endl;
        return;
    }
    if(n==1 || !(n%2) || (!(n%5))&& n>10){
       cout<<"No"<<endl;
       return;
    }
    for(int i = 3;i<=sqrt(n);i+=2){
        if(!(n%i)){
            cout<<"No"<<endl;
            return;
        }
    }
    cout<<"Yes"<<endl;
}
int main(){
    int n;
    int num;
    cin>>n;
    while(n--){
        cin>>num;
        Judge(num);
    }
    return 0;
}
【CSP-J入门组】【22202】：https://ac.nowcoder.com/acm/problem/22202
#include <iostream>
#include <cstring>
using namespace std;

int main(){
    char c;
    int num=0,alpha=0,other=0;
    while(c = getchar(),c != '?'){
        if(isdigit(c))
            ++num;
        else if(isalpha(c))
            ++alpha;
        else
            ++other;
    }
    cout<<"Letters="<<alpha<<endl;
    cout<<"Digits="<<num<<endl;
    cout<<"Others="<<other<<endl;
    return 0;
}
【CSP-J入门组】【22203】：https://ac.nowcoder.com/acm/problem/22203
#include <iostream>
#include <string>
using namespace std;
void Print(int n){
    int sz = 2*n - 1;
    string s(sz+1,' ');
    for(int i = 0;i<n;i++){
        s[sz/2+i] = '*';
        s[sz/2-i] = '*';
        cout<<s<<endl;
    }
}
int main(){
    int n;
    while(cin>>n)
        Print(n);
    return 0;
}
【CSP-J入门组】【22204】：https://ac.nowcoder.com/acm/problem/22204
#include <iostream>
#include <string>
using namespace std;
void Print(int n){
    int sz = 2*n - 1;
    string s(sz+1,' ');
    for(int i = 0;i<n;i++){
        s[sz/2+i] = '*';
        s[sz/2-i] = '*';
        cout<<s<<endl;
    }
    for(int i = n - 1;i>0;--i){
        s[sz/2+i] = ' ';
        s[sz/2-i] = ' ';
        cout<<s<<endl;
    }
}
int main(){
    int n;
    while(cin>>n)
        Print(n);
    return 0;
}
【CSP-J入门组】【22205】：https://ac.nowcoder.com/acm/problem/22205
#include <iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    int res = 1;
    int tmp = 1;
    for(int i = 2;i<=n;++i){
        tmp*=i;
        res += tmp;
    }
    cout<<res<<endl;
    return 0;
}
【CSP-J入门组】【22206】：https://ac.nowcoder.com/acm/problem/22206
#include <iostream>
using namespace std;

int main(){
    for(int i = 1;i<10;++i){
        for(int j = 1;j<=i;++j)
           printf("%d*%d=%2d ",j,i,i*j);
        printf("\n");
    }
    return 0;
}
【CSP-J入门组】【22208】：https://ac.nowcoder.com/acm/problem/22208
#include <iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int tmp = 0;
    for(int i = 1;i<=n;++i){
        int m = tmp + i;
        for(int j=tmp;j<m;++j){
            printf("%4d",++tmp);
        }
        printf("\n");
    }
    return 0;
}
【CSP-J入门组】【22209】：https://ac.nowcoder.com/acm/problem/22209
#include <iostream>
#include <string>
using namespace std;

int main(){
    char c;
    cin>>c;
    int n = c - 'A' + 1;
    int sz = 2*n - 1;
    string s(sz,' ');
    char tmp = 'A';
    for(int i = 0;i<n;++i){
        for(int j = 0;j<=i;++j){
            s[sz/2-j] = tmp+i-j;
            s[sz/2+j] = tmp+i-j;
        }
        cout<<s<<endl;
    }
    return 0;
}
【CSP-J入门组】【22210】：https://ac.nowcoder.com/acm/problem/22210
#include <iostream>
#include <cmath>
using namespace std;

bool helper(int& n){
    if(n>10 && !(n%5))
        return false;
    for(int i = 3;i<=sqrt(n);i+=2)
        if(!(n%i))
            return false;
    return true;
}
int main(){
    int n;
    cin>>n;
    if(n>=2)
        cout<<2<<" ";
    else
        return 0;
    for(int i = 3;i<=n;i+=2){
        if(helper(i))
            cout<<i<<" ";
    }
    return 0;
}
【CSP-J入门组】【22211】：https://ac.nowcoder.com/acm/problem/22211
#include <iostream>
using namespace std;
int main(){
    long* dp = new long[3];
    dp[0] = 0,dp[1] = 1;
    int n;
    cin>>n;
    if(n<=2){
        cout<<dp[n-1]<<endl;
        return 0;
    }
    n -= 2;
    while(n--){
        dp[2] = dp[0]+dp[1];
        dp[0] = dp[1];
        dp[1] = dp[2];
    }
    cout<<dp[2]<<endl;
    return 0;
}
【CSP-J入门组】【22212】：https://ac.nowcoder.com/acm/problem/22212
#include <iostream>
#include <cmath>
using namespace std;

int main(){
    int row ,col;
    int tmp;
    for(int i=0;i<5;++i){
        for(int j = 0;j<5;++j){
            cin>>tmp;
            if(tmp){
                row = i;
                col = j;
             }
        }
    }
    cout<<abs(2-row)+abs(2-col)<<endl;
    return 0;
}
【CSP-J入门组】【22213】：https://ac.nowcoder.com/acm/problem/22213
#include <iostream>
#include <cmath>
using namespace std;
int main(){
    int a,b,n;
    cin>>n;
    for(int i = sqrt(n);i>0;--i){
        if(i*(n/i)==n){
            a = i;
            b = n/i;
            break;
        }
    }
    cout<<a<<" "<<b<<endl;
    return 0;
}
【CSP-J入门组】【22214】：https://ac.nowcoder.com/acm/problem/22214
#include <iostream>
using namespace std;
int main(){
    int total,a,b;
    cin>>a>>b>>total;
    int m1 = total/a;
    for(int i = m1;i>=0;--i)
        if(!((total-i*a)%b)){
            cout<<"Yes"<<endl;
            return 0;
        }
    cout<<"No"<<endl;
    return 0;
}
【CSP-J入门组】【22215】：https://ac.nowcoder.com/acm/problem/22215
#include <iostream>
using namespace std;
int main(){
    int A,B;
    cin>>A>>B;
    while(A!=B){
        if(A>B)
            A-=B;
        else
            B-=A;
    }
    cout<<A<<endl;
    return 0;
}
【CSP-J入门组】【22216】：https://ac.nowcoder.com/acm/problem/22216
#include <iostream>
#include <stack>
using namespace std;
int main(){
    int cnt;
    int sz;
    int tmp;
    cin>>cnt;
    stack<int> st;
    while(cnt--){
        cin>>sz;
        while(sz--){
            cin>>tmp;
            st.push(tmp);
        }
        while(!st.empty()){
            tmp = st.top();
            cout<<tmp<<" ";
            st.pop();
        }
        cout<<endl;
    }
    return 0;
}
【CSP-J入门组】【22218】：https://ac.nowcoder.com/acm/problem/22218
#include <iostream>
using namespace std;
int main(){
    int male=0,female=0;
    int input;
    int* sz = new int[2];
    cin>>sz[0]>>sz[1];
    while(sz[0]--){
        cin>>input;
        male = input>male?input:male;
    }
    while(sz[1]--){
        cin>>input;
        female = input>female?input:female;
    }
    cout<<male+female<<endl;
    return 0;
}
【CSP-J入门组】【22219】：https://ac.nowcoder.com/acm/problem/22219
#include <iostream>
#include <vector>
using namespace std;
int main(){
    int n,target;
    int flag = 0;
    while(cin>>n){
        vector<int> v(n);
        int inx = 0;
        int tmp = n;
        while(tmp--){
            cin>>v[inx++];
        }
        cin>>target;
        for(int i = 0;i<n;++i)
            if(target==v[i]){
                flag = 1;
                cout<<i<<endl;
                break;
            }
        if(!flag)
            cout<<"No"<<endl;
        flag = 0;
    }
    return 0;
}
【CSP-J入门组】【22220】：https://ac.nowcoder.com/acm/problem/22220
#include <iostream>
#include <vector>
using namespace std;
int main(){
    int n;
    int sum = 0;
    int flag = 0;
    double ave = 0.0;
    while(cin>>n){
        vector<int> v(n);
        for(int i = 0;i<n;++i){
            cin>>v[i];
            sum+=v[i];
        }
        ave=sum*1.0/n;
        for(int i = 0;i<n;++i)
            if(v[i]<ave){
                flag = 1;
                cout<<v[i]<<" ";
            }
        cout<<endl;
        sum=0;
    }
    return 0;
}
【CSP-J入门组】【22221】：https://ac.nowcoder.com/acm/problem/22221
#include <vector>
#include <iostream>
using namespace std;
int main(){
    int sz;
    cin>>sz;
    vector<int> tower(sz);
    for(int i = 0;i<sz;++i)
        cin>>tower[i];
    int m;
    cin>>m;
    int mp = m;
    while(mp--){
        vector<int> hadd(3);
        for(int i = 0;i<3;++i)
            cin>>hadd[i];
        for(int i = hadd[0];i<=hadd[1];++i)
            tower[i-1] += hadd[2];
    }
    for(int i = 0;i<sz;++i)
        cout<<tower[i]<<" ";
    return 0;
}
【CSP-J入门组】【22222】：https://ac.nowcoder.com/acm/problem/22222
#include <iostream>
#include <vector>
using namespace std;
int main(){
    int n;
    cin>>n;
    vector<int> v(n);
    for(int i = 0;i<n;++i)
        cin>>v[i];
    int x,sum=0;
    for(int i = 1;i<n;++i){
        if(!sum)
            x = v[i];
        sum+=x==v[i]?1:-1;
    }
    cout<<x<<endl;
    return 0;
}
【CSP-J入门组】【22224】：https://ac.nowcoder.com/acm/problem/22224
#include <iostream>
using namespace std;
int main(){
    char* str = new char[1024];
    cin.getline(str,1024);
    cout<<str;
    return 0;
}
【CSP-J入门组】【22225】：https://ac.nowcoder.com/acm/problem/22225
#include <iostream>
#include <vector>
using namespace std;
int main(){
    char* str = new char[512];
    vector<int> cnt(26,0);
    while(cin.getline(str,512)){
        char* pr = str;
        while(*pr){
            if(*pr<='z'&& *pr >= 'a')
                ++cnt[*pr-'a'];
            pr++;
        }
    }
    for(char i = 'a';i<='z';++i){
        if(cnt[i-'a'])
            cout<<i<<":"<<cnt[i-'a']<<endl;
    }
    return 0;
}
【CSP-J入门组】【22226】：https://ac.nowcoder.com/acm/problem/22226
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
bool helper(int& n){
    for(int i = 3;i<=sqrt(n);i+=2)
        if(!(n%i)) 
            return false;
    return true;
}
int main(){
    int n;
    vector<int> prime(78498,1000001);
    prime[0] = 2;
    int indx = 1;
    for(int i = 3;i<1000000;i+=2){
        if(n>10 && !(n%5))
            continue;
        if(helper(i))
            prime[indx++] = i;
    }
    cin>>n;
    int top;
    for(int i = 0;i<n;++i){
        cin>>top;
        int index = 0;
        while(index<78498 && prime[index]<=top)
            ++index;
        cout<<index<<endl;
    }
    return 0;
}
【CSP-J入门组】【22221】：https://ac.nowcoder.com/acm/problem/22227
#include <iostream>
using namespace std;
class Solution{
    public:
    int loop(int n,int m){
        ++count;
        int x = 0;
        if(n==1)
            return 0;
        else{
            x = loop(n-1,m);
        }
        return (m+x)%n;
    }
    private:
    int count = 0;
};
int main(){
    int n,k,m;
    cin>>n>>k>>m;
    Solution s;
    cout<<(s.loop(n,m)+k)%n<<endl;
    return 0;
}
【CSP-J入门组】【22227】：https://ac.nowcoder.com/acm/problem/22228
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;
int main(){
    int n;
    while(cin>>n){
        vector<int> v(n);
        for(int i = 0;i<n;++i)
            cin>>v[i];
        int target;
        cin>>target;
        auto it = find(v.begin(),v.end(),target);
        if(it!=v.end())
            v.erase(it);
        for(auto& e:v)
            cout<<e<<" ";
        cout<<endl;
    }
    return 0;
}
【CSP-J入门组】【22228】：https://ac.nowcoder.com/acm/problem/22228
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;
int main(){
    int n;
    while(cin>>n){
        vector<int> v(n);
        for(int i = 0;i<n;++i)
            cin>>v[i];
        int target;
        cin>>target;
        auto it = find(v.begin(),v.end(),target);
        if(it!=v.end())
            v.erase(it);
        for(auto& e:v)
            cout<<e<<" ";
        cout<<endl;
    }
    return 0;
}
【CSP-J入门组】【22229】：https://ac.nowcoder.com/acm/problem/22229
#include <iostream>
#include <vector>
using namespace std;
int Find(const vector<vector<int>>& mp,const int& target){
    int sz = mp.size();
    for(int i = 0;i<sz;++i){
        if(mp[i][0] == target){
            return i;
        }
    }
    return -1;
}
int main(){
    int n,num;
    cin>>n;
    vector<vector<int>> mp;
    while(n--){
        cin>>num;
        int inx = Find(mp,num);
        if(inx != -1)
            ++mp[inx][1];
        else
            mp.push_back({num,1});
    }
    int sz = mp.size();
    int res = mp[0][0];
    int res_cnt = mp[0][1];
    for(int i = 1;i<sz;++i){
        if(mp[i][1]>res_cnt){
            res = mp[i][0];
            res_cnt = mp[i][1];
        }
    }
    cout<<res<<endl;
    return 0;
}
【CSP-J入门组】【22230】：https://ac.nowcoder.com/acm/problem/22230
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int sz;
    cin>>sz;
    vector<vector<int>> sq(sz,vector<int>(sz));
    int left = 0,top = 0,right =sz-1,bottom= sz-1;
    int l,r,b,t;
    int num = 1;
    while(num<=sz*sz){
        l = left;
        while(l<=right)
            sq[top][l++] = num++;
        ++top;
        t = top;
        while(t<=bottom)
            sq[t++][right] = num++;
        --right;
        r = right;
        while(r>=left)
            sq[bottom][r--] = num++;
        --bottom;
        b = bottom;
        while(b>=top)
            sq[b--][left] = num++;
        ++left;
    }
    for(int i = 0;i<sz;++i){
        for(int j = 0;j<sz;++j)
            cout<<sq[i][j]<<" ";
        cout<<endl;
    }
    return 0;
}
【CSP-J入门组】【22231】：https://ac.nowcoder.com/acm/problem/22231
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<vector<int>> snake(n, vector<int>(n));
    int num = 1;
    int x = 0, y = 0;
    int flag;
    for (int k = 0; k < 2 * n; ++k) {
        flag = k > n-1 ? 1 : 0;
        if (!flag) {//上三角
            if (!(k & 1)) {//斜向上
                while (x >= 0)
                    snake[x--][y++] = num++;
                ++x;
            }
            else {//斜向下
                while (y >= 0)
                    snake[x++][y--] = num++;
                ++y;
            }
        }
        else {//下三角
            if (k == n) {//主对角线需要将坐标校正回来
                if (k & 1)
                    ++x, --y;
                else
                    --x, ++y;
            }
            if (!(k & 1)) {//斜向上
                while (y < n)
                    snake[x--][y++] = num++;
                x += 2, --y;
            }
            else {//斜向上
                while (x < n)
                    snake[x++][y--] = num++;
                y += 2, --x;
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j)
           cout << snake[i][j] << " ";
        cout << endl;
    }
    return 0;
}
【CSP-J入门组】【22232】：https://ac.nowcoder.com/acm/problem/22232
#include <iostream>
#include <vector>
using namespace std;
class Solution{
    public:
    int Count(const vector<vector<char>>& board,const int& x,const int& y){
        int cnt = 0;
        int m = board.size();
        int n = board[0].size();
        for(int i = 0;i<8;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0||ny<0||nx>=m||ny>=n||board[nx][ny]=='?')
                continue;
            ++cnt;
        }
        return cnt;
    }
    private:
        int dir[8][2] = {{1,0},{-1,0},{0,1},{0,-1},{-1,-1},{1,1},{1,-1},{-1,1}};
};
int main(){
    int row,col;
    cin>>row>>col;
    Solution s;
    vector<vector<char>> board(row,vector<char>(col));
    for(int i = 0;i<row;++i)
        for(int j = 0;j < col;++j)
            cin>>board[i][j];
    vector<vector<char>> cnt(row,vector<char>(col,'*'));
    for(int i = 0;i< row;++i){
        for(int j = 0;j < col;++j){
            if(board[i][j] == '?')
                cnt[i][j] = s.Count(board, i, j) + '0';
        }
    }
    for(int i = 0;i<row;++i){
        for(int j = 0;j < col;++j)
            cout<<cnt[i][j];
        cout<<endl;
    }
    return 0;
}
【CSP-J入门组】【22233】：https://ac.nowcoder.com/acm/problem/22233
#include <iostream>
#include <vector>
using namespace std;
class Solution{
    public:
    int Count(vector<vector<char>>& str){
        int cnt = 0;
        int m = str.size();
        int n = str[0].size();
        for(int i=0;i<m-1;++i){             //遍历数组中每个元素右下对角方向元素是否满足条件{
            for(int j=0;j<n-1;++j){
                if(str[i][j]!='f'&&str[i][j+1]!='f'&&str[i+1][j]!='f'&&str[i+1][j+1]!='f')
                    continue;            //当四个元素中不存在'f'时直接访问下一个元素
                else if(str[i][j]!='a'&&str[i][j+1]!='a'&&str[i+1][j]!='a'&&str[i+1][j+1]!='a')
                    continue;            //当四个元素中不存在'a'时直接访问下一个元素
                else if(str[i][j]!='c'&&str[i][j+1]!='c'&&str[i+1][j]!='c'&&str[i+1][j+1]!='c')
                    continue;            //当四个元素中不存在'c'时直接访问下一个元素
                else if(str[i][j]!='e'&&str[i][j+1]!='e'&&str[i+1][j]!='e'&&str[i+1][j+1]!='e')
                    continue;            //当四个元素中不存在'e'时直接访问下一个元素
                else 
                    ++cnt;            //否则计数变量加一，表示存在构成‘face’的元素
            }
        }
        return cnt;
    }
}; 
int main(){
    int n,m;
    cin>>n>>m;
    vector<vector<char>> board(n,vector<char>(m));
    for(int i=0;i<n;++i){
        getchar();
        for(int j=0;j<m;++j){
            board[i][j]=getchar();
        }
    }
    Solution s;
    cout<<s.Count(board)<<endl;
    return 0;
}
【CSP-J入门组】【22235】：https://ac.nowcoder.com/acm/problem/22235
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
class Solution {
public:
    int Count(const vector<vector<int>>& com) {
        int row = com.size();
        int col = com[0].size();
        vector<bool> champion(row, false);
        stack<int> rec;//存储冠军队伍
        for (int i = 0; i < col; ++i) {
            int max = com[0][i];//设冠军是第一支队伍
            rec.push(0);
            for (int j = 1; j < row; ++j) {//从第二支开始比较
                if (com[j][i] > max) {//冠军更新
                    max = com[j][i];
                    while (rec.size())//清空冠军栈
                        rec.pop();
                    rec.push(j);//新冠军加入
                }
                else if(com[j][i]==max) {//并列冠军
                    rec.push(j);//入栈
                }
            }
            while (rec.size()) {//标记冠军
                int tmp = rec.top();
                champion[tmp] = true;
                rec.pop();
            }
        }
        int res = 0;
        for (int i = 0;i<row;++i)
            res += champion[i]?1:0;
        return res;
    }
};
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> com(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        getchar();
        int inx = 0, m_c = m;
        while(m_c--)
            com[i][inx++] = getchar() - '0';
    }
    Solution s;
    cout << s.Count(com) << endl;
    return 0;
}
【CSP-J入门组】【22236】：https://ac.nowcoder.com/acm/problem/22236
#include <iostream>
#include <cmath>
using namespace std;
class Solution{
    public:
    int Renew(const int n,const int& m,const int& a){
        int _m = m%a?m/a+1:m/a;
        int _n = n%a?n/a+1:n/a;
        return _m*_n;
    }
};
int main(){
    int n,m,a;
    cin>>n>>m>>a;
    Solution s;
    cout<<s.Renew(n,m,a)<<endl;
    return 0;
}
【CSP-J入门组】【22237】：https://ac.nowcoder.com/acm/problem/22237
#include <iostream>
using namespace std;
class Solution{
    public:
    void Seek(const int& n,const int& k,int* res){
        if(k==n || !n || !k)//至少合适位置
            res[0] = 0;//已满,空车,无车
        else
            res[0] = 1;//连续座
        res[1] = min(2*k,n-k);
    }
};
int main(){
    int n,k;
    cin>>n>>k;
    int* res = new  int[2];
    Solution s;
    s.Seek(n,k,res);
    cout<<res[0]<<" "<<res[1]<<endl;
    return 0;
}
【CSP-J入门组】【22239】：https://ac.nowcoder.com/acm/problem/22239
#include <cmath>
#include <iostream>
using namespace std;
class Solution{
    public:
    bool Possibility(int x,int y,int M){
        int sum = abs(x) + abs(y);
        if(sum<=M && !((M-sum)&1))
            return true;
        else
            return false;
    }
};
int main(){
    int a,b,M;
    cin>>a>>b>>M;
    Solution s;
    if(s.Possibility(a,b,M))
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    return 0;
}
【CSP-J入门组】【22240】：https://ac.nowcoder.com/acm/problem/22240
#include <iostream>
using namespace std;
class Solution{
    public:
    int possible(const int& n,const int& a,const int& b){
        int res = 0;
        int pre = n - a - 1;
        for(int i = n - 1;pre>=0;--i,--pre){
            if(n-1-i<=b)
                ++res;
            else
                break;
        }
        return res;
    }
};
int main(){
    int n,a,b;
    cin>>n>>a>>b;
    Solution s;
    cout<<s.possible(n,a,b)<<endl;
    return 0;
}

【CSP-J入门组】【22241】：https://ac.nowcoder.com/acm/problem/22241
#include <iostream>
#include <queue>
using namespace std;
class Solution{
    public:
    void Water(const int& Y,const int& k,const int& n,queue<int>& s){
        for(int i = 1;i <= n/k;++i){
            if(i*k>=Y)
                s.push(k*i-Y);
        }
    }
};
int main(){
    int Y,n,k;
    cin>>Y>>k>>n;
    queue<int> s;
    Solution so;
    so.Water(Y,k,n,s);
    if(s.empty())
        cout<<-1<<endl;
    else{
        while(s.size()){
            cout<<s.front()<<" ";
            s.pop();
        }
    }
    return 0;
}

LeetCode【145】【二叉树的后序遍历】：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root)
            return res;
        stack<TreeNode*> st;
        TreeNode* par = nullptr;
        while(root || !st.empty()){
            while(root){
                st.push(root);
                root = root->left; 
            }
            root = st.top();
            st.pop();
            if(!root->right || root->right == par){//没有右树 or 右树返回
                res.push_back(root->val);
                par = root;
                root = nullptr;
            }else{//进入右树
                st.push(root);
                root = root->right;
            }
        }
        return res;
    }
};
LeetCode【94】【二叉树的中序遍历】：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root)
            return res;
        stack<TreeNode*> st;
        while(root || !st.empty()){
            while(root){
                st.push(root);
                root = root->left;
            }
            root = st.top();
            st.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
LeetCode【144】【二叉树的前序遍历】：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root)
            return res;
        stack<TreeNode*> st;
        while(root || !st.empty()){
            while(root){
                st.push(root);
                res.push_back(root->val);
                root = root->left;
            }
            root = st.top();
            st.pop();
            root = root->right;
        }
        return res;
    }
};

LeetCode【105】【根据前中序恢复二叉树】：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        return creat_VLR_LVR(preorder, inorder, n);
    }
    TreeNode* creat_VLR_LVR(vector<int>& preorder, vector<int>& inorder, int n) {
        if (!n)
            return nullptr;
        int k = 0;
        while (inorder[k] != preorder[0])
            ++k;
        TreeNode* t = new TreeNode(inorder[k]);
        vector<int> inl(inorder.begin(), inorder.begin() + k);
        vector<int> inr(inorder.begin() + k + 1, inorder.end());
        vector<int> prel(preorder.begin() + 1, preorder.begin() + k+1);
        vector<int> prer(preorder.begin() + k + 1, preorder.end());
        t->left = creat_VLR_LVR(prel, inl, k);
        t->right = creat_VLR_LVR(prer, inr, n - k - 1);
        return t;
    }
};

LeetCode【450】【删除二叉搜索树中的节点】：https://leetcode-cn.com/problems/delete-node-in-a-bst/
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root)
            return nullptr;
        if(key>root->val)
            root->right = deleteNode(root->right,key);
        else if(key<root->val)
            root->left = deleteNode(root->left,key);
        else{
            TreeNode* p = nullptr;
            if(root->left && root->right){
                p = root->right;
                while(p->left)
                     p = p->left;
                p->left = root->left;
                root = root->right;
            }
            else{
                if(root->left)
                    return root->left;
                else
                    return root->right;
            }
        }
        return root;
    }
};

剑指offer【36】【二叉搜索树与双向链表】：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if(!root)
            return root;
        DFS(root);
        head->left = pre;
        pre->right = head;
        return head;
    }
    void DFS(Node* cur){
        if(!cur)
            return;
        DFS(cur->left);
        if(pre)
            pre->right = cur;
        else
            head = cur;
        cur->left = pre;
        pre = cur;
        DFS(cur->right);
    }
private:
    Node* pre;
    Node* head;
};

LeetCode【1117】【H2O生成】：https://leetcode-cn.com/problems/building-h2o/
#include <semaphore.h> 
class H2O {
public:
    H2O() {
        sem_init(&hjob,0,0);// H 反应条件信号量
        sem_init(&ojob,0,0);// O 反应条件信号量
        sem_init(&hlimit,0,2);// H线程信号量
        sem_init(&olimit,0,1);// O线程信号量
    }

    void hydrogen(function<void()> releaseHydrogen) {
        sem_wait(&hlimit);// 保证只有2个H线程进入执行
        sem_post(&hjob);// 释放H原子到达信号
        sem_wait(&ojob);// 等待O原子到达
        // releaseHydrogen() outputs "H". Do not change or remove this line.
        releaseHydrogen();        
        sem_post(&hlimit);// 相当于唤醒1个H线程
    }

    void oxygen(function<void()> releaseOxygen) {
        sem_wait(&olimit);// 保证只有1个O线程进入执行
        sem_post(&ojob);// 释放O原子到达信号，因为有2个H线程等待所以释放2个
        sem_post(&ojob);
        sem_wait(&hjob);// 等待H原子到达，2个原因同上
        sem_wait(&hjob);
        // releaseOxygen() outputs "O". Do not change or remove this line.
        releaseOxygen();
        sem_post(&olimit);// 相当于唤醒1个O线程
    }
    private:
        sem_t hjob;
        sem_t ojob;
        sem_t hlimit;
        sem_t olimit;
};
牛客【组队竞赛】：大意是给3*n个整数，每3个数字为一组，如何分配使所有组的第二大数字之和最大
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    long long MaxLevel(vector<int>& level, const int& n) {
        sort(level.begin(), level.end());
        long long  res = 0;
        for (int i = n; i < 3 * n; i+=2)
            res += level[i];
        return res;
    }
};
int main() {
    int n;
    cin >> n;
    vector<int> level(3*n);
    for (int i = 0; i < 3*n; ++i)
        cin >> level[i];
    Solution s;
    cout << s.MaxLevel(level, n) << endl;
    return 0;
}

牛客【删除字符串】：删除s1中s2含有的所有字符：
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
class Solution {
public:
    void Remove(string& s1, const string& s2) {
        int sz = s2.size();
        for (auto& s : s2) {
            auto it = s1.begin();
            while (it != s1.end()) {
                it = find(it, s1.end(), s);
                if(it == s1.end())
                    break;
                it = s1.erase(it, it+1);
            }
        }
    }
};
int main() {
    char* buf = new char[512];
    memset(buf, '\0', 512);
    cin.getline(buf, 512);
    string s1(buf);
    memset(buf, '\0', 512);
    cin.getline(buf, 512);
    string s2(buf);
    Solution s;
    s.Remove(s1, s2);
    cout << s1 << endl;
    return 0;
}

【牛客】【子排列划分】：给一个数组，将该数组划分为非递增/非递减子排列，最少划分为几段？
//排序子序列
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int Split(const vector<int>& seq) {
        int sz = seq.size();
        int cnt = 0;//划分次数
        vector<int> tmp(sz);
        tmp[0] = 0;
        for (int i = 1; i < sz; ++i) {
            if (seq[i] - seq[i - 1] > 0)//递增
                tmp[i] = 1;
            else if (seq[i] - seq[i - 1] == 0)//相等
                tmp[i] = 0;
            else//递减
                tmp[i] = -1;
        }
        auto it = tmp.begin();
        while (it != tmp.end()) {
            auto zero = find(it, tmp.end(), 0);
            if (zero != tmp.end())
                it = tmp.erase(zero, zero + 1);
            else
                break;
        }
        sz = tmp.size();
        for (int i = 1; i < sz; i++)
            if (tmp[i - 1] != tmp[i]) {
                ++cnt;
                ++i;
            }
            
        return cnt+1;
    }
};
int main() {
    int n;
    cin >> n;
    vector<int> seq(n);
    for (int i = 0; i < n; ++i)
        cin >> seq[i];
    Solution s;
    cout << s.Split(seq) << endl;
    return 0;
}

【牛客】【单词翻转】：给一个英语句子，将单词翻转:eg.i  like beijing!    输出：beijing! like i
#include <iostream>
#include <string>
#include <string.h>
#include <algorithm>
using namespace std;

class Solution {
public:
    void Reverse(string& str) {
        char* start = (char*)str.c_str();
        char* begin = start;
        char* end = start;
        string res;
        while (*end)
            ++end;
        start = end - 1;
        while (start != begin) {
            while (start!=begin && isspace(*start))//越过空格
                --start;
            end = start;//end指向单词最后一个字母
            while (start!=begin && !isspace(*start))//越过单词
                --start;
            if (start-begin>0) {
                string tmp(start + 1, end + 1);//单词记录
                res += tmp;
                res += ' ';
            }
            else if (start == begin) {
                string tmp(start, end + 1);//单词记录
                res += tmp;
            }else
                break;
        }
        str = res;
        return;
    }
};
int main() {
    char* buf = new char[101];
    memset(buf, '\0', 101);
    cin.getline(buf, 101);
    Solution s;
    string str(buf);
    s.Reverse(str);
    cout << str << endl;
};

LeetCode【993】【二叉树的堂兄弟节点】：https://leetcode-cn.com/problems/cousins-in-binary-tree/
class Solution {
public:
    bool isCousins(TreeNode* root, int x, int y) {
        h.push_back(0),h.push_back(0);
        par.push_back(nullptr),par.push_back(nullptr);
        Measure(root,x,0,0,nullptr);
        Measure(root,y,1,0,nullptr);
        return h[0]==h[1] && par[0]!=par[1];
    }
    private:
    void Measure(TreeNode* root,const int& key,const int& index,int hv,TreeNode* p){
        if(!root){
            h[index] = hv;
            par[index] = nullptr;
            return;
        }
        if(root->val != key){
            if(root->left)
                Measure(root->left,key,index,hv+1,root);
            if(root->right)
                Measure(root->right,key,index,hv+1,root); 
        }else{
            h[index] = hv;
            par[index] = p;
        }
    }
    private:
    vector<int> h;
    vector<TreeNode*> par;
};

【牛客】【寻找字符串中最长连续数字串】：
//寻找最长连续数字字符串
#include <iostream>
#include <string.h>
#include <string>
using namespace std;

class Solution {
public:
	string Seek(const string& str) {
		int len = 0;
		string maxL;
		int sz = str.size();
		int i = 0;
		while (i < sz) {
			string tmp;
			if (str[i] >= '0' && str[i] <= '9') {
				tmp += str[i++];
				while (str[i] >= '0' && str[i] <= '9' && str[i] == str[i - 1] + 1)
					tmp += str[i++];
			}
			else
				++i;
			int l = tmp.size();
			if (l > len)
				maxL = tmp, len = l;

		}
		return maxL;
	}
};
int main() {
	char* buf = new char[256];
	memset(buf, '\0', 256);
	cin.getline(buf, 256);
	string str(buf);
	Solution s;
	cout << s.Seek(str) << endl;
	return 0;
}

【牛客】【数组中出现次数超一半的数】：
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        int sz = numbers.size();
        int x = 0;
        int votes = 0;
        for (int i = 0; i < sz; ++i) {
            x = votes == 0 ? numbers[i] : x;
            votes += numbers[i] == x ? 1 : -1;
        }
        int cnt = 0;
        for (int i = 0; i < sz; ++i)
            cnt += numbers[i] == x ? 1 : 0;
        return cnt > sz / 2 ? x : 0;
    }
};

int main() {
    Solution s;
    vector<int> v{1,2,3,2,2,2,5,4,2};
    cout << s.MoreThanHalfNum_Solution(v) << endl;
    return 0;
}

【牛客】【A,B,C糖果】：
#include <iostream>
#include <vector>
using namespace std;

class Solution{
    public:
    void CandyCal(vector<int>& res,const vector<int>& input){
        res[0] = (input[0]+input[2])>>1;
        res[1] = input[2] - res[0];
        res[2] = input[3] - res[1]; 
    }
};

int main(){
    vector<int> input(4);
    vector<int> res(3,0);
    for(int i = 0; i < 4; ++i)
        cin>>input[i];
    Solution s;
    s.CandyCal(res,input);
    if(res[0]-res[1]!=input[0] || res[1]-res[2]!=input[1] || 
       res[0]+res[1]!=input[2] || res[1]+res[2]!=input[3]){
        cout<<"No"<<endl;
        return 0;
    }
    cout<<res[0]<<" "<<res[1]<<" "<<res[2]<<endl;
    return 0;
}

【牛客】【十进制转任意进制】：
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

class Solution{
    public:
        char num[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
    public:
    void swift(int M,const int& N){
        int flag = M<0?1:0;
        string res;
        M *= M<0?-1:1;
        while(M > 0){
            res += num[M%N];
            M /= N;
        }
        if(flag)
            res += '-';
        reverse(res.begin(),res.end());
        if(res.size()==0)
            cout<<"0"<<endl;
        else
            cout<<res<<endl;
    }
};
int main(){
    int M,N;
    cin>>M>>N;
    Solution s;
    s.swift(M,N);
    return 0;
}

LeetCode【1114】【按序打印】：https://leetcode-cn.com/problems/print-in-order/
#include <semaphore.h>
class Foo {
public:
    Foo() {
        sem_init(&one_done,0,0);
        sem_init(&two_done,0,0);
    }

    void first(function<void()> printFirst) {
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        sem_post(&one_done);
    }

    void second(function<void()> printSecond) {
        sem_wait(&one_done);
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        sem_post(&two_done);
    }

    void third(function<void()> printThird) {
        sem_wait(&two_done);
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
    private:
    sem_t one_done;
    sem_t two_done;
};

LeetCode【682】【棒球比赛】：https://leetcode-cn.com/problems/baseball-game/
class Solution {
public:
    int calPoints(vector<string>& ops) {
        int sz = ops.size();
        stack<int> st;
        st.push(to_num(ops[0]));
        for(int i = 1; i < sz; ++i){
            if(ops[i] == "+"){
                int num1 = st.top();
                st.pop();
                int num2 = st.top();
                st.push(num1);
                st.push(num1+num2);
            }
            else if(ops[i] == "D")
                st.push(2*st.top());
            else if(ops[i] == "C")
                st.pop();
            else
                st.push(to_num(ops[i]));
        }
        int score = 0;
        while(!st.empty()){
            score+=st.top();
            st.pop();
        }
        return score;
    }
    private:
    int to_num(string s){
        int num = 0;
        int flag = s[0] == '-'?-1:1;
        int sz = s.size();
        int i = flag == -1?1:0;
        for(; i < sz; ++i)
            num = num*10 + (s[i]-'0'); 
        return num*flag;
    }
};

【牛客】【不要2】：
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

class Solution{
    public:
    int Cake(const int& W,const int& H){
        int res = 0;
        vector<vector<bool>> cake(H,vector<bool> (W,true));
        for(int i = 0; i < H;++i){
            for(int j = 0; j < W; ++j){
                if(cake[i][j]){
                    ++res;
                    if(i+2<H)
                        cake[i+2][j] = false;
                    if(j+2<W)
                        cake[i][j+2] = false;
                }
            }
        }
        return res;
    }
};

int main(){
    int W,H;
    Solution s;
    while(cin>>W>>H)
        cout<<s.Cake(W,H)<<endl;
    return 0;
}
【牛客】【将字符串转换为整数】：
class Solution {
public:
    int StrToInt(string str) {
        int sz = str.size();
        if(!sz)
            return 0;
        long res = 0;
        int i = 0;
        int flag = 1;
        while(isspace(str[i]))
            ++i;
        if(str[i] == '-')
            flag = -1,++i;
        else if(str[i] == '+')
            flag = 1,++i;
        else if('9'<=str[i] || str[i]<='0')
            return 0;
        for(int j = i; j < sz; ++j)
            if(str[j]>='9' || str[j]<='0')
                return 0;
        while('0'<=str[i] && str[i]<='9' && res == (int)res)
            res = res*10 + (str[i++] - '0');
        if(res!=(int)res)
            return 0;
        return (int)flag*res;
    }
};

LeetCode【692】【前K个高频单词】：https://leetcode-cn.com/problems/top-k-frequent-words/
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string,int> cnt;
        for(auto& s:words)
            ++cnt[s];
        vector<pair<string,int>> tmp(cnt.begin(),cnt.end());
        sort(tmp.begin(),tmp.end(),compare);
        vector<string> ans;
        for(int i = 0; i < k; ++i)
            ans.push_back(tmp[i].first);
        return ans;
    }
private:
static bool compare(const pair<string,int>& t1,const pair<string,int>& t2){
        if(t1.second == t2.second)
            return t1.first<t2.first;
        return t1.second>t2.second;
    }
};

LeetCode【884】【 两句话中的不常见单词】：https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/
class Solution {
public:
    vector<string> uncommonFromSentences(string s1, string s2) {
        vector<string> v1;
        vector<string> v2;
        Swift(v1,s1);
        Swift(v2,s2);
        map<string,int> mp1;
        map<string,int> mp2;
        for(auto& s:v1)
            ++mp1[s];
        for(auto& s:v2)
            ++mp2[s];
        vector<string> ans;
        for(auto& it:mp1)
            if(it.second==1 && mp2[it.first]==0)
                ans.push_back(it.first);
         for(auto& it:mp2)
            if(it.second==1 && mp1[it.first]==0)
                ans.push_back(it.first);
        return ans;
    }
private:
    void Swift(vector<string>& v, const string& s) {
        int start = 0;
        int end = 0;
        int sz = s.size();
        while (end < sz) {
            while (start < sz && s[start] == ' ')
                ++start;
            end = start;
            while (end < sz && s[end] != ' ')
                ++end;
            v.push_back(s.substr(start, end - start));
            start = end;
        }
    }
};

【牛客】【合法括号序列判断】：
class Parenthesis {
public:
    bool chkParenthesis(string A, int n) {
        if(!n || n&1 || A[0]!='(')
            return false;
        stack<char> st;
        for(int i = 0; i < n; ++i){
            if(A[i] == ')' && (!st.empty()) && st.top()=='(')
                st.pop();
            else if(A[i] == '(')
                st.push(A[i]);
            else
                return false;
        }
        return st.empty();
    }
};
【牛客】【将N变为斐波那契数列成员的最小步数】：
#include <iostream>
#include <cmath>
using namespace std;

class Solution {
public:
    int MinStep(const int& N) {
        int* dp = new int[3];
        dp[0] = 0, dp[1] = 1;
        dp[2] = 0;
        while (N > dp[2]) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return min(N - dp[0], dp[1] - N);
    }
};
int main() {
    int N;
    cin >> N;
    Solution S;
    cout << S.MinStep(N) << endl;
    return 0;
}

【牛客】【素数】：输出1至N之间所有个位为1的素数
#include <iostream>
#include <cmath>
using namespace std;
class  Solution{
public:
    void Show(const int& n){
        int cnt = 0;
        for(int i = 11; i < n; i+=10){
            if(Right(i)){
                ++cnt;
                cout<<i<<" ";
            }
        }
        if(!cnt){
            cout<<-1<<endl;
            return;
        }
        cout<<endl;
    }
private:
    bool Right(const int& x){
        for(int i = 3; i <= sqrt(x); i += 2)
            if(!(x%i))
                return false;
        return true;
    }
};
int main(){
    int n;
    Solution S;
    while(cin>>n)
        S.Show(n);
    return 0;
}

【牛客】【字典序与长度序】：
#include <iostream>
#include <string>
#include <vector>
#include <string.h>
using namespace std;
class  Solution {
public:
    void ShowRes(const vector<string>& v, const int& n) {
        int flag = WhichKind(v, n);
        if (!flag)
            cout << "none" << endl;
        else if (flag == 1)
            cout << "lexicographically" << endl;
        else if (flag == 2)
            cout << "lengths" << endl;
        else
            cout << "both" << endl;
    }
private:
    int WhichKind(const vector<string>& v, const int& n) {
        int flagd = 1, flagl = 1;
        for (int i = 0; i < n - 1; ++i) {
            if (strcmp(v[i].c_str(), v[i + 1].c_str()) > 0)
                flagd = 0;
            if (v[i].size() > v[i + 1].size())
                flagl = 0;
        }
        if (flagd && flagl)
            return 3;
        else if (flagd)
            return 1;
        else if (flagl)
            return 2;
        return 0;
    }
};
int main() {
    int n;
    cin >> n;
    getchar();
    vector<string> v(n);
    for (int i = 0; i < n; ++i)
        getline(cin, v[i]);
    Solution S;
    S.ShowRes(v, n);
    return 0;
}

【牛客】【最小公倍数】：
#include <iostream>
#include <map>
#include <cmath>
using namespace std;

class Solution{
public:
    void Test(const int& A,const int& B){
        int Max = A>B?A:B;
        int Min = A>B?B:A;
        if(!(Max%Min)){
            cout<<Max<<endl;
            return;
        }
        int res = Max;
        for(int i = 2;res%Min;++i)
            res = Max*i;
        cout<<res<<endl;
    }
};
int main(){
    int A,B;
    cin>>A>>B;
    Solution S;
    S.Test(A,B);
    return 0;
}

【牛客】【单词识别】：https://www.nowcoder.com/practice/16f59b169d904f8898d70d81d4a140a0?tpId=94&tqId=31064&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fbit-kaoyan%2Fquestion-ranking&tPage=2
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <unordered_map>
using namespace std;

class Solution {
public:
    void Show(const string& s) {
        vector<string> v;
        Split(s, v);
        unordered_map<string, int> mp;
        for (auto& s : v)
            ++mp[s];
        vector<pair<string,int>> v2(mp.begin(),mp.end());
        sort(v2.begin(), v2.end(), compare);
        for (auto& it : v2)
            cout << it.first << ":" << it.second << endl;
    }
private:
    void Split(const string& s, vector<string>& v) {
        auto start = s.begin();
        auto last = start;
        while (last != s.end()) {
            auto last = find(start, s.end(), ' ');
            string tmp(start, last);
            auto it = find(tmp.begin(), tmp.end(), '.');
            while (it != tmp.end()) {
                it = tmp.erase(it);
                it = find(it, tmp.end(), '.');
            }
            v.push_back(tmp);
            while (last!=s.end() && *last == ' ')
                ++last;
            start = last;
            if (start == s.end())
                break;
        }
        Swift(v);
    }
    void Swift(vector<string>& v) {
        int sz = v.size();
        for (int i = 0; i < sz; ++i) {
            int n = v[i].size();
            for (int j = 0; j < n; ++j) {
                if (v[i][j] <= 'Z' && v[i][j] >= 'A')
                    v[i][j] += 32;
            }
        }
    }
    static bool compare(const pair<string, int>& s1, const pair<string, int>& s2) {
        if (s1.second == s2.second)
            return s1.first < s2.first;
        return s1.second > s2.second;
    }
};
int main() {
    string s;
    getline(cin, s);
    Solution S;
    S.Show(s);
    return 0;
}

【牛客】【华为机试题，棋盘路线】：从左上角沿着格子边缘走，多少走法走到右下角
#include <iostream>
#include <vector>
using namespace std;

class Solution{
    public:
    int WayNum(const int& n,const int& m){
        vector<vector<int>> board(n+1,vector<int>(m+1,1));
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= m; ++j)
                board[i][j] = board[i-1][j] + board[i][j-1];
        }
        return board[n][m];
    }
};
int main(){
    int n,m;
    Solution S;
    while(cin>>n>>m)
        cout<<S.WayNum(n,m)<<endl;
    return 0;
}

【牛客】【井字棋】：
class Board {
public:
    bool checkWon(vector<vector<int>> board) {
        if(board.size()!=3 || board[0].size()!=3)
            return false;
        for(int i = 0; i < 3; ++i){
            if(board[i][0]+board[i][1]+board[i][2]==3)return true;
            if(board[0][i]+board[1][i]+board[2][i]==3)return true;
        }
        if(board[1][1]!=1)
            return false;
        if(board[0][0]+board[2][2]==2)return true;
        if(board[0][2]+board[2][0]==2)return true;
        return false;
    }
};

【牛客】【密码强度等级】：
class Solution{
public:
    void SafeLevel(const string& pwd){
        int score = 0;
        int sz = pwd.size();
        if(sz<=4)
            score += 5;
        else if(sz<=7)
            score += 10;
        else
            score += 25;
        int num_cnt = 0,char_cnt = 0;
        bool lower = false;
        bool upper = false;
        for(int i = 0; i < sz; ++i){
            if(pwd[i]>='0' && pwd[i]<='9')
                ++num_cnt;
            else if(pwd[i]>='a' && pwd[i]<='z')
                lower = true;
            else if(pwd[i]>='A' && pwd[i]<='Z')
                upper = true;
            else
                ++char_cnt;
        }
        score += num_cnt?(num_cnt>1?20:10):0;
        score += lower&&upper?20:((!lower && !upper)?0:10);
        score += char_cnt?(char_cnt>1?25:10):0;
        if(lower&&upper&&num_cnt&&char_cnt)
            score += 5;
        else if((lower||upper)&&num_cnt&&char_cnt)
            score += 3;
        else if((lower||upper)&&num_cnt)
            score += 2;
        if(score >= 90)
            cout<<"VERY_SECURE"<<endl;
        else if(score >= 80)
             cout<<"SECURE"<<endl;
        else if(score >= 70)
             cout<<"VERY_STRONG"<<endl;
        else if(score >= 60)
             cout<<"STRONG"<<endl;
        else if(score >= 50)
            cout<<"AVERAGE"<<endl;
        else if(score >= 25)
            cout<<"WEAK"<<endl;
        else
            cout<<"VERY_WEAK"<<endl;
    }
};

int main(){
    string s;
    Solution S;
    while(getline(cin,s))
        S.SafeLevel(s);
    return 0;
}

【牛客】【寻找最近父节点】：满二叉树从根节点按层序编号，1开编，输入两个数，求最近父节点
class LCA {
public:
    int getLCA(int a, int b) {
        if(a==b)
            return a;
        if(a/2 == b/2)
            return a/2;
        while(a!=b){
            if(a>b)
                a /= 2;
            else if(b>a)
                b /= 2;
        }
        return a;
    }
};
【牛客】【二进制序列最长连续1长度】：
#include <iostream>
#include <vector>
using namespace std;
class Solution {
public:
    void Rec(const int& n) {
        vector<int> s(32, 0);
        for (int i = 0; i < 32; ++i)
            s[32 - 1 - i] = (n >> i) & 1;
        int len = 0;
        int l = 0;
        int r = 0;
        while (r < 32) {
            while (l < 32 && !s[l])
                ++l;
            r = l;
            while (r < 32 && s[r])
                ++r;
            len = r - l > len ? r - l : len;
            l = r;
        }
        cout << len << endl;
    }
};
int main() {
    Solution S;
    int n;
    while (cin >> n)
        S.Rec(n);
    return 0;
}

【牛客】【将偶数分解为两个差值最小的素数和】：
#include <iostream>
#include <cmath>
using namespace std;

class Solution{
public:
    void Seek(const int& n){
        int l = n/2,r = n/2;
        while(!test(l) || !test(r)){//任何一个非素数都会继续循环；
            if(!test(l) || !test(r))
                --l,++r;
        }
        cout<<l<<endl<<r<<endl;
    }
private:
    bool test(const int& x){//素数返回true，否则false
        if(x == 2)
            return true;
        if(x == 1 || !(x%2) || (x>10 && !(x%5)))
           return false;
        for(int i = 3; i <= sqrt(x); ++i)
            if(!(x%i))
                return false;
        return true;
    }
};
int main(){
    int n;
    Solution S;
    while(cin>>n)
        S.Seek(n);
    return 0;
}

【牛客】【将m的二进制值插入到n的二进制值得j至i位】:
class BinInsert {
public:
    int binInsert(int n, int m, int j, int i) {
        return  n ^= (m << j);
    }
};

【牛客】【跳石板】：https://www.nowcoder.com/questionTerminal/4284c8f466814870bae7799a07d49ec8
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

class Solution {
public:
    int MinStep(const int& N, const int& M) {
        vector<int> step(M + 1, M + 1);
        step[N] = 0;
        for (int i = N; i <= M; ++i) {
            if (step[i] == M + 1)
                continue;
            for (int j = 2; j * j <= i; ++j) {
                if (!(i % j)) {
                    if (i + j <= M)
                        step[i + j] = min(step[i + j], step[i] + 1);
                    if (i + i / j <= M)
                        step[i + i / j] = min(step[i + i / j], step[i] + 1);
                }
            }
        }
        return step[M] == M + 1 ? -1 : step[M];
    }
};

int main() {
    int N, M;
    Solution S;
    while (cin >> N >> M)
        cout << S.MinStep(N, M) << endl;
    return 0;
}


【牛客】【参数解析】：
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    void Split(string& s) {
        vector<string> v;
        bool flag1 = false, flag2 = false;
        char* start = (char*)s.c_str();
        char* left = start;
        char* right = left;
        while (*right) {
            while (*left == ' ')//越过空格
                ++left;
            if (*left == '"') {
                flag1 = true;
                ++left;
            }
            right = left;
            while (*right && *right != ' ' || flag1) {
                if (*right == '"') {
                    flag2 = true;
                    break;
                }
                ++right;
            }
            string tmp(s.substr(left - start, right-left));
            v.push_back(tmp);
            if (*right)
                ++right;
            else
                break;
            left = right;
            flag1 = flag2 = false;
        }
        int sz = v.size();
        cout << sz << endl;
        for (int i = 0; i < sz; ++i)
            cout << v[i] << endl;
    }
};

int main() {
    string s;
    Solution S;
    while (getline(cin, s))
        S.Split(s);
    return 0;
}

【牛客】【幸运袋子】：https://www.nowcoder.com/questionTerminal/a5190a7c3ec045ce9273beebdfe029ee?source=relative
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
	int Count(const int& n, vector<int>& x) {
		N = n;
		sort(x.begin(), x.end());
		dfs(0, x);
		return cnt;
	}
private:
	void dfs(int index,const vector<int>& x) {
		for (int i = index; i < N; i++){
			sum += x[i];
			mul *= x[i];
			if (sum > mul) {
				cnt++;
				dfs(i + 1, x);
			}
			else if (x[i] == 1)
				dfs(i + 1,x);
			else {
				sum -= x[i];
				mul /= x[i];
				break;
			}
			sum -= x[i];
			mul /= x[i];
			for (; i < N - 1 && x[i] == x[i + 1]; i++);
		}
	}
private:
	int mul = 1;
	int sum = 0;
	int cnt = 0;
	int N;
};

int main() {
	int n;
	cin >> n;
	vector<int> ball(n, 0);
	for (int i = 0; i < n; ++i)
		cin >> ball[i];
	Solution S;
	cout << S.Count(n, ball) << endl;
	return 0;
}

【牛客】【计算日期是该年的第几天】：
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    int CountDay(const vector<int>& v) {
        if (v[0] <= 0 || v[1] <= 0 || v[1] > 12
            || v[2] <= 0 || v[2] > 31)
            return -1;
        int day = 0;
        bool flag = IsLeapYear(v[0]);
        for (int i = 1; i < v[1]; ++i) {
            if (i == 2 && flag)
                day += month[0];
            else
                day += month[i];
        }
        return day + v[2];
    }
private:
    bool IsLeapYear(const int& y) {
        if (!(y % 400))//世纪闰年
            return true;
        if (!(y % 4) && y % 100)//普通闰年
            return true;
        return false;
    }
private:
    int month[13] = { 29,31,28,31,30,31,30,31,31,30,31,30,31 };
};

int main() {
    vector<int> n(3, 0);
    Solution S;
    while (cin >> n[0] >> n[1] >> n[2])
        cout << S.CountDay(n) << endl;
    return 0;
}

【牛客】【手套】：https://www.nowcoder.com/questionTerminal/365d5722fff640a0b6684391153e58d8
class Gloves {
public:
    int findMinimum(int n, vector<int> left, vector<int> right) {
        int left_sum = 0,right_sum = 0;
        int left_min = 27,right_min = 27;
        int zeros = 0;
        for(int i = 0; i <n ; ++i){
            if(!left[i] || !right[i])//不能匹配
                zeros += (left[i]+right[i]);//全取
            else{
                left_sum += left[i];//左手套求和
                right_sum += right[i];//右手套求和
                left_min = min(left[i],left_min);//左手套最少值
                right_min = min(right[i],right_min);//右手套最少值
            }
        }
        //在一边覆盖所有颜色需要取的最少数量
        int res = zeros + min(left_sum-left_min+1,right_sum-right_min+1);
        return res + 1;//在另一组拿一个即可
    }
};

【牛客】【N对应的二进制1的个数】：
#include <iostream>
using namespace std;

class Solution {
public:
    int CountOne(int& N) {
        int cnt = 0;
        while (N) {
            ++cnt;
            N &= (N - 1);
        }
        return cnt;
    }
};
int main() {
    int n;
    Solution S;
    while (cin >> n)
        cout << S.CountOne(n) << endl;
    return 0;
}

【牛客】【扑克牌】：
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void Winner(string& s) {
        vector<vector<string>> card(split(s));
        int sz1 = card[0].size();
        int sz2 = card[0].size();
        int win = WhichWinner(card);
        if (win == -1) {
            cout << "ERROR" <<endl;
            return;
        }
        int sz_w = card[win].size();
        for (int i = 0; i < sz_w; ++i)
            cout << card[win][i] << " ";
        cout << endl;
    }
private:
    vector<vector<string>> split(string& s) {
        bool flag = false;
        vector<vector<string>> ans(2);
        auto it = find(s.begin(), s.end(), '-');
        string s1(s.begin(), it);
        string s2(it + 1, s.end());
        int i = 0;
        it = s1.begin();
        while (it != s1.end()) {
             if (*it == ' ') {
                ++it;
                continue;
             }
             ans[0].push_back("");
             while (it!=s1.end() && *it != ' ') {
                    ans[0][i] += *it;
                    ++it;
             }
              ++i;
            }
        i = 0;
        it = s2.begin();
        while (it != s2.end()) {
            if (*it == ' ') {
                ++it;
                continue;
            }
            ans[1].push_back("");
            while (it != s2.end() && *it != ' ') {
                ans[1][i] += *it;
                ++it;
            }
            ++i;
        }
        return ans;
    }
    int WhichWinner(vector<vector<string>>& card) {
        int sz0 = card[0].size();
        int sz1 = card[1].size();
        //存在对王
        if (card[0][0].size() == 5)
            return 0;
        if (card[1][0].size() == 5)
            return 1;
        vector<string> tmp{ "3","4","5","6","7","8","9","10","J","Q","K","A","2" };
        if (sz0 == sz1) { //牌数相等
            bool f0 = false, f1 = false;
            for (int i = 0; i < 13; ++i) {
                if (!f0 && tmp[i] == card[0][0]) {
                    f0 = true;
                    break;
                }
                if (!f1 && tmp[i] == card[1][0]) {
                    f1 = true;
                    break;
                }
            }
            return f0 ? 1 : 0;
        }
        else if (sz0 == 4 || sz1 == 4) //存在炸弹
            return sz0 == 4 ? 0 : 1;//谁是炸弹谁赢
        return -1;//异常
    }
};
int main() {
    string s;
    Solution S;
    while (getline(cin, s))
        S.Winner(s);
    return 0;
}


【牛客】【N内的完备数】：
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void Winner(string& s) {
        vector<vector<string>> card(split(s));
        int sz1 = card[0].size();
        int sz2 = card[0].size();
        int win = WhichWinner(card);
        if (win == -1) {
            cout << "ERROR" <<endl;
            return;
        }
        int sz_w = card[win].size();
        for (int i = 0; i < sz_w; ++i)
            cout << card[win][i] << " ";
        cout << endl;
    }
private:
    vector<vector<string>> split(string& s) {
        bool flag = false;
        vector<vector<string>> ans(2);
        auto it = find(s.begin(), s.end(), '-');
        string s1(s.begin(), it);
        string s2(it + 1, s.end());
        int i = 0;
        it = s1.begin();
        while (it != s1.end()) {
             if (*it == ' ') {
                ++it;
                continue;
             }
             ans[0].push_back("");
             while (it!=s1.end() && *it != ' ') {
                    ans[0][i] += *it;
                    ++it;
             }
              ++i;
            }
        i = 0;
        it = s2.begin();
        while (it != s2.end()) {
            if (*it == ' ') {
                ++it;
                continue;
            }
            ans[1].push_back("");
            while (it != s2.end() && *it != ' ') {
                ans[1][i] += *it;
                ++it;
            }
            ++i;
        }
        return ans;
    }
    int WhichWinner(vector<vector<string>>& card) {
        int sz0 = card[0].size();
        int sz1 = card[1].size();
        //存在对王
        if (card[0][0].size() == 5)
            return 0;
        if (card[1][0].size() == 5)
            return 1;
        vector<string> tmp{ "3","4","5","6","7","8","9","10","J","Q","K","A","2" };
        if (sz0 == sz1) { //牌数相等
            bool f0 = false, f1 = false;
            for (int i = 0; i < 13; ++i) {
                if (!f0 && tmp[i] == card[0][0]) {
                    f0 = true;
                    break;
                }
                if (!f1 && tmp[i] == card[1][0]) {
                    f1 = true;
                    break;
                }
            }
            return f0 ? 1 : 0;
        }
        else if (sz0 == 4 || sz1 == 4) //存在炸弹
            return sz0 == 4 ? 0 : 1;//谁是炸弹谁赢
        return -1;//异常
    }
};
int main() {
    string s;
    Solution S;
    while (getline(cin, s))
        S.Winner(s);
    return 0;
}

【牛客】【超长正整数相加】：
#include <iostream>
#include <string>
using namespace std;

class Solution {
public:
    string BigNumAdd(const string& n1, const string& n2) {
        int sz1 = n1.size();
        int sz2 = n2.size();
        int len = sz1 > sz2 ? sz1 + 1 : sz2 + 1;
        string ans(len, '0');
        int flag = 0;
        int index1 = sz1 - 1;
        int index2 = sz2 - 1;
        int tmp = 0;
        int x = 0, y = 0;
        for (int i = len - 1; i >= 0; --i) {
            x = index1 >= 0 ? n1[index1--] - '0' : 0;
            y = index2 >= 0 ? n2[index2--] - '0' : 0;
            tmp = x + y + flag;
            ans[i] = tmp % 10 + '0';
            flag = tmp / 10;
        }
        if (ans[0] == '0')
            ans.erase(ans.begin());
        return ans;
    }
};
int main() {
    string s1, s2;
    Solution S;
    while (cin >> s1 >> s2)
        cout << S.BigNumAdd(s1, s2) << endl;
    return 0;
}

【牛客】【INOC产品部】【杨辉三角的变形】：
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    int SeekLoc(const int& N) {
        vector<int> Old(2 * N + 1, 0);
        vector<int> New(2 * N + 1, 0);
        Old[N] = 1;//中间初始值
        for (int i = 1; i <= N; ++i) {
            for (int j = 0; j < i; ++j) {
                New[N - j] = Old[N - j] + Old[N - j - 1] + Old[N - j + 1];
                New[N + j] = New[N - j];
            }
            Old = New;
        }
        int res = -1;
        for (int i = 1; i < N; ++i) {
            if (!(New[i] & 1)) {
                res = i;
                break;
            }
        }
        return res;
    }
};
int main() {
    int n;
    Solution S;
    while (cin >> n)
        cout << S.SeekLoc(n) << endl;
    return 0;
}

【牛客】【字符串通配符】：
#include <string>
#include <vector>
#include <iostream>
using namespace std;

class Solution {
public:
    void IsMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));
        dp[0][0] = true;
        for(int i = 1; i <= n; ++i) {
            if (p[i - 1] == '*') {
                dp[0][i] = true;
            }
            else {
                break;
            }
        }
         for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                }
                else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        if(dp[m][n])
            cout<<"true"<<endl;
        else
            cout<<"false"<<endl;
    }
};

int main(){
    string p;
    string s;
    Solution S;
    while(cin>>p>>s)
        S.IsMatch(s,p);
    return 0;
}

【牛客】【兔子繁衍】：
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    int Rabbits(int n) {
        if (n < 1)
            return 0;
        if (n == 1 || n == 2)
            return 1;
        n -= 2;
        vector<int> dp(3, 1);
        while (n--) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
};
int main() {
    int n;
    Solution S;
    while (cin >> n)
        cout << S.Rabbits(n) << endl;
    return 0;
}

【牛客】【汽水瓶】:
#include <iostream>
using namespace std;
class Solution{
public:
    int Bottles(int n){
        int res = 0;
        while(n>2){
            int water = n/3;
            n -= water*2;
            res += water;
        }
        if(n==2)//只有2个空瓶可以借
            res += 1;
        return res;
    } 
};

int main(){
    int n;
    Solution S;
    while(cin>>n,n!=0)
        cout<<S.Bottles(n)<<endl;
    return 0;
}

【牛客】【寻找a,b两个字符串的最长公共子串】：
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

class Solution {
public:
    string FindSubStr(string& a, string& b) {
        if (a.size() > b.size())//保证a是短串
            swap(a, b);
        string str_m;//存储最长公共子串
        for (int i = 0; i < a.size(); i++){
            for (int j = i; j < a.size(); j++){
                string temp = a.substr(i, j - i + 1);
                if (int(b.find(temp)) < 0)
                    break;
                else if (str_m.size() < temp.size())
                    str_m = temp;
            }
        }
        return str_m;
    }
};
int main() {
    string s1;
    string s2;
    Solution S;
    while (cin >> s1 >> s2)
        cout << S.FindSubStr(s1, s2) << endl;
    return 0;
}

【牛客】【公共字串计算】：
#include <string>
#include <algorithm>
#include <iostream>
using namespace std;
class Solution{
public:
    int getCommonStrLength(string& shorts,string& longs){
        int szs = shorts.size();
        int szl = longs.size();
        if(szs<szl){
            swap(shorts,longs);
            swap(szs,szl);
        }
        int len = 0;
        for(int i = 0; i < szs; ++i){
            for(int j = i; j <szs - 1; ++j){
                string tmp(shorts.substr(i,j-i+1));
                if(int(longs.find(tmp)) >= 0)
                    len = len<j-i+1?j-i+1:len;
            }
        }
        return len;
    }
};

【牛客】【翻转字符串】：
#include <iostream>
#include <string>
using namespace std;

class Solution{
public:
    void Reverse(string& s){
        int sz = s.size();
        for(int i = 0;i < sz/2; ++i){
            char tmp = s[i];
            s[i] = s[sz-1-i];
            s[sz-1-i] = tmp;
        }
    }
};

int main(){
    string s;
    Solution S;
    while(cin>>s){
        S.Reverse(s);
        cout<<s<<endl;
    }
    return 0;
}

LeetCode【剑指offer59-II】【队列的最大值】：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/
class MaxQueue {
public:
    MaxQueue() {
    }
    
    int max_value() {
        if(Max.empty())
            return -1;
        return Max.front();
    }
    
    void push_back(int value) {
        Que.push(value);
        while(Max.size() && Max.back()<value)
            Max.pop_back();
        Max.push_back(value);
    }
    
    int pop_front() {
        if(Que.empty())
            return -1;
        int tmp = Que.front();
        Que.pop();
        if(tmp == Max.front())
            Max.pop_front();
        return tmp;
    }
private:
    queue<int> Que;
    deque<int> Max;
};

LeetCode【173】【二叉搜索树迭代器】：https://leetcode-cn.com/problems/binary-search-tree-iterator/
class BSTIterator {
public:
    BSTIterator(TreeNode* root):cur(root) {}
    
    int next() {//即int operator++()
        while(cur){
            st.push(cur);
            cur = cur->left;
        }
        cur = st.top();
        st.pop();
        int res = cur->val;
        cur = cur->right;
        return res;
    }
    
    bool hasNext() {
        return cur || !st.empty();
    }
private:
    TreeNode* cur;
    stack<TreeNode*> st;
};

【牛客】【MP3光标位置】：https://www.nowcoder.com/questionTerminal/eaf5b886bd6645dd9cfb5406f3753e15
#include <iostream>
#include <string>
#include <map>
using namespace std;

class Solution {
public:
    void Slide(const int& n, const string& s) {
        int sz = s.size();
        int mouse = 1, begin = 1, dk = n < 4 ? n : 4;
        for (int i = 0; i < sz; ++i) {
            if (begin == 1 && mouse == 1 && s[i] == 'U')//特殊向上翻页
                begin = n < 4 ? 1 : n - 3, mouse = n;
            else if (begin != 1 && mouse == begin && s[i] == 'U')//光标位于屏幕第一行向上翻
                --begin, --mouse;
            else if (begin == n - 3 && mouse == n && s[i] == 'D')//特殊向下翻页
                begin = mouse = 1;
            else if (begin != n - 3 && mouse == begin + 3 && s[i] == 'D')//光标位于最后一行向下翻
                ++begin, ++mouse;
            else if (s[i] == 'U')//光标位于屏幕中间，向上翻
                --mouse;
            else//光标位于屏幕中间，向下翻
                mouse = mouse==n?1:mouse+1;
        }
        for (int i = begin; i < begin + dk; ++i)
            cout << i << " ";
        cout << endl << mouse << endl;
    }
};
int main() {
    string s;
    int n;
    Solution S;
    while (cin >> n >> s)
        S.Slide(n, s);
    return 0;
}

【牛客】【洗牌】：
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void Shuffle(vector<int>& cards, const int& n, int& k) {
        vector<int> tmp(2 * n, 0);
        while (k--) {
            int idx = 0;
            for (int i = 0; i < n; ++i) {
                tmp[idx++] = cards[2 * n - i - 1];
                tmp[idx++] = cards[n - i - 1];
            }
            reverse(tmp.begin(), tmp.end());
            swap(tmp, cards);
        }
        for (int i = 0; i < 2 * n; ++i)
            if (i != 2 * n - 1)
                cout << cards[i] << " ";
            else
                cout << cards[i] << endl;
    }
};

int main() {
    int T;
    int n, k;
    cin >> T;
    Solution S;
    while (T--) {
        cin >> n >> k;
        vector<int> cards(2 * n);
        for (int i = 0; i < 2 * n; ++i)
            cin >> cards[i];
        S.Shuffle(cards, n, k);
    }
    return 0;
}

【牛客】【小易的升级之路】：
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    int Ability(int& a, const int& n, const vector<int>& monster) {
        for (int i = 0; i < n; ++i) {
            if (monster[i] <= a)
                a += monster[i];
            else
                a += GCD(a, monster[i]);
        }
        return a;
    }
private:
    int GCD(int n, int m) {
        while (n != m) {
            if (n > m)
                n -= m;
            else if (m > n)
                m -= n;
        }
        return n;
    }
};

int main() {
    int n, a;
    Solution S;
    while (cin >> n >> a) {
        vector<int> monster(n);
        for (int i = 0; i < n; ++i)
            cin >> monster[i];
        cout << S.Ability(a, n, monster) << endl;
    }
    return 0;
}

【牛客】【字符串中第一个出现一次的字符】：
#include <iostream>
#include <string>
#include <map>
using namespace std;

class Solution {
public:
    void SeekFirst(const string& s) {
        int sz = s.size();
        map<char, int> mp;
        for (auto& ss : s)
            ++mp[ss];
        int index = sz;
        for (auto& it : mp) {
            if (it.second == 1) {
                int tmp = s.find(it.first);
                index = tmp < index ? tmp : index;
            }
        }
        if (index > sz - 1)
            cout << -1 << endl;
        else
            cout << s[index] << endl;
    }
};

int main() {
    string s;
    Solution S;
    while (cin >> s)
        S.SeekFirst(s);
    return 0;
}

【牛客】【数组中出现次数超过一半的数】：
class Gift {
public:
    int getValue(vector<int> gifts, int n) {
        map<int,int> mp;
        for(auto& num:gifts)
            ++mp[num];
        for(auto& it:mp)
            if(it.second>n/2)
                return it.first;
        return 0;
    }
};

LeetCode【72】【编辑距离】：https://leetcode-cn.com/problems/edit-distance/
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        if(!(m*n))
            return m+n; 
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i = 0; i <= m; ++i)
            dp[i][0] = i;
        for(int i = 0; i <= n; ++i)
            dp[0][i] = i;
        for(int i = 1; i <= m; ++i){
            for(int j = 1; j <= n; ++j){
                int left = dp[i][j-1] + 1;
                int up = dp[i-1][j] + 1;
                int left_up = dp[i-1][j-1];
                if(word1[i-1]!=word2[j-1]) ++left_up;
                dp[i][j] = min(left,min(up,left_up));
            }
        }
        return dp[m][n];
    }
};

【牛客】【年终奖】：
class Bonus {
public:
    int getMost(vector<vector<int> > board) {
        vector<vector<int>> dp(board);
        for(int i = 1; i<6;++i){
            dp[0][i] += dp[0][i-1];
            dp[i][0] += dp[i-1][0];
        }
        for(int i = 1; i<6; ++i){
            for(int j = 1;j<6;++j){
                dp[i][j] += max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[5][5];
    }
};

【牛客】【迷宫问题】：https://www.nowcoder.com/questionTerminal/535df0770f0940f092ab77db0907e5c9
#include <iostream>
#include <vector>
#include <deque>
#include <string>
#pragma warning(disable:4996)
using namespace std;

class Solution {
public:
    void ShortPath(const vector<vector<int>>& board) {
        m = board.size();
        n = board[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        visited[0][0] = true;
        deque<string> dq;
        dq.push_back("(0,0)");
        BackTrack(board, 0, 0, dq, visited);

        while (!ans.empty()) {
            cout << ans.front() << endl;
            ans.pop_front();
        }
    }
private:
    void BackTrack(const vector<vector<int>>& board, int x, int y, deque<string>& dq, vector<vector<bool>>& vis) {
        if (x == m - 1 && y == n - 1) {
            if (ans.empty() || dq.size() < ans.size())
                ans = dq;
            return;
        }
        for (int i = 0; i < 4; ++i) {
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if (nx >= m || ny >= n || nx < 0 || ny < 0 || board[nx][ny] || vis[nx][ny])
                continue;
            vis[nx][ny] = true;
            char tmp[64] = { 0 };
            sprintf(tmp, "(%d,%d)", nx, ny);
            dq.push_back(string(tmp));
            BackTrack(board, nx, ny, dq, vis);
            dq.pop_back();
        }
    }
private:
    int m;
    int n;
    int dir[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };
    deque<string> ans;
};
int main() {
    int n, m;
    Solution S;
    while (cin >> m >> n) {
        vector<vector<int>> board(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                cin >> board[i][j];
        S.ShortPath(board);
    }
    return 0;
}

【牛客】【星际密码】：
#include <iostream>
#include <vector>
using namespace std;
vector<int> rec(10001);
class Solution {
public:
    void Pwd(const vector<int>& num, const int& n) {
        for (int i = 0; i < n; ++i) 
            printf("%04d",rec[num[i]]);
        cout << endl;
    }
};
int main() {
    rec[0] = rec[1] = 1;
    for (int i = 2; i < 10001; ++i)
        rec[i] = (rec[i - 2] + rec[i - 1]) % 10000;
    int n;
    Solution S;
    while (cin >> n) {
        vector<int> num(n);
        for (int i = 0; i < n; ++i)
            cin >> num[i];
        S.Pwd(num, n);
    }
    return 0;
}
【牛客】【数根】：
#include <iostream>
#include <string> 
using namespace std;

class Solution {
public:
    int NumRoot(string& n) {
        int sz = n.size();
        if (sz == 1)
            return n[0] - '0';
        int root = 0;
        while (n.size() != 1) {
            for (int i = 0; i < sz; ++i)
                root += (n[i] - '0');
            n = "";
            if (root > 9) {
                n = string(to_string(root));
                sz = n.size();
                root = 0;
            }
            else
                break;
        }
        return root;
    }
};
int main() {
    string n;
    Solution S;
    while (cin >> n)
        cout << S.NumRoot(n) << endl;
    return 0;
}

【牛客】【猫进碗】：
#include <iostream>
#include <string>
using namespace std;

class Solution {
public:
    void CanIn(const string& r, const string& cat) {
        string circle = BigMul(BigMul(r, "2"), "314");
        int sz = cat.size();
        int len = circle.size();
        string integar;
        for (int i = 0; i < len - 2; ++i)
            integar += circle[i];
        if (cat > integar)
            cout << "No" << endl;
        else
            cout << "Yes" << endl;
    }
private:
    string BigMul(const string& n1, const string& n2) {
        if (n1 == "0" || n2 == "0")
            return "0";
        int len1 = n1.size(), len2 = n2.size();
        string ans(len1 + len2, '0');
        for (int i = len1 - 1; i >= 0; --i) {
            for (int j = len2 - 1; j >= 0; --j) {
                int cur = (n1[i] - '0') * (n2[j] - '0') + (ans[i + j + 1] - '0');
                ans[i + j + 1] = cur % 10 + '0';
                ans[i + j] += cur / 10;
            }
        }
        if (ans[0] == '0')
            ans.erase(ans.begin());
        return ans;
    }
};

int main() {
    string r;
    string cat;
    Solution S;
    while (cin >> cat >> r)
        S.CanIn(r, cat);
    return 0;
}

【牛客】【三角形】：https://www.nowcoder.com/questionTerminal/c67a09062c0f4a5b964eef0945d3dd06
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void IsTriangle(const string& a, const string& b, const string& c) {
        if (StringAdd(a, b, c) &&
            StringAdd(a, c, b) &&
            StringAdd(b, c, a))
            cout << "Yes" << endl;
        else
            cout << "No" << endl;
    }
private:
    bool StringAdd(const string& s1, const string& s2, const string& s3) {
        string ss1(s1);
        string ss2(s2);
        int sz1 = ss1.size(), sz2 = ss2.size();
        int sz = sz1 > sz2 ? sz1 : sz2;
        reverse(ss1.begin(), ss1.end());
        reverse(ss2.begin(), ss2.end());
        int flag = 0;
        string res;
        for (int i = 0; i < sz; ++i) {
            int n1 = i >= sz1 ? 0 : (ss1[i] - '0');
            int n2 = i >= sz2 ? 0 : (ss2[i] - '0');
            int tmp = n1 + n2 + flag;
            res += (tmp % 10 + '0');
            flag = tmp / 10;
        }
        if (flag)
            res += '1';
        reverse(res.begin(), res.end());
        sz = res.size();
        if (sz == s3.size())
            return res > s3;
        return sz > s3.size();
    }
};

int main() {
    string a, b, c;
    Solution S;
    while (cin >> a >> b >> c)
        S.IsTriangle(a, b, c);
}

【牛客】【猴子分桃】：https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a
#include <iostream>
#include <cmath>
using namespace std;

class Solution {
public:
    void PeachOlder(int& N) {
        long a = pow(5, N) - 4;
        long b = pow(4, N) + N - 4;
        cout << a << " " << b << endl;
    }
};
int main() {
    int N;
    Solution S;
    while (cin >> N, N)
        S.PeachOlder(N);
    return 0;
}

【牛客】【奇数位是奇数偶数位是偶数】：
class Solution {
public:
    /**
     *  奇数位上都是奇数或者偶数位上都是偶数
     *  输入：数组arr，长度大于2
     *  len：arr的长度
     *  将arr调整成奇数位上都是奇数或者偶数位上都是偶数
     */
    void oddInOddEvenInEven(vector<int>& arr, int len) {
        int i = 0, j = 1;
        while (i < n && j < n) {
            while (i < n && ((arr[i] & 1) == 0))
                i += 2;
            while (j < n && ((arr[j] & 1) == 1))
                j += 2;
            if (i < n && j < n) {
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
    }
};

【牛客】【有假币】：
#include <iostream>
using namespace std;

class Solution{
public:
    int MinT(int& N){
        int res = 0;
        while(N>1){
            N = (N/3+ (N%3>0));
            ++res;
        }
        return res;
    }
};
int main(){
    int N;
    Solution S;
    while(cin>>N,N)
        cout<<S.MinT(N)<<endl;
    return 0;
}

【牛客】【】：
class Solution {
public:
    int getFirstUnFormedNum(vector<int> arr, int len) {
        vector<int> sum;
        //计算子集
        int top = 1 << len;
        for (int mask = 1; mask < top; ++mask) {
            int tmp = 0;
            for (int i = 0; i < len; ++i)
                if (mask & (1 << i))
                    tmp += arr[i];
            sum.push_back(tmp);
        }
        //删除重复数字
        set<int> sset(sum.begin(),sum.end());
        auto e = sset.end();
        --e;
        //计算没算出的数字
        vector<int> ans;
        for (int i = *sset.begin(); i <= *e; ++i) {
            if (sset.end() == find(sset.begin(), sset.end(), i))
                ans.push_back(i);
        }
        //取最小
        int sz = ans.size();
        if (!sz)
            return (*e + 1);
        return ans[0];
    }
};

【牛客】【因子个数】：https://www.nowcoder.com/questionTerminal/e8fb8f89f5d147ec92fd8ecfefe89b0d
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

class Solution {
public:
    int NumofFactors(int& N) {
        int idx = 0;
        int res = 0;
        while (N != 1) {
            if (N % primetable[idx] == 0)
                ++res;
            while (N % primetable[idx] == 0)
                N /= primetable[idx];
            if (primetable[++idx] > N)
                break;
        }
        return res;
    }
public:
    Solution() {
        primetable[0] = 2;
        primetable[1] = 3;
        primetable[2] = 5;
        primetable[3] = 7;
        int index = 4;
        for (int i = 11; i < 100000; i += 2) {
            if (i % 5 == 0)
                continue;
            bool flag = 1;
            for (int j = 3; j <= sqrt(i); j += 2) {
                if (i % j != 0)
                    continue;
                flag = 0;//非质数
                break;
            }
            if (flag)
                primetable[index++] = i;
        }
    }
    ~Solution(){
       delete[] primetable;
   }
private:
    int primetable[9592];
};

int main() {
    Solution S;
    int n;
    while (cin >> n)
        cout << S.NumofFactors(n) << endl;
    return 0;
}

【牛客】【最难的问题】：https://www.nowcoder.com/questionTerminal/9f6b8f6ec26d44cfb8fc8c664b0edb6b
#include <iostream>
#include <string>
#include <map>
using namespace std;

class Solution {
public:
    void Swift(string& src) {
        int sz = src.size();
        for (int i = 0; i < sz; ++i) {
            if (src[i] != ' ')
                src[i] = mp[src[i]];
        }
    }
public:
    Solution() {
        for (char c = 'Z'; c > 'E'; --c)
            mp[c] = c - 5;
        char tmp = 'Z';
        for (char c = 'E'; c >= 'A'; --c)
            mp[c] = tmp--;
    }
private:
    map<char, char> mp;
};

int main() {
    Solution S;
    string src;
    while (getline(cin,src)) {
        S.Swift(src);
        cout << src << endl;
    }
    return 0;
}

【牛客】【分解因式】：
#include <iostream>
#include <cmath>
#include <string>
using namespace std;

class Solution {
public:
    string AnalysisFactors(int& n) {
        string ans;
        ans += to_string(n);
        string tmp(" = ");
        ans += tmp;
        int idx = 0;
        tmp = " * ";
        while (n != 1) {
            while (n != 1 && (n % table[idx] == 0)) {
                ans += to_string(table[idx]);
                ans += tmp;
                n /= table[idx];
            }
            if (n < table[++idx])
                break;
        }
        auto e = ans.end();
        ans.erase(e - 3, e);
        return ans;
    }
public:
    Solution() {
        table = new int[78498];
        table[0] = 2;
        table[1] = 3;
        table[2] = 5;
        table[3] = 7;
        int idx = 4;
        for (int i = 11; i < 1000000; i += 2) {
            if (i % 5 == 0)
                continue;
            bool flag = true;
            for (int j = 3; j <= sqrt(i); j+=2) {
                if (i % j != 0)
                    continue;
                flag = false;
                break;
            }
            if (flag)
                table[idx++] = i;
        }
    }
    ~Solution() {
        delete[] table;
    }
private:
    int* table;
};

int main() {
    int n;
    Solution S;
    while (cin >> n)
        cout << S.AnalysisFactors(n) << endl;
    return 0;
}

【牛客】【美国节日】：https://www.nowcoder.com/questionTerminal/d95d98a2f96e49078cd7df84ba0c9d79
#include <iostream>
#include <string>
#include <vector>
#pragma warning(disable:4996)
using namespace std;

class Solution {
public:
    void Festival(const int& year) {
        vector<string> ans(8);
        Compute(ans, year);
        for (int i = 0; i < 8; ++i)
            cout << ans[i] << endl;
        cout << endl;
    }
private:
    void Compute(vector<string>& ans, const int& year) {
        NoCompute(ans, year);
        string tmp;
        char dates[15] = { 0 };

        int day = 1;
        int w = Week(year - 1, 13);
        if (w == 0 || w == 1)
            day = 2 - w;
        else
            day += (8 - w);
        sprintf(dates, "%02d-%02d", 1, day + 14);
        tmp = string(dates);
        ans[1] += tmp;

        day = 1;
        w = Week(year - 1, 14);
        if (w == 0 || w == 1)
            day = 2 - w;
        else
            day += (8 - w);
        sprintf(dates, "%02d-%02d", 2, day + 14);
        tmp = string(dates);
        ans[2] += tmp;

        day = 31;
        w = Week(year, 5, 31);
        if (w == 1)
            day = 31;
        else if (w == 0)
            day = 25;
        else
            day -= (w - 1);
        sprintf(dates, "%02d-%02d", 5, day);
        tmp = string(dates);
        ans[3] += tmp;

        day = 1;
        w = Week(year, 9);
        if (w == 0 || w == 1)
            day += 1 - w;
        else
            day += (8 - w);
        sprintf(dates, "%02d-%02d", 9, day);
        tmp = string(dates);
        ans[5] += tmp;

        day = 1;
        w = Week(year, 11);
        if (w > 4)
            day += (11 - w);
        else
            day += (4 - w);
        sprintf(dates, "%02d-%02d", 11, day + 21);
        tmp = string(dates);
        ans[6] += tmp;
    }
    void NoCompute(vector<string>& ans, const int& year) {
        string tmp(to_string(year));
        tmp += '-';
        for (int i = 0; i < 8; ++i)
            ans[i] = tmp;
        ans[0] += "01-01";
        ans[4] += "07-04";
        ans[7] += "12-25";
    }
    int Week(const int& year, const int& month, const int& day = 1) {
        int c = year / 100, y = year % 100, d = day, m = month;
        int w = (c / 4 - 2 * c + y + y / 4 + 13 * (m + 1) / 5 + d - 1) % 7;
        return (w + 7) % 7;
    }
};
int main() {
    int year;
    Solution S;
    while (cin >> year)
        S.Festival(year);
    return 0;
}

【牛客】【斐波那契凤尾】：https://www.nowcoder.com/questionTerminal/c0a4b917a15f40a49ca10532ab9019fb
#include <iostream>
#include <string>
#define TOP 1000000
using namespace std;

class Solution{
public:
    void NFaccnoi(const int& N){
        string ans(to_string(table[N]));
        int sz = ans.size();
        if(N>=29 && sz!=6){
            int n = 6-sz;
            while(n--)
                ans.insert(ans.begin(),'0');
        }
        cout<<ans<<endl;
    }
public:
    Solution(){
        table = new int[100001];
        table[0] = 1;
        table[1] = 1;
        for(int i = 2; i < 100001; ++i)
            table[i] = (table[i-1]+table[i-2])%TOP;
    }
    ~Solution(){
        delete table;
    }
private:
    int* table;
};

int main(){
    int n;
    Solution S;
    while(cin>>n)
        S.NFaccnoi(n);
    return 0;
}

【牛客】【淘宝网店】：https://www.nowcoder.com/questionTerminal/754921e9c98b43d1b2d70c227b844101
#include <iostream>
using namespace std;

class Solution{
public:
    long Profit(const int& y1,const int& m1,const int& d1,
                const int& y2,const int& m2,const int& d2){
        long res = 0; 
        bool leapyear;
        //中间有年份则计算中间年份 
        for(int i = y1+1;i <= y2-1;++i){
            leapyear = IsLeapYear(i);
            if(leapyear)
                res += 580;
            else
                res += 579;
        }
        if(y1==y2 && m1 == m2){//同年同月
            res += (d2-d1+1);
            if(!Prime[m1])
                res *= 2;
            return res;
        }
        //同年 or 跨年不同月
        //第一个月
        leapyear = IsLeapYear(y1);
        if(m1==2 && leapyear)
            res += days[0]-d1+1;
        else if(Prime[m1])
            res += days[m1]-d1+1;
        else
            res += (days[m1]-d1+1)*2;
        //第一年m1月后的其余月份
        for(int i = m1+1; i <= 12; ++i){
            if(i == 2 && leapyear)
                res += days[0];
            else if(Prime[i])
                res += days[i];
            else
                res += days[i]*2;
        }
        //最后一月
        if(Prime[m2])
            res += d2;
        else
            res += d2*2;
        if(y1 != y2){//不同年
            leapyear = IsLeapYear(y2);
            //m2之前的同年月份
            for(int i = 1; i < m2; ++i){
                if(leapyear && i == 2)
                    res += days[0];
                else if(Prime[i])
                    res += days[i];
                else
                    res += days[i]*2;
            }
        }
       return res;
    }
    ~Solution(){
       delete[] days;
       delete[] Prime;
     }
private:
    bool IsLeapYear(const int& year){
        if(year%400==0)
            return true;
        if(year%4==0 && year%100)
            return true;
        return false;
    }
private:
    int days[13] = {29,31,28,31,30,31,30,31,31,30,31,30,31};
    bool Prime[13] = {1,0,1,1,0,1,0,1,0,0,0,1,0};
};

int main(){
    int y1,y2,m1,m2,d1,d2;
    Solution S;
    while(cin>>y1>>m1>>d1>>y2>>m2>>d2)
        cout<<S.Profit(y1,m1,d1,y2,m2,d2)<<endl;
    return 0;
}

【牛客】客似云来】：https://www.nowcoder.com/questionTerminal/3549ff22ae2c4da4890e9ad0ccb6150d
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    long long Number(const int& d1, const int& d2) {
        if (d1 == d2)
            return tabeln[d1 - 1];
        if (1 == d1)
            return tabels[d2 - 1];
        return tabels[d2 - 1] - tabels[d1 - 2];
    }
public:
    Solution():tabeln(80),tabels(80) {
        tabeln[0] = tabels[0] = 1;
        tabeln[1] = 1, tabels[1] = 2;
        for (int i = 2; i < 80; ++i) {
            tabeln[i] = tabeln[i - 1] + tabeln[i - 2];
            tabels[i] = tabeln[i] + tabels[i - 1];
        }
    }
private:
    vector<long long> tabeln;//第n天的数目
    vector<long long> tabels;//第一天到第n天的总数
};

int main() {
    Solution S;
    int d1, d2;
    while (cin >> d1 >> d2)
        cout << S.Number(d1, d2) << endl;
    return 0;
}

【牛客】【剪花布条】：https://www.nowcoder.com/questionTerminal/1046cd038f7a4b04b2b77b415973de1c
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

class Solution{
public:
    int Number(const string& sample,const string& target){
        size_t pos = 0;
        int cnt = 0;
        size_t ed = string::npos;
        int sz = target.size();
        while((pos=sample.find(target,pos)) != ed){
            ++cnt;
            pos += sz;
        }
        return cnt;
    }
};

int main(){
    Solution S;
    string s;
    string t;
    while(cin>>s>>t)
        cout<<S.Number(s, t)<<endl;
    return 0;
}

【牛客】【收件人列表】：
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    string Name(vector<string>& v, const int& N) {
        string ans;
        for (int i = 0; i < N; ++i) {
            bool exist = (v[i].find(',',0) != string::npos) || (v[i].find( ' ',0) != string::npos);
            exert(ans, v[i], exist);
        }
        auto e = ans.end();
        e -= 2;
        ans.erase(e, ans.end());
        return ans;
    }
private:
    void exert(string& ans, string& s, bool exist) {
        if (exist) {
            s.insert(s.begin(), '"');
            s.insert(s.end(), '"');
        }
        ans += s;
        ans += ", ";
    }
};

int main() {
    int n;
    Solution S;
    while (cin >> n) {
        vector<string> v(n);
        getchar();
        for (int i = 0; i < n; ++i) 
            getline(cin, v[i]);
        cout << S.Name(v, n) << endl;
    }
    return 0;
}

【牛客】【养兔子】：
#include <iostream>
#include <vector>
using namespace std;

class Solution{
public:
    long long FacN(const int& N){
        return table[N-1];
    }
    Solution():table(90){
        table[0] = 1;
        table[1] = 2;
        for(int i = 2; i < 90; ++i)
            table[i] = table[i-1] + table[i-2];
    }
private:
   vector<long long> table;
};

int main(){
    int n;
    Solution S;
    while(cin>>n)
        cout<<S.FacN(n)<<endl;
    return 0;
}

【牛客】【抄送列表】：
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    string IsExist(const string& sample, const string& tar) {
        vector<string> v;
        Split(sample, v);
        int sz = v.size();
        for (int i = 0; i < sz; ++i)
            if (v[i] == tar)
                return string("Ignore");
        return string("Important!");
    }
private:
    void Split(const string& sam, vector<string>& v) {
        int left = 0, right = 0;
        int sz = sam.size();
        while (left < sz) {
            if (sam[left] == '"') {
                ++left;
                right = sam.find('"', left + 1);
                v.push_back(sam.substr(left, right - left));
            }
            else {
                right = sam.find(',', left + 1);
                if (right == string::npos)
                    right = sz;
                v.push_back(sam.substr(left, right - left));
            }
            if (sam[right] == '"')
                left = right + 2;
            else
                left = right + 1;
        }
    }
};

int main() {
    string sam;
    string tar;
    Solution S;
    while (getline(cin, sam), getline(cin, tar))
        cout << S.IsExist(sam, tar) << endl;
    return 0;
}

【牛客】【年会抽奖】：
#include <iostream>
#include <iomanip>
#include <vector>
using namespace std;

class Solution {
public:
    void Possiblity(const int& n) {
        double ans;
        ans = son[n - 1] / (double)par[n - 1];
        ans *= 100;
        cout << fixed << setprecision(2) << ans << "%" << endl;
    }
    Solution() :par(20), son(20) {
        son[0] = 0;
        son[1] = 1;
        for (int i = 2; i < 20; ++i)
            son[i] = i * (son[i - 1] + son[i - 2]);
        par[0] = 1;
        par[1] = 2;
        for (int i = 2; i < 20; ++i)
            par[i] = (i + 1) * par[i - 1];
    }
private:
    vector<long long> par;
    vector<long long> son;
};
int main() {
    int n;
    Solution S;
    while (cin >> n)
        S.Possiblity(n);
    return 0;
}

【牛客】【Pre-Post】:
#include <iostream>
#include <string>
#include <map>
using namespace std;

class Solution {
public:
    int KindsofMTree(const int& n,const string& pr, const string& po) {
        m = n;
        ans = 1;
        pre = pr;
        post = po;
        int sz = pr.size();
        for (int i = 0; i < sz; ++i)
            mp[post[i]] = i;
        Creat(0, sz - 1, 0, sz - 1);
        return ans;
    }
private:
    void Creat(int preS, int preE, int postS, int postE) {
        if (preS >= preE)
            return;
        int i = preS + 1, cnt = 0;//cnt统计子树的个数,i是标识当前树的根节点的子树的根节点，在pre中的下标
        int idx = mp[pre[i]];
        while (i <= preE) {
            Creat(i, i + idx - postS, postS, idx);
            ++cnt;
            if (idx != postE - 1) {//子树不止一个,把要递归搜索的树的区间整体移动=
                i += idx - postS + 1;   //idx-postS是刚刚递归过的子树的大小
                                  //i要跨过这个区间，找到下一个要搜索的根节点
                postS = idx + 1;    //post的区间起始位置也要前进1位
                idx = mp[pre[i]];//idx重新定位下一个要搜索的子树根节点在post中的下标
            }
            else
                break;//完成对当前区间中所有字数根节点的全部搜索
        }
        ans *= Cmk(m, cnt);//计算排列组合，cnt表示当前层有几个子树
    }
    int Cmk(int m, const int& k) {
        int numerator = 1, denominator = 1;
        for (int i = 0; i < k; i++, --m)
            numerator *= m;
        for (int i = 1; i <= k; ++i)
            denominator *= i;
        return numerator / denominator;
    }
private:
    int ans;
    map<char, int> mp;
    string pre;
    string post;
    int m;
};

int main() {
    string pre;
    string post;
    int n;
    Solution S;
    while (cin >> n, cin >> pre, cin >> post)
        cout << S.KindsofMTree(n,pre, post) << endl;
    return 0;
}

【牛客】【Rational Arithmetic】：https://www.nowcoder.com/questionTerminal/b388bdee5e3e4b1c86a79ad1877a3aa4?toCommentId=9495842&ran=103
#include <iostream>
#include <string>
#include <vector>
#include <cmath>
using namespace std;
class Solution {
public:
    //对外接口
	void Calculate(vector<string>& n) {
		//划分数据
		int index = 0, idx = 0;
		Split(n[0], index, idx);
		idx = 0;
		Split(n[1], index, idx);
        //为避免两有理数被多次计算字符串，此处进行计算
        Head(num[0], num[1], n1);
        Head(num[2], num[3], n2);
		// +
		int s = num[0] * num[3] + num[2] * num[1];
		int p = num[1] * num[3];
		Show(s, p, '+');
		// -
		s = num[0] * num[3] - num[2] * num[1];
		Show(s, p, '-');
		// *
		s = num[0] * num[2];
		p = num[1] * num[3];
		Show(s, p, '*');
		// /
		s = num[0] * num[3];
		p = num[1] * num[2];
		if (p < 0 && s>0)//若分母为负数，交换负号
			s *= -1, p *= -1;
		Show(s, p, '/');
	}
	Solution() :num(4) {}
private:
    //更相减损术
	int GDC(int m1, int m2) {
		m1 *= m1 < 0 ? -1 : 1;
		m2 *= m2 < 0 ? -1 : 1;
		while (m1 != m2) {
			if (m1 > m2)
				m1 -= m2;
			else if (m1 < m2)
				m2 -= m1;
			else
				return m1;
		}
		return m1;
	}
    //格式控制及输出
	void Show(const int& s, const int& p, const char& sys) {
		string head;
        //拼接第一个有理数
		head += n1;
		head += ' ';
		head += sys;
		head += ' ';
        //拼接第二个有理数
		head += n2;
		head += " = ";
        //拼接结果
		if (!p)
			head += "Inf";
		else if (!s)
			head += '0';
		else
			Head(s, p, head);
		cout << head << endl;
	}
    //输出字符串拼接
	void Head(const int& s, const int& p, string& head) {
		if (s == 0) {
			head += '0';
		}
		else if (abs(s) > p) {//存在整数部分
			bool flag = s < 0;//负数为真
			if (flag)
				head += "(-";
			head += to_string(abs(s / p));//整数部分
			if (s/p*p != s) {//存在小数部分
				head += ' ';
				 CalFraction(s,p,head);
			}
			if (flag)
				head += ")";
		}
		else if (s == p)
			head += '1';
		else {//不存在整数部分
			bool flag = s < 0;//负数为真
			if (flag)
		    head += "(-";
            CalFraction(s,p,head);
			if (flag)
				head += ")";
		}
	}
    //计算分数部分
    void CalFraction(const int& s,const int& p,string& head){
        int fac = GDC(abs(s) % p, p);//最大公因数
		head += to_string((abs(s) - abs(s) / p * p) / fac);
		head += '/';
		head += to_string(p / fac);
    }
    //数字切割
	void Split(string& n,int& index,int& idx) {
		int sys = n[0] == '-' ? -1 : 1;//正负判断
		idx += sys == -1 ? 1 : 0;//确定因符号引起的偏移
		int pos = n.find('/', idx);//找出完整数字
		for (int j = idx; j < pos; ++j)
			num[index] = num[index] * 10 + (n[j] - '0');
		num[index++] *= sys;
		idx = pos + 1;
		pos = n.size();
		for (int j = idx; j < pos; ++j)
			num[index] = num[index] * 10 + (n[j] - '0');
		++index;
	}
private:
	vector<int> num;//[a1,b1,a2,b2]
    string n1;//数1的输出格式
    string n2;//数2的输出格式
};

int main() {
	Solution S;
	vector<string> n(2);
	while (cin >> n[0] >> n[1])
		S.Calculate(n);
}

【牛客】【mkdir】：https://www.nowcoder.com/questionTerminal/433c0c6a1e604a4795291d9cd7a60c7a
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

bool comp(const string& s1, const string& s2) {
    return s1 < s2;
}
class Solution {
public:
    void Mkdir(vector<string>& path, const int& n) {
        sort(path.begin(), path.end(), comp);
        for (int i = 1; i < n; ++i) {
            int pos = path[i].find(path[i - 1], 0);
            if (pos != string::npos && path[i][pos + path[i - 1].size()] == '/')
                path[i - 1] = "";
        }
        auto it = path.begin();
        while (it != path.end()) {
            it = find(it, path.end(), "");
            if (it != path.end())
                it = path.erase(it);  
        }
        int sz = path.size();
        for (int i = 0; i < sz; ++i)
            cout << string(head + path[i]) << endl;
        cout << endl;
    }
    Solution():head("mkdir -p ") {}
private:
    string head;
};

int main() {
    Solution S;
    int n;
    while (cin >> n) {
        getchar();
        vector<string> path(n);
        for (int i = 0; i < n; ++i)
            getline(cin, path[i]);
        S.Mkdir(path, n);
    }
    return 0;
}

【牛客】【最大连接数量】：
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

class Solution {
public:
    int MaxConnect(const vector<string>& req) {
        int res = 0;
        int sz = req.size();
        string q;
        for (int i = 0; i < sz; ++i) {
            if (req[i][2] == 'c')
                q += req[i][0];
            else
                q.erase(find(q.begin(), q.end(), req[i][0]));
            res = res < q.size() ? q.size() : res;
        }
        return res;
    }
};
int main() {
    Solution S;
    int n;
    while (cin >> n) {
        getchar();
        vector<string> v(n);
        for (int i = 0; i < n; ++i)
            getline(cin, v[i]);
        cout << S.MaxConnect(v) << endl;
    }
    return 0;
}

【牛客】【蘑菇阵】：
#include <vector>
#include <iostream>
#include <iomanip>
using namespace std;

class Solution {
public:
    double Possibility(vector<vector<int>>& board) {
        int n = board.size();
        int m = board[0].size();
        vector<vector<double>> dp(n+1, vector<double>(m+1, 0.0));
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if(i == 1 && j == 1) {dp[i][j] = 1; continue;}
                if(!board[i-1][j-1]) {dp[i][j] = 0; continue;}
                if(i == n && j == m) {dp[i][j] = dp[i-1][j] + dp[i][j-1]; continue;}
                if(i == n) {dp[i][j] = dp[i-1][j]*0.5 + dp[i][j-1]; continue;}
                if(j == m) {dp[i][j] = dp[i-1][j] + dp[i][j-1]*0.5; continue;}
                if(i == 1) {dp[i][j] = dp[i][j-1]*0.5; continue;}
                if(j == 1) {dp[i][j] = dp[i-1][j]*0.5; continue;}
                dp[i][j] = dp[i][j-1]*0.5 + dp[i-1][j]*0.5;
            }
        }
        return dp[n][m];
    }
};

int main() {
    Solution S;
    int n, m, k;
    int x, y;
    while (cin >> n >> m >> k) {
        vector<vector<int>> board(n, vector<int>(m, 1));
        for (int i = 0; i < k; ++i) {
            cin >> x >> y;
            board[x - 1][y - 1] = 0;
        }
        cout << fixed << setprecision(2) << S.Possibility(board) << endl;
    }
}

【牛客】【红与黑】：
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    int Bricks(const vector<string>& board, const int& wid, const int& len) {
        m = wid, n = len;
        cnt = 1;
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        int x, y;
        bool flag = true;
        for (x = 0; x < m; ++x) {
            for (y = 0; y < n; ++y) {
                if (board[x][y] == '@') {
                    visited[x][y] = true;
                    flag = false;
                    break;
                }
            }
            if (!flag)
                break;
        }
        DFS(board, visited, x, y);
        return cnt;
    }
private:
    void DFS(const vector<string>& board, vector<vector<bool>>& visited, int x, int y) {
        for (int i = 0; i < 4; ++i) {
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if (nx >= m || nx < 0 || ny >= n || ny < 0 ||
                visited[nx][ny] || board[nx][ny] == '#')
                continue;
            visited[nx][ny] = true;
            ++cnt;
            DFS(board, visited, nx, ny);
        }
    }
private:
    int m;
    int n;
    int cnt;
    int dir[4][2] = { {1,0},{0,1},{-1,0},{0,-1} };
};

int main() {
    Solution S;
    int m, n;
    while (cin >> m >> n) {
        getchar();
        vector<string> board(m);
        for (int i = 0; i < m; ++i)
            getline(cin, board[i]);
        cout << S.Bricks(board, m, n) << endl;
    }
    return 0;
}

【牛客】【最长公共子序列】：https://www.nowcoder.com/questionTerminal/9ae56e5bdf4f480387df781671db5172
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Solution{
public:
    int MaxLen(const string& A,const string& B){
        int sz1 = A.size();
        int sz2 = B.size();
        vector<vector<int>> dp(sz1,vector<int>(sz2,0));
        dp[0][0] = A[0]==B[0]?1:0;
        for(int i=1; i<sz1; i++) {
            dp[i][0] = (A[i] == B[0]) ? 1 : 0;
            dp[i][0] = max(dp[i-1][0], dp[i][0]);
        }
        for(int j=1; j<sz2; j++) {
            dp[0][j] = (A[0] == B[j]) ? 1 : 0;
            dp[0][j] = max(dp[0][j-1], dp[0][j]);
        }
        // 计算
        for(int i=1; i<sz1; i++) {
            for(int j=1; j<sz2; j++) {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                if(A[i] == B[j]) {
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);
                }
            }
        }
        return dp[sz1-1][sz2-1];
    }
};

int main(){
    Solution S;
    string s1;
    string s2;
    while(cin>>s1>>s2)
        cout<<S.MaxLen(s1, s2)<<endl;
    return 0;
}

【牛客】【字符串计数】：
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Solution{
public:
    int Number(const vector<string>& s,const vector<int>& l){
        vector<int> dp(l[1]+1);
        int ans = 0;
        for(int i = 1; i <= l[1]; ++i){
            dp[i] = (26*(dp[i-1]))%1000007;
            if(i<=s[0].size()) dp[i] -= s[0][i-1];
            if(i<=s[1].size()) dp[i] += s[1][i-1];
            if(i == s[1].size()) dp[i]--;
            if(i>=l[0]) ans += dp[i];
        }
        return ans%1000007;
    }
};

int main(){
    Solution S;
    vector<string> s(2);
    vector<int> l(2);
    while(cin>>s[0]>>s[1]>>l[0]>>l[1])
        cout<<S.Number(s,l)<<endl;
    return 0;
}

【牛客】【发邮件】：
#include <iostream>
#include <vector>
using namespace std;

class Solution{
public:
    long long Number(const int& n){
        vector<long long> dp(n+1,0);
        dp[2] = 1;
        for(int i = 3; i <= n; ++i)
            dp[i] = (i-1)*(dp[i-1]+dp[i-2]);
        return dp[n];
    }
};

int main(){
    Solution S;
    int n;
    while(cin>>n)
        cout<<S.Number(n)<<endl;
    return 0;
}

【牛客】【最长上升子序列】：
#include <vector>
#include <iostream>
using namespace std;

class Solution{
public:
    int MaxLen(const int& n,const vector<int>& v){
        int ans = 1;
        vector<int> dp(n,1);
        for(int i = 1; i < n; ++i){
            for(int j = 0; j < i; ++j)
                if(v[i]>v[j])
                    dp[i] = max(dp[i],dp[j]+1);
            ans = max(ans,dp[i]);
        }
        return ans;
    }
};

int main(){
    Solution S;
    int n;
    while(cin>>n){
        vector<int> v(n);
        for(int i = 0; i<n; ++i)
            cin>>v[i];
        cout<<S.MaxLen(n, v)<<endl;
    }
    return 0;
}

【牛客】【逆波兰表达式】：
#include <iostream>
#include <stack>
#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    int Cal(const int& n, const vector<string>& v) {
        stack<int> st;
        st.push(Str2Num(v[0]));
        st.push(Str2Num(v[1]));
        int idx = 2;
        while (idx < n) {
            if (v[idx] == "*" || v[idx] == "/" || v[idx] == "+" || v[idx] == "-") {
                int n1 = st.top(); st.pop();
                int n2 = st.top(); st.pop();
                st.push(CalC(n1, n2, v[idx]));
            }
            else
                st.push(Str2Num(v[idx]));
            ++idx;
        }
        return st.top();
    }
private:
    int CalC(const int& n1, const int& n2, const string& s) {
        if (s == "*")
            return n1 * n2;
        if (s == "+")
            return n1 + n2;
        if (s == "-")
            return n2 - n1;
        if (s == "/")
            return n2 / n1;
    }
    int Str2Num(const string& s) {
        int ans = 0;
        int sz = s.size();
        for (int i = 0; i < sz; ++i)
            ans = ans * 10 + (s[i] - '0');
        return ans;
    }
};

int main() {
    Solution S;
    int n;
    while (cin >> n) {
        vector<string> v(n);
        for (int i = 0; i < n; ++i)
            cin >> v[i];
        cout << S.Cal(n, v) << endl;
    }
    return 0;
}

【牛客】【五子棋】：
#include <string>
#include <vector>
#include <iostream>
using namespace std;

class Solution{
public:
    void Exist(const vector<string>& b){
        if(helper(b))
            cout<<"Yes"<<endl;
        else
            cout<<"No"<<endl;
    }
private:
    bool helper(const vector<string>& map){
for (int i = 0; i < 20; i ++ ) {
            for (int j = 0; j < 20; j ++ ) {
                if(map[i][j] == '*' || map[i][j] == '+') {
                    for (int k = 0; k < 4; k ++ ) {
                        int count = 1;
                        int x = i + dir[k][0];
                        int y = j + dir[k][1];
                        while (x >= 0 && x < 20 && y >= 0 && y < 20 && map[x][y] == map[i][j]) {
                            count ++ ;
                            x += dir[k][0];
                            y += dir[k][1];
                        }
                        if(count == 5) return true;
                    }
                }
            }
        }
        return false;
    }
private:
    //(x,y)——下，右，右下，左下
    int dir[4][2] = {{1,0},{0,1},{1,1},{1,-1}};
};

int main(){
    Solution S;
    vector<string> b(20);
    while(getline(cin, b[0])){
        for(int i = 1; i < 20; ++i)
            getline(cin,b[i]);
        S.Exist(b);
    }
    return 0; 
}

【牛客】【解读密码】：
#include <iostream>
#include <string>
using namespace std;

class Solution{
public:
    string Number(const string& s){
        int sz = s.size();
        string ans;
        for(int i = 0; i < sz; ++i)
            if(s[i]>='0' && s[i]<='9')
                ans += s[i];
        return ans;
    }
};

int main(){
    string in;
    Solution S;
    while(getline(cin,in))
        cout<<S.Number(in)<<endl;
    return 0;
}

【牛客】【走迷宫】：
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    void MinStep(const vector<string>& board,vector<vector<int>>& len,int x,int y) {
        if(x < 1 || y < 1 || x > 8 || y > 8 || board[x][y] == '#')
            return;
        int MIN = min(min(len[x - 1][y], len[x + 1][y]), min(len[x][y - 1], len[x][y + 1])) + 1;
        if(MIN < len[x][y])
            len[x][y] = MIN;
        else
            return;
        MinStep(board, len, x - 1, y);
        MinStep(board, len, x + 1, y);
        MinStep(board, len, x, y - 1);
        MinStep(board, len, x, y + 1);
    }

};

int main() {
    Solution S;
    vector<string> board(10);
    while (getline(cin, board[0])) {
        for (int i = 1; i < 10; ++i)
            getline(cin, board[i]);
        vector<vector<int>> len(10,vector<int>(10,101));
        len[0][1] = 0;
        S.MinStep(board,len,1,1);
        cout<<len[8][8]+1<<endl;
    }
    return 0;
}

【牛客】【求和】：
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    void ShowPro(const int& x, const int& y) {
        n = x, m = y;
        vector<int> seq;
        BackTrack(0, 1, seq);
    }
private:
    void BackTrack(int sum, int start, vector<int>& seq) {
        if (sum == m) {
            int sz = seq.size();
            for (auto& e : seq)
                cout << e << " ";
            cout << endl;
        }
        for (int i = start; i < n; ++i) {
            if (sum + i > m)
                return;
            seq.push_back(i);
            BackTrack(sum + i, i + 1, seq);
            seq.pop_back();
        }
    }
private:
    int n;
    int m;
};

int main() {
    Solution S;
    int n, m;
    while (cin >> n >> m)
        S.ShowPro(n, m);
    return 0;
}

【牛客】【电话号码】：
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;

class Solution {
public:
    void Tel(vector<string>& tel, const int& n) {
        Handle(tel, n);
        Swift(tel, n);
        sort(tel.begin(), tel.end(), comp);
        DelCom(tel, n);
        int sz = tel.size();
        for (int i = 0; i < sz; ++i)
            cout << tel[i] << endl;
        cout<<endl;
    }
    Solution() :sym("22233344455566677778889999") {}
private:
    void DelCom(vector<string>& tel, const int& n) {
        set<string> st(tel.begin(), tel.end());
        tel.clear();
        for (auto& e : st)
            tel.push_back(e);
    }
    void Handle(vector<string>& tel, const int& n) {
        for (int i = 0; i < n; ++i) {
            auto it = tel[i].begin();
            while (it != tel[i].end()) {
                it = find(it, tel[i].end(), '-');
                if (it != tel[i].end())
                    it = tel[i].erase(it);
                else
                    break;
            }
        }
    }
    void Swift(vector<string>& tel, const int& n) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 7; ++j) {
                if (tel[i][j] >= '0' && tel[i][j] <= '9')
                    continue;
                tel[i][j] = sym[tel[i][j] - 'A'];
            }
        }
        for (int i = 0; i < n; ++i)
            tel[i].insert(3, "-");
    }
private:
    string sym;
private:
    static bool comp(const string& s1, const string& s2) {
        return s1 < s2;
    }
};

int main() {
    Solution S;
    int n;
    while (cin >> n) {
        getchar();
        vector<string> tel(n);
        for (int i = 0; i < n; ++i)
            getline(cin, tel[i]);
        S.Tel(tel, n);
    }
}

【牛客】【骆驼命名法】：
#include <string>
#include <iostream>
#include <algorithm>
using namespace std;

class Solution {
public:
    void Swift(string& str) {
        auto it = find(str.begin(), str.end(), '_');
        while (it != str.end()) {
            ++it;
            *it -= 32;
            it = find(it+1, str.end(), '_');
        }
        it = find(str.begin(), str.end(), '_');
        while (it != str.end()) {
            it = str.erase(it);
            if (it != str.end())
                it = find(str.begin(), str.end(), '_');
        }
    }
};

int main() {
    Solution S;
    string tmp;
    while (cin >> tmp) {
        S.Swift(tmp);
        cout << tmp << endl;
    }
    return 0;
}

【牛客】【单词翻转】：
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    void Rerverse(string& str) {
        Split(str);
    }
private:
    void Split(string& str) {
        vector<string> v;
        string tmp;
        int sz = str.size();
        for (int i = 0; i < sz; ++i) {
            while(i<sz && isalpha(str[i])) 
                tmp += str[i++];
            v.push_back(tmp);
            tmp.clear();
            if(i<sz)
                ++i;
            while (i<sz && !isalpha(str[i])) { ++i; }
            i -= 1;
        }
        sz = v.size();
        str.clear();
        for (int i = sz - 1; i >= 0; --i) {
            str += v[i];
            if (i)
                str += " ";
        }
    }
};

int main() {
    Solution S;
    string str;
    while (getline(cin, str)) {
        S.Rerverse(str);
        cout << str << endl;
    }
    return 0;
}

【牛客】【乒乓球筐】：
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
using namespace std;

class Solution{
public:
    void Exist(const string& s1,const string& s2){
        map<char,int> mp1;
        map<char,int> mp2;
        int sz1 = s1.size();
        int sz2 = s2.size();
        for(int i = 0; i < sz1; ++i)
            ++mp1[s1[i]];
        for(int i = 0; i < sz2; ++i)
            ++mp2[s2[i]];
        for(auto& e:mp2){
            if(!mp1[e.first] || mp1[e.first] < e.second){
                cout<<"No"<<endl;
                return;
            }
        }
        cout<<"Yes"<<endl;
    }
};

int main(){
    Solution S;
    string s1;
    string s2;
    while(cin>>s1>>s2)
        S.Exist(s1, s2);
    return 0;
}

【牛客】【查找兄弟单词】：
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

class Solution {
public:
    void NumofBro(const vector<string>& dict, const string& word, const int& k) {
        int res = 0;
        vector<string> ans;
        for (auto& e: dict){//在词典中找兄弟
            if (IsBro(e,word)) {
                ++res;
                ans.push_back(e);
            }
        }
        sort(ans.begin(), ans.end(), comp);
        cout << res << endl;
        if (k <= res)
            cout << ans[k - 1] << endl;
    }
private:
    bool IsBro(string s1,string s2){
        if(s1 == s2)
            return false;
        sort(s1.begin(),s1.end());
        sort(s2.begin(),s2.end());
        return s1==s2;
    }
    static bool comp(const string& s1,const string& s2){
        return s1<s2;
    }
};
int main() {
    Solution S;
    string word;
    int n, k;
    while (cin >> n) {
        vector<string> dict(n);
        for (int i = 0; i < n; ++i)
            cin >> dict[i];
        cin >> word >> k;
        S.NumofBro(dict, word, k);
    }
    return 0;
}

【牛客】【数组中出现次数超过一半的数字】：
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        int x;
        int flag = 0;
        int sz = numbers.size();
        for(int i = 0; i < sz; ++i){
            x = flag==0?numbers[i]:x;
            flag += numbers[i]==x?1:-1;
        }
        return x;
    }
};

【牛客】【简单错误记录】：
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

struct error_codes{
    string filename;
    int codeline;
    int counter=1;
    bool operator==(const error_codes &a){
        if(a.filename==filename&&a.codeline==codeline){
            return true;
        }else{
            return false;
        }
    }
};

string getfilename(string &path);

int main(){
    vector<error_codes> arr;
    string path;
    int codeline;
    while(cin>>path>>codeline){
    	error_codes temp;
        temp.filename=getfilename(path);
        temp.codeline=codeline;
        vector<error_codes>::iterator res;
        res=find(arr.begin(),arr.end(),temp);
        if(res==arr.end()){
            arr.push_back(temp);
        }else{
            res->counter++;
        }
    }
    int j=0;
    if(arr.size()>8){
        j=arr.size()-8;
    }
    for(;j<arr.size();j++){
        cout<<arr[j].filename<<" "<<arr[j].codeline<<" "<<arr[j].counter<<endl;
    }
    return 0;
}

string getfilename(string &path){
    int pos;
    string result;
    pos=path.rfind('\\');
    result=path.substr(pos+1,path.size()-pos);
    if(result.length()>16){
        result=result.substr(result.length()-16,16);
    }
    return result;
}

【牛客】【马戏团】：
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Per {
public:
    int h;
    int w;
    int nu;
    bool operator<(const Per& p) {
        if (w != p.w)//按体重升序排
            return w<=p.w;
        return h > p.h;//体重相同，按身高降序
    }
};

class Solution {
public:
    int Height(vector<Per>& v) {
        sort(v.begin(), v.end());
        int sz = v.size();
        vector<int> dp(sz, 1);
        int max = -1;
        for (int i = 0; i < sz; i++) {
            for (int j = 0; j < i; j++) 
                if (dp[j] + 1 > dp[i] && v[i].h >= v[j].h)
                    dp[i] = dp[j] + 1;
            if (dp[i] > max) max = dp[i];
        }
        return max;
    }
};

int main() {
    Solution S;
    int N;
    while (cin >> N) {
        vector<Per> v(N);
        for (int i = 0; i < N; ++i) 
            cin >> v[i].nu >> v[i].w >> v[i].h;
        cout << S.Height(v) << endl;
    }
    return 0;
}

【牛客】【合唱团】：
#include <iostream>
#include <vector>
#include <cmath>
#include <limits.h>         
using namespace std;

class Solution {
public:
    long long Cap(vector<int>& v, const int& n, const int& k, const int& d) {
        vector<vector<long long>> maxMul(n, vector<long long>(k + 1, 0));
        vector<vector<long long>> minMul(n, vector<long long>(k + 1, 0));
        for (int i = 0; i < n; i++){
            maxMul[i][1] = v[i];
            minMul[i][1] = v[i];
        }
        for (int i = 2; i <= k; i++){
            for (int j = 0; j <n; j++){
                for (int m = 1; m <=d&&j >= m; m++){
                    maxMul[j][i] = max(maxMul[j][i], max(maxMul[j - m][i - 1] * v[j], minMul[j - m][i - 1] * v[j]));
                    minMul[j][i] = min(minMul[j][i], min(minMul[j - m][i - 1] * v[j], maxMul[j - m][i - 1] * v[j]));
                }
            }
        }
 
        long long maxMulResult = 1LL << 63;
        for (int i = 0; i < n; i++)
            maxMulResult = max(maxMulResult, maxMul[i][k]);
        return maxMulResult;
    }
};
int main() {
    Solution S;
    int n, k, d;
    while (cin >> n) {
        vector<int> v(n);
        for (int i = 0; i < n; ++i)
            cin >> v[i];
        cin >> k >> d;
        cout << S.Cap(v, n, k, d) << endl;
    }
    return 0;
}

【牛客】【左右最值最大差】:
class MaxGap {
public:
    int findMaxGap(vector<int> A, int n) {
        int max = A[0],min;
        for(int i = 0; i < n; ++i)
            max = max<A[i]?A[i]:max;
        min = A[0]>A[n-1]?A[n-1]:A[0];
        return max - min;
    }
};

【牛客】【顺时针打印矩阵】：
class Printer {
public:
    vector<int> clockwisePrint(vector<vector<int>> mat, int n, int m) {
        int all = n * m;
        vector<int> res(all);
        int idx = 0;
        int left = 0, top = 0, right = m - 1, bottom = n - 1;
        int l, r, b, t;
        while (idx < all) {
            l = left;
            while (idx < all && l <= right)
                res[idx++] = mat[top][l++];
            ++top;
            t = top;
            while (idx < all && t <= bottom)
                res[idx++] = mat[t++][right];
            --right;
            r = right;
            while (idx < all && r >= left)
                res[idx++] = mat[bottom][r--];
            --bottom;
            b = bottom;
            while (idx < all && b >= top)
                res[idx++] = mat[b--][left];
            ++left;
        }
        return res;
    }
};

【LeetCode】【字符串的排列】：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/
class Solution {
public:
    vector<string> permutation(string s) {
        sz = s.size();
        sort(s.begin(),s.end());
        vector<bool> used(sz,false);
        BackTack("",used,s);
        return res;
    }
private:
    void BackTack(string tmp,vector<bool>& used,const string& s){
        if(tmp.size() == sz){
            res.push_back(tmp);
            return;
        }
        for(int i = 0; i < sz; ++i){
            if(used[i] || (i>0 && !used[i-1] && s[i-1] == s[i]))
                continue;
            used[i] = true;
            tmp += s[i];
            BackTack(tmp,used,s);
            tmp.erase(tmp.end()-1,tmp.end());
            used[i] = false;
        }
    }
private:
    vector<string> res;
    int sz;
};

【LeetCode219】【存在重复元素】：https://leetcode-cn.com/problems/contains-duplicate-ii/
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int sz = nums.size();
        unordered_map<int,int> mp;
        for(int i = 0; i < sz; ++i){
            if(mp.count(nums[i]) && i-mp[nums[i]]<=k)
                return true;
            mp[nums[i]] = i;
        }
        return false;
    }
};

【LeetCode228】【汇总区间】：https://leetcode-cn.com/problems/summary-ranges/
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int sz = nums.size();
        vector<string> res;
        int i = 0;
        while(i<sz){
            int st = nums[i++];
            string tmp(to_string(st));
            while(i<sz && nums[i-1] + 1 == nums[i])
                ++i;
            int ed = nums[i-1];
            if(st != ed){
                tmp += "->";
                tmp += to_string(ed);
            }
            res.push_back(tmp);
            tmp.clear();
        }
        return res;
    }
};

【剑指offer07】【重建二叉树】：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int sz = preorder.size();
        for(int i = 0; i < sz; ++i)
            mp[inorder[i]] = i;
        return DFS(preorder, inorder, 0, sz-1, 0, sz-1);
    }
private:
    TreeNode* DFS(vector<int>& pre,vector<int>&in,int st1,int ed1,int st2,int ed2){
        if(st1>ed1 || st2>ed2)
            return nullptr;
        int k = mp[pre[st1]];
        int len = k - st2;
        TreeNode* root = new TreeNode(pre[st1]);
        root->left = DFS(pre, in, st1+1, st1+1+len, st2, k-1);
        root->right = DFS(pre, in, st1+1+len, ed1, k+1, ed2);
        return root;
    }
private:
    unordered_map<int,int> mp;
};

【剑指offer20】【表示数值的字符串】：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/
class Solution {
public:
    bool isNumber(string s) {
        DelSpace(s);//删除前后空格
        int idx = SplitIndex(s); //获取划分索引
        int sz = s.size();
        if (idx != string::npos) {
            vector<string> num(2);
            num[0] = s.substr(0, idx);
            num[1] = s.substr(idx + 1, sz - idx);
            int sz0 = num[0].size();
            int sz1 = num[1].size();
            if (!sz0 && !sz1)//仅有一个符号
                return false;
            else if ((s[idx] == 'e' || s[idx] == 'E') && (!sz0 || !sz1))//e为两端
                return false;
            else if (s[idx] == '.' && !idx && !isdigit(num[1][0]))//.开头紧跟+/-
                return false;
            else if (s[idx] == '.' && sz0 == 1 && !isdigit(num[0][0]) && !sz1)
                return false;
            else if(sz0 == 1 && (s[idx] == 'e' || s[idx] == 'E') && (num[0][0] == '+' ||
                num[0][0] == '-'))
                return false;
            bool flag0 = IsNumPre(num[0], sz0);
            bool flag1 = IsNumPost(num[1], sz1);
            if (!flag0 || !flag1)
                return false;
            return true;
        }
        return IsNumPre(s, s.size());
    }
private:
    bool IsNumPre(const string& s,const int& sz) {
        if (!sz)
            return true;
        if (sz == 1 && s[0] == '.')
            return false;
        int i = 0;
        if (s[i] == '+' || s[i] == '-')
            ++i;
        while (i < sz && isdigit(s[i]))
            ++i;
        if (s[i] == '.')
            ++i;
        while (i < sz && isdigit(s[i]))
            ++i;
        return i == sz;
    }
    bool IsNumPost(const string& s, const int& sz) {
        if (!sz)
            return true;
        if (s == "+" || s == "-")
            return false;
        int i = 0;
        if (sz > 1 && s[i] == '+' || s[i] == '-')
            ++i;
        while (i < sz && isdigit(s[i]))
            ++i;
        return i == sz;
    }
    int SplitIndex(const string & s) {
        int idx = s.find('e', 0);
        if (idx != string::npos)
            return idx;
        idx = s.find('E', 0);
        if (idx != string::npos)
            return idx;
        idx = s.find('.', 0);
        if (idx != string::npos)
            return idx;
        return string::npos;
    }
    void DelSpace(string & s) {
        int sz = s.size();
        for (int i = sz - 1; i >= 0; --i) {
            if (s[i] == ' ')
                continue;
            else {
                s.erase(i + 1, sz - i - 1);
                break;
            }
        }
        sz = s.size();
        for (int i = 0; i < sz; ++i) {
            if (s[i] == ' ')
                continue;
            else {
                s.erase(0, i);
                break;
            }
        }
    }
};

【剑指offer33】【二叉搜索树的后序遍历序列】：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return DFS(0,postorder.size()-1,postorder);
    }
private:
    bool DFS(int left,int right,vector<int>& v){
        if(left>=right)//1个或0个
            return true;
        int k = left;
        while(k<right && v[k]<v[right])//查找比根大的第一个元素
            ++k;
        for(int i = k; i < right; ++i){//遍历右子树
            if(v[i]<v[right])
                return false;
        }
        return DFS(left,k-1,v) && DFS(k,right-1,v);//左子树 && 右子树
    }
};
【剑指offer40】【最小k个数】：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> hp(arr.begin(),arr.begin()+k);
        if(!k)
            return hp;
        for(int i = k/2-1; i >= 0;  --i)
            AdjustDown(hp,i,k);
        int n = arr.size();
        for(int i = k; i < n;i++){
            if(arr[i]<hp[0]){//小于最大的数
                hp[0] = arr[i];
                AdjustDown(hp,0,k);
            }
        }
        return hp;
    }
private:
   void AdjustDown(vector<int>& hp,int p,const int& k){
        int tmp = hp[p];
        int s = 2*p+1;
        while(s<k){
            if(s+1<k && hp[s+1]>hp[s])
                ++s;
            if(tmp>=hp[s])
                break;
            hp[p]= hp[s];
            p = s;
            s = 2*p+1;
       }
       hp[p] = tmp;
   }
};

【LeetCode23】【合并k个升序链表】：https://leetcode-cn.com/problems/merge-k-sorted-lists/
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
       return merge(lists,0,lists.size()-1);
    }
private:
    ListNode* merge(vector<ListNode*>& lists,int l,int r){
        if(l == r)
            return lists[l];
        if(l > r)
            return nullptr;
        int mid = (l + r)>>1;
        return MergeTwo(merge(lists,l,mid),merge(lists,mid+1,r));
    }
    ListNode* MergeTwo(ListNode* l1,ListNode* l2){
        if(!l1 || !l2)
            return l1?l1:l2;
        ListNode* head = new ListNode();
        ListNode* tmp = head;
        while(l1 && l2){
            if(l1->val < l2->val){
                tmp->next = l1;
                l1 = l1->next;
            }
            else{
                tmp->next = l2;
                l2 = l2->next;
            }
            tmp = tmp->next;
        }
        tmp->next = l1?l1:l2;
        ListNode* res = head->next;
        delete head;
        return res;
    }
};

【2021荣耀提前批笔试】【N个字符，1<=长度<=L，试问可以组成多少个不同的符号】：
#include <vector>
#include <limits.h>
#include <iostream>
using namespace std;

class Solution {
#define MOD  1000000007
public:
	unsigned long long NumofID(const int& N, const int& L) {
		if (!N || !L)
			return 0;
		unsigned long long res = N;
		vector<unsigned long long> v(L, N);
		for (int i = 1; i < L; ++i) {
			v[i - 1] %= MOD;
			while (v[i - 1] > LLONG_MAX / N) //阶乘超范围
				v[i - 1] -= MOD;
			v[i] *= v[i - 1];
			while (res > LLONG_MAX - v[i]) //加法超范围
				res -= MOD;
			res += v[i];
			res %= MOD;
		}
		return res;
	}
};

int main() {
	Solution S;
	int N, L;
	while (cin >> N >> L, N || L)
		cout << S.NumofID(N, L) << endl;
	return 0;
}

【剑指offerII:108】【有效的回文】：https://leetcode-cn.com/problems/XltzEq/
class Solution {
public:
    bool isPalindrome(string s) {
        Change(s);
        int sz = s.size();
        for(int i = 0 ; i < sz/2; ++i)
            if(s[i]!=s[sz-1-i])
                return false;
        return true;
    }
private:
    void Change(string& s){
        auto e = s.begin();
        while(e!=s.end()){
            if(isalnum(*e)){
                if(isalpha(*e))
                    *e  =  tolower(*e);
                ++e;
                continue;
            }
            else
                e = s.erase(e,e+1);
        }
    }
};

【剑指offerII70】【排序数组中只出现一次的数字】：https://leetcode-cn.com/problems/skFtm2/
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int res = 0;
        for(auto& e: nums)
            res ^= e;
        return res;
    }
};
【剑指 Offer II 004. 】【 只出现一次的数字】：https://leetcode-cn.com/problems/WGki4K/
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int sz = nums.size();
        vector<int> cnt(32,0);
        for(int i = 0; i < 32; ++i){
            for(int j = 0; j < sz; ++j){
                if((nums[j]>>i) & 1)
                    ++cnt[i];
            }
            cnt[i] %= 3;
        }
        int res = 0;
        for(int i = 0; i < 32; ++i){
            if(cnt[i])
                res += (1<<i);
        }
        return res;
    }
};

【从s1中删除s2中的字符】：
#include <iostream>
#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;

class Solution {
public:
    string DelSameChar(string& s1, string& s2) {
        unordered_map<char, int> ump;
        int sz = s2.size();
        for (auto& s : s2)
            ump[s] = 1;
        for (auto& e : ump) {
            auto it = s1.begin();
            while (it != s1.end()) {
                it = find(it, s1.end(), e.first);
                if (it != s1.end())
                    it = s1.erase(it, it + 1);
            }

        }
        return s1;
    }
};

int main() {
    Solution S;
    string s1;
    string s2;
    while (getline(cin, s1), getline(cin, s2))
        cout << S.DelSameChar(s1, s2) << endl;
    return 0;
}

【LeetCode679】【24 点游戏】：https://leetcode-cn.com/problems/24-game/
double Add(const double& x,const double& y){ return x+y; }
double Mul(const double& x,const double& y){ return x*y; }
double Min(const double& x,const double& y){ return x-y; }
double Div(const double& x,const double& y){ 
    if (y==0)//除数为0
        return DBL_MIN;
    return x/y;
}

class Solution {
#define VALID_LIMIT 1e-6
public:
    bool judgePoint24(vector<int>& cards) {
        vector<double> num(4);
        for(int i = 0; i < 4; ++i)
            num[i] = (double)cards[i];
        return BackTrack(num);
    }
public:
    Solution(){
        p[0] = Add;
        p[1] = Mul;
        p[2] = Min;
        p[3] = Div;
    }
private:
     bool BackTrack(vector<double> &l) {
        int sz = l.size();
        if (sz == 1) //已运算出结果
            return fabs(l[0] - 24.0) <  VALID_LIMIT;
        for (int i = 0; i < sz; ++i) {//控制数1
            for (int j = 0; j < sz; ++j) {//控制数2
                if (i != j) {//数1 != 数2
                    vector<double> list2 = vector<double>();
                    for (int k = 0; k < sz; k++) {
                        if (k != i && k != j) //刨去运算的两个数
                            list2.emplace_back(l[k]);
                    }
                    for (int k = 0; k < 4; k++) {//四种运算
                        if (k < 2 && i > j)//+*满足交换律，不需要重复计算 
                            continue;
                        list2.emplace_back((*p[k])(l[i], l[j]));//运算
                        if (BackTrack(list2))
                            return true;
                        list2.pop_back();//回退
                    }
                }
            }
        }
        return false;
    }
private:
    double(*p[4])(const double& x,const double& y);
};

【删除字符串首尾空格，中间连续空格只保留一个】：
class Solution {
public:
    string DelSpace(string& s) {
        DelHead(s);
        reverse(s.begin(), s.end());
        DelHead(s);
        reverse(s.begin(),s.end());
        auto t = s.begin();
        bool flag = false;
        while (t != s.end()) {
            if (*t != ' ') {
                flag = false;
                ++t;
            }
            else if (flag && *t == ' ')
                t = s.erase(t, t + 1);
            else {
                flag = true;
                ++t;
            }
        }
        return s;
    }
private:
    void DelHead(string& s){
        auto t = s.begin();
        while (*t == ' ')
            t = s.erase(t, t + 1);
    }
};

【LeetCode152】【乘积最大子数组】：https://leetcode-cn.com/problems/maximum-product-subarray/
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int minn = nums[0];
        int maxn = nums[0];
        int ans = nums[0];
        int sz = nums.size();
        for(int i = 1; i < sz; ++i){
            int t_min = minn;
            int t_max = maxn;
            minn = min(minn*nums[i], min(nums[i],t_max*nums[i]));
            maxn = max(maxn*nums[i], max(nums[i],t_min*nums[i]));
            ans = max(ans,maxn);
        }
        return ans;
    }
};

【Leetcode4】【 寻找两个正序数组的中位数】：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        priority_queue<int, vector<int>, less<int>> maxHeap;
        priority_queue<int, vector<int>, greater<int>> minHeap; 
        int sz1 = nums1.size();
        int sz2 = nums2.size();
        int sz = sz1 + sz2;
        for(int i = 0 ; i < sz; ++i){
            int x = i>=sz1?nums2[i-sz1]:nums1[i];
            if(maxHeap.size() == minHeap.size()){
                minHeap.push(x);
                maxHeap.push(minHeap.top());
                minHeap.pop();

            }
            else{
                maxHeap.push(x);
                minHeap.push(maxHeap.top());
                maxHeap.pop();
            }
        }
        if(minHeap.size() == maxHeap.size())
            return 0.5*(minHeap.top()+maxHeap.top());
        return maxHeap.top()*1.0;
    }
};
【笔试】：
起点为（0,0）,方向为4个。0为水路，花费2，1位陆地，花费为1，2为障碍，不可通过，最小费用达到右下角，无法到达返回-1
class Solution {
public:
	int minSailCost(vector<vector<int>>& input) {
		row = input.size();
		col = input[0].size();
		vector<vector<bool>> visited(row, vector<bool>(col, false));
		BackTrack(input, visited, 0, 0, 0);
		return MinCost == INT_MAX ? -1 : MinCost;
	}
private:
	void BackTrack(const vector<vector<int>>& input, vector<vector<bool>>& visited, int x, int y, int cost) {
		if (x == row - 1 && y == col - 1) {
			MinCost = cost < MinCost ? cost : MinCost;
			return;
		}
		for (int i = 0; i < 4; ++i) {
			int nx = x + dir[i][0];
			int ny = y + dir[i][1];
			if (nx < 0 || nx >= row || ny < 0 || ny >= col || visited[nx][ny] || input[nx][ny] == 2)
				continue;
			visited[nx][ny] = true;
			int fee = input[nx][ny] == 1 ? 1 : 2;
			BackTrack(input, visited, nx, ny, cost + fee);
			visited[nx][ny] = false;
		}
	}
public:
	Solution() :MinCost(INT_MAX), row(0), col(0) {}
private:
	int MinCost;
	int row;
	int col;
	int dir[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };
};

【剑指offer57-II】【和为s的连续正数序列】：
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
         vector<vector<int>>vec;
        vector<int> res;
        for (int l = 1, r = 2; l < r;){
            int sum = (l + r) * (r - l + 1) / 2;
            if (sum == target) {
                res.clear();
                for (int i = l; i <= r; ++i) {
                    res.emplace_back(i);
                }
                vec.emplace_back(res);
                l++;
            } else if (sum < target) {
                r++;
            } else {
                l++;
            }
        }
        return vec;
    }
};

【剑指 Offer 34】【 二叉树中和为某一值的路径】：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int target) {
        vector<int> path;
        DFS(root,target,path);
        return res;
    }
private:
    void DFS(TreeNode* root, int ans, vector<int> seq){
        if(root==nullptr)
            return;
        ans -= root->val;
        seq.push_back(root->val);
        if(ans == 0 && root->left==nullptr && root->right == nullptr){
            res.push_back(seq);
            return;
        }
        if(root->left != nullptr)
            DFS(root->left,ans,seq);
        if(root->right != nullptr)
            DFS(root->right,ans,seq);
    }
};

【剑指 Offer 41】【 数据流中的中位数】：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {
    }
    
    void addNum(int num) {
        if(Biger.size() == Smaller.size()){
            Smaller.push(num);
            Biger.push(Smaller.top());
            Smaller.pop();
        }else{
            Biger.push(num);
            Smaller.push(Biger.top());
            Biger.pop();
        }
    }
    
    double findMedian() {
        if(Biger.size() == Smaller.size())
            return 0.5*(Biger.top() + Smaller.top());
        return 1.0*Biger.top();
    }
private:
    priority_queue<int, vector<int>, less<int>> Biger;
    priority_queue<int, vector<int>, greater<int>> Smaller;
};

【剑指 Offer 46】【 把数字翻译成字符串】：https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/
class Solution {
public:
    set<string> st;
    vector<int> digit;
    int translateNum(int num) {
        Split(num);
        DFS("", 0);
        return st.size();
    }
private:
    void DFS(string tmp,int idx){
        if(idx == sz){
            cout<<tmp<<endl;
            st.insert(tmp);
            return;
        }
        int x = 0;
        for(int i = idx; i < idx + 2 && i < sz; ++i){
            x = x*10 + digit[i];
            if(x > 25 || (i-idx==1 && x<10))
                return;
            tmp += dict[x];
            DFS(tmp,i+1);
            tmp.erase(tmp.end()-1,tmp.end());
        }
    }
    void Split(int num){
        while(num){
            digit.push_back(num%10);
            num/=10;
        }
        reverse(digit.begin(),digit.end());
        sz = digit.size();
    }
public:
    Solution(){
        char tmp = 'a';
        for(int  i = 0 ; i <= 25; ++i)
            dict[i] = tmp++;
    }
private:
    map<int,char> dict;
    int sz;
};

【剑指 Offer 45】【把数组排成最小的数】：https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/
class Solution {
public:
    string minNumber(vector<int>& nums) {
        int sz = nums.size();
        vector<string> st(sz);
        for(int i = 0; i < sz; ++i)
            st[i] = to_string(nums[i]);
        sort(st.begin(),st.end(),comp);
        string res;
        for(int i = 0 ; i < sz; ++i)
            res += st[i];
        return res;
    }
private:
    static bool comp(string x,string y){
         return (x+y)<(y+x);
    }
};

【剑指 Offer 60】【n个骰子的点数】：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/
class Solution {
public:
    vector<double> dicesProbability(int n) {
        vector<double> dp(6,1.0/6.0);
        for(int i = 2; i <= n; ++i){
            vector<double> tmp(5*i+1, 0);
            for(int j = 0; j < dp.size(); ++j){
                for(int k = 0; k < 6; ++k)
                    tmp[j+k] += dp[j]/6.0;
            }
            dp = tmp;
        }
        return dp;
    }
};

【剑指 Offer II 003】【前 n 个数字二进制中 1 的个数】：https://leetcode-cn.com/problems/w3tCBm/
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> dp(n+1,0);
        dp[0] = 0;
        for(int i = 1; i <= n; ++i)
            dp[i] = i&1?dp[i-1]+1:dp[i>>1];
        return dp;
    }
};

【剑指 Offer II 002】【二进制加法】：https://leetcode-cn.com/problems/JFETK5/
class Solution {
public:
    string addBinary(string a, string b) {
        int sz1 = a.size();
        int sz2 = b.size(); 
        int sz = max(sz1,sz2);
        reverse(a.begin(),a.end());
        reverse(b.begin(),b.end());
        int flag = 0;
        string res;
        for(int i = 0; i < sz; ++i){
            int n1 = i>=sz1?0:a[i]-'0';
            int n2 = i>=sz2?0:b[i]-'0';
            int tmp = n1 + n2 + flag;
            flag = tmp>1?1:0;
            res += tmp%2 + '0';
        }
        if(flag)
            res += '1';
        reverse(res.begin(),res.end());
        return res;
    }
};

【剑指 Offer II 001】【整数除法】：https://leetcode-cn.com/problems/xoh6Oh/
class Solution {
public:
    int divide(int a, int b) {
        if(a==INT_MIN && b==-1)
            return INT_MAX;
        int flag = 2;
        flag -= a>0?(a=-a,1):0;
        flag -= b>0?(b=-b,1):0;
        unsigned int res =  MyDiv(a,b);
        return flag==1?-res:res;
    }
private:
    unsigned int MyDiv(int a,int b){
        int ret = 0;
        while(a <= b){
            unsigned int k = 1;
            int val = b;
            //0xc0000000=2^30，防止val溢出
            while(val>=0xc0000000 && a <= val + val)
                k += k,val += val;
            ret += k;
            a -= val; 
        }
        return ret;
    }
};

【剑指 Offer 51】【数组中的逆序对】：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        vector<int> tmp(nums);
        return MergeSort(nums, tmp, 0, nums.size() - 1);
    }
private:
    int MergeSort(vector<int>& nums,vector<int>& tmp,int left, int right){
        if(left>=right)
            return 0;
        int mid = left + ((right-left)>>1);
        int inv_cnt = MergeSort(nums,tmp,left,mid) + MergeSort(nums,tmp,mid+1,right);
        int i = left,j = mid+1, pos = left;
        while(i<=mid && j <= right){
            if(nums[i]<=nums[j]){
                tmp[pos++] = nums[i++];
                inv_cnt += (j-(mid+1));
            }else
                tmp[pos++] = nums[j++];
        }
        for(int k = i; k <= mid; ++k){
            tmp[pos++] = nums[k];
            inv_cnt += (j-(mid+1));
        }
        for(int k = j; k <= right; ++k)
            tmp[pos++] = nums[k];
        copy(tmp.begin() + left, tmp.begin()+ right + 1, nums.begin() + left);
        return inv_cnt;
    }
};

【LeetCode347】【前 K 个高频元素】：https://leetcode-cn.com/problems/top-k-frequent-elements/
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> ump;
        for(auto& x:nums)
            ++ump[x];
        vector<pair<int,int>> tar(ump.begin(),ump.end());
        sort(tar.begin(), tar.end(), comp);
        vector<int> res(k);
        for(int i = 0; i < k; ++i)
            res[i] = tar[i].first;
        return res;
    }
    static bool comp(const pair<int,int>& p1,const pair<int,int>& p2){
        return p1.second>p2.second;
    }
};

【LeetCode49 】【字母异位词分组】：https://leetcode-cn.com/problems/group-anagrams/
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> ump;
        for(string& s:strs){
            string key = s;
            sort(key.begin(),key.end());
            ump[key].emplace_back(s);
        }
        vector<vector<string>> res;
        for (auto it = ump.begin(); it != ump.end(); ++it) 
            res.emplace_back(it->second);
        return res;     
    }
};

【LeetCode229】【求众数 II】：https://leetcode-cn.com/problems/majority-element-ii/
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int sz = nums.size();
        int limit = sz/3;
        unordered_map<int,int> ump;
        for(int i = 0; i < sz; ++i)
            ++ump[nums[i]];
        vector<int> res;
        for(auto& it:ump){
            if(it.second > limit)
                res.push_back(it.first);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};

【LeetCode179】【最大数】：https://leetcode-cn.com/problems/largest-number/
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        int sz = nums.size();
        vector<string> tmp(sz);
        for(int i = 0; i < sz; ++i)
            tmp[i] = to_string(nums[i]);
        sort(tmp.begin(),tmp.end(),comp);
        string res;
        for(int i = 0 ; i < sz; ++i)
            res += tmp[i];
        sz = res.size();
        string zeros(sz,'0');
        return zeros==res?"0":res;
    }
private:
    static bool comp(string s1, string s2){
        return s1+s2>s2+s1;
    }
};

【LeetCode654】【最大二叉树】：https://leetcode-cn.com/problems/maximum-binary-tree/
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return helper(nums,0,nums.size());
    }
private:
    TreeNode* helper(const vector<int>& num, int left, int right){
        if(left==right)
            return nullptr;
        int pos = MaxIdx(num, left, right);
        TreeNode* root = new TreeNode(num[pos]);
        root->left = helper(num, left, pos);
        root->right = helper(num, pos+1, right);
        return root;
    }
    int MaxIdx(const vector<int>& num, int left, int right){
        int res = left; 
        for(int i = left + 1; i < right; ++i)
            res = num[i]>num[res]?i:res;
        return res;
    }
};

【LeetCode938】【 二叉搜索树的范围和】：https://leetcode-cn.com/problems/range-sum-of-bst/
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int res = 0;
        DFS(root,res,low,high);
        return res;
    }
private:
    void DFS(TreeNode* root,int& res,const int& low, const int& high){
        if(root==nullptr)
            return;
        res += (root->val>=low && root->val<=high)?root->val:0;
        DFS(root->left,res,low,high);
        DFS(root->right,res,low,high);
    }
};

【958】【 二叉树的完全性检验】：https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        queue<TreeNode*> Q;
        Q.push(root);
        while(Q.empty() == false){
            int sz = Q.size();
            for(int i = 0 ; i < sz; ++i){
                TreeNode* t = Q.front();
                Q.pop();
                if(t->left == nullptr && t->right)//
                    return false;
                else if(t->right==nullptr){//此后应再无孩子
                    if(t->left)
                        Q.push(t->left);
                    while(Q.size()){
                        TreeNode* p = Q.front();
                        Q.pop();
                        if(p->left || p->right)
                            return false;
                    }
                    return true;
                }
                if(t->left)
                    Q.push(t->left);
                if(t->right)
                    Q.push(t->right);
            }
        }
            return true;
    }
};

【1008】【前序遍历构造二叉搜索树】：https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/
class Solution {
public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        int sz = preorder.size();
        if(sz == 0)
            return nullptr;
        return DFS(preorder, 0, sz-1);
    }
private:
    TreeNode* DFS(const vector<int>& pre, int left, int right){
        if(left>right)
            return nullptr;
        TreeNode* t = new TreeNode(pre[left]);
        if(left == right)
            return t;
        int l = left, r = right;
        while(l<r){
            int mid = l + ((r-l+1)>>1);
            if(pre[mid] < pre[left])
                l = mid;
            else
                r = mid - 1; 
        }
        t->left = DFS(pre,left + 1,l);
        t->right  = DFS(pre, l + 1, right);
        return t;
    }
};

【LeetCode148】【 排序链表】：https://leetcode-cn.com/problems/sort-list/
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return sortList(head, nullptr);
    }
private:
    ListNode* sortList(ListNode* head, ListNode* tail){
        if(head == nullptr)
            return head;
        if(head->next == tail){
            head->next = nullptr;
            return head;
        }
        ListNode* slow = head, *fast = head;
        while(fast != tail){
            slow = slow->next;
            fast = fast->next;
            if(fast != tail)
                fast = fast->next;
        }
        ListNode* mid = slow;
        return merge(sortList(head, mid),sortList(mid,tail));
    }
    ListNode* merge(ListNode* head1, ListNode* head2){
        ListNode* dummyhead= new ListNode(0);
        ListNode *temp = dummyhead, *temp1 = head1, *temp2 = head2;
        while(temp1!=nullptr && temp2!=nullptr){
            if(temp1->val <= temp2->val){
                temp->next = temp1;
                temp1 = temp1->next;
            }
            else{
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        if(temp1!=nullptr)
            temp->next = temp1;
        else if(temp2!=nullptr)
            temp->next = temp2;
        ListNode *res = dummyhead->next;
        delete dummyhead;
        return res;
    }
};

【LeetCode143】【重排链表】：https://leetcode-cn.com/problems/reorder-list/
【线性表】
class Solution {
public:
    void reorderList(ListNode* head) {
        vector<ListNode*> num;
        ListNode* tmp = head;
        while(tmp){
            num.push_back(tmp);
            tmp = tmp->next;
        }
        int i = 0, j = num.size()-1;
        while(i<j){
            num[i++]->next = num[j];
            if(i == j)
                break;
            num[j--]->next = num[i];
        }
        num[i]->next = nullptr;
    }
};
【中点+翻转+合并】
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* mid = SeekMid(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next; 
        mid->next = nullptr;
        l2 = Reverse(l2);
        Merge(l1, l2);
    }
private:
    ListNode* SeekMid(ListNode* head){
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast->next != nullptr && fast->next->next!=nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
    ListNode* Reverse(ListNode* l){
        ListNode* pre = nullptr;
        ListNode* cur = l;
        while(cur != nullptr){
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }  
        return pre;
    }
    void Merge(ListNode* l1, ListNode* l2){
        ListNode* l1_tmp;
        ListNode* l2_tmp;
        while(l1!=nullptr && l2!=nullptr){
            l1_tmp = l1->next;
            l2_tmp = l2->next;
            l1->next = l2;
            l2->next = l1_tmp;
            l1 = l1_tmp;
            l2 = l2_tmp;
        }
    }
};

【901】【 股票价格跨度】：https://leetcode-cn.com/problems/online-stock-span/
class StockSpanner {
public:
    StockSpanner() {}
    
    int next(int price) {
        int w = 1;
        while(!prices.empty() && price >= prices.top()){
            w += weight.top();
            prices.pop();
            weight.pop();
        }
        prices.push(price);
        weight.push(w);
        return w;
    }
private:
    stack<int> prices;
    stack<int> weight;
};

【剑指 Offer II 105】【岛屿的最大面积】：https://leetcode-cn.com/problems/ZL6zAn/
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        row = grid.size();
        col = grid[0].size();
        maxArea = 0;
        vector<vector<bool>> visited(row, vector<bool> (col,false));
        for(int i = 0; i < row; ++i)
            for(int j = 0; j < col; ++j)
                if(grid[i][j] && !visited[i][j]){
                    int area = 1;
                    DFS(grid,visited, i, j, area);
                } 
        return maxArea;
    }
private:
    void DFS(const vector<vector<int>>& grid, vector<vector<bool>>& visited,int x, int y,int& area){
        maxArea = area>maxArea?area:maxArea;
        visited[x][y] = true;
        for(int i = 0; i < 4; ++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0 || nx>=row || ny<0 || ny>=col || !grid[nx][ny] || visited[nx][ny])
                continue;
            ++area;
            DFS(grid,visited,nx,ny,area);
        }
    }
private:
    int maxArea;
    int row;
    int col;
    int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; 
};

【剑指 Offer II 099】【. 最小路径之和】：https://leetcode-cn.com/problems/0i0mDW/
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(grid);
        for(int i = 1; i < m; ++i)
            dp[i][0] += dp[i-1][0];
        for(int i = 1; i < n; ++i)
            dp[0][i] += dp[0][i-1];
        for(int i = 1; i < m; ++i){
            for(int j = 1; j < n; ++j)
                dp[i][j] += min(dp[i-1][j],dp[i][j-1]);
        }
        return dp[m-1][n-1];
    }
};

【剑指 Offer II 021】【. 删除链表的倒数第 n 个结点】：https://leetcode-cn.com/problems/SLwz0R/
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0,head);
        ListNode* first = head;
        ListNode* second = dummy;
        while(n--)
            first = first->next;
        while(first){
            first = first->next;
            second = second->next;
        }
        second->next = second->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};

【剑指 Offer II 024】【. 反转链表】：https://leetcode-cn.com/problems/UHnkqh/
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr || head->next==nullptr)
            return head;
        ListNode* dummy = new ListNode(0);
        ListNode* cur = head;
        ListNode* back = cur->next;
        while(cur!=nullptr){
            cur->next = dummy->next;
            dummy->next = cur;
            cur = back;
            if(back!=nullptr)
                back = back->next;
        }
        return dummy->next;
    }
};

【剑指 Offer II 044】【. 二叉树每层的最大值】：https://leetcode-cn.com/problems/hPov7L/
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        if(root == nullptr)
            return res;
        queue<TreeNode*> Q;
        Q.push(root);
        while(!Q.empty()){
            int sz = Q.size();
            int tmp_max = INT_MIN;
            for(int i = 0; i < sz; ++i){
                TreeNode* t = Q.front();
                Q.pop();
                tmp_max = t->val>tmp_max?t->val:tmp_max;
                if(t->left)
                    Q.push(t->left);
                if(t->right)
                    Q.push(t->right);
            }
            res.push_back(tmp_max);
        }
        return res;
    }
};

【剑指 Offer II 045】【. 二叉树最底层最左边的值】：https://leetcode-cn.com/problems/LwUNpT/
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        DFS(root, 0);
        return res;
    }
private:
    void DFS(TreeNode* root,int curdepth){
        if(root == nullptr)
            return;
        ++curdepth;
        if(curdepth>depth){
            depth = curdepth;
            res = root->val;
        }
        DFS(root->left,curdepth);
        DFS(root->right,curdepth);
    }
private:
    int depth = 0;
    int res;
};

【LeetCode1905】【统计子岛屿】：https://leetcode-cn.com/problems/count-sub-islands/
class Solution {
public:
    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        m = grid2.size();
        n = grid2[0].size();
        int res = 0;
        vector<vector<bool>> visited(m,vector<bool> (n,false));
        bool flag = true;
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(grid2[i][j] && !visited[i][j] && grid1[i][j]){
                    flag = true;
                    DFS(grid1,grid2,visited,i,j,flag);
                    if(flag)
                        ++res;
                }
            }
        }
        return res;
    }
private:
    void DFS(const vector<vector<int>>& grid1,const vector<vector<int>>& grid2,vector<vector<bool>>& visited,int x, int y,bool& flag){
        for(int i = 0; i < 4; ++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0 || nx>=m || ny<0 || ny>=n || visited[nx][ny] || !grid2[nx][ny])
                continue;
            if(grid1[nx][ny]==0)
                flag = false;
            visited[nx][ny] = true;
            DFS(grid1,grid2,visited,nx,ny,flag);
        }
    }
private:
    int m;
    int n;
    int dir[4][2] ={{1,0},{0,1},{-1,0},{0,-1}}; 
};

【LeetCode560】【和为K的子数组】：
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int res = 0;
        int sum = 0;
        unordered_map<int,int> ump;
        ump[0] = 1;
        for(auto& x: nums){
            sum += x;
            res += ump[sum-k];
            ++ump[sum];
        }
        return res;
    }
};

【剑指 Offer II 104】【排列的数目】：https://leetcode-cn.com/problems/D0F0SV/
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<long> dp(target+1,0);
        dp[0] = 1;
        for(int i = 1; i <= target; ++i){
            for(const int& n: nums){
                if(i<n || dp[i]>INT_MAX-n)
                    continue;
                dp[i] += dp[i-n];
            }
        }
        return dp[target];
    }
};

【LeetCode413】【.等差数列划分】：https://leetcode-cn.com/problems/arithmetic-slices/
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int res = 0, l = 0; 
        int sz = nums.size();
        for(int i = 2; i < sz; ++i){
            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])
                res += ++l;
            else
                l = 0;
        }
        return res;
    }
};

【LeetCode1414. 】【和为 K 的最少斐波那契数字数目】：https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/
class Solution {
public:
    int findMinFibonacciNumbers(int k) {
        int res = 0;
        for(int i = 43; i>=0 && k; --i){
            if(k>=nums[i]){
                ++res;
                k -= nums[i];
            }
        }
        return res;
    }
public:
    Solution():nums(44){
        nums[0] = nums[1] = 1;
        for(int i = 2; i < 44; ++i)
            nums[i] = nums[i-1]+nums[i-2];
    }
private:
    vector<int> nums;
};

【LeetCode99】【. 恢复二叉搜索树】：https://leetcode-cn.com/problems/recover-binary-search-tree/
class Solution {
public:
    void recoverTree(TreeNode* root) {
        vector<int> in;
        Inorder(in,root);
        int cnt = 0;
        int sz = in.size();
        vector<int> err(2,-1);
        vector<int> tmp(in);
        sort(tmp.begin(),tmp.end());
        for(int i = 0; i < sz; ++i){
            if(in[i]!=tmp[i]){
                err[0] = in[i];
                err[1] = tmp[i];
                break;
            }
        }
        Recover(root,err,2);
    }
private:
    void Recover(TreeNode* root, const vector<int>& err,int cnt){
        if(root == nullptr)
            return;
        if(root->val == err[0] || root->val == err[1]){
            root->val = root->val==err[0]?err[1]:err[0];
            if(cnt == 0)
                return;
        }
        Recover(root->left,err,cnt);
        Recover(root->right,err,cnt);
    }
    void Inorder(vector<int>& in,TreeNode* root){
        if(root==nullptr)
            return;
        Inorder(in,root->left);
        in.push_back(root->val);
        Inorder(in,root->right);
    }
};

【剑指 Offer II 034】【. 外星语言是否排序】：https://leetcode-cn.com/problems/lwyVBB/submissions/
class Solution {
public:
    bool isAlienSorted(vector<string>& words, string order) {
        int i = 1;
        for(auto& c:order)
            dict[c] = i++;
        int sz = words.size();
        for(int i = 1; i < sz; ++i){
            if(!IsSorted(words[i-1],words[i]))
                return false;
        }
        return true;
    }
    bool IsSorted(const string& s1,const string& s2){
        int sz1 =  s1.size(); 
        int sz2 = s2.size();
        int i = 0;
        for(; i<sz1 && i<sz2; ++i){
            if(dict[s1[i]]>dict[s2[i]])
                return false;
            if(dict[s1[i]]<dict[s2[i]])
                return true;
        }
        return i==sz1;
    }
private:
    unordered_map<char,int> dict;
};

【剑指 Offer II 015】【. 字符串中的所有变位词】：https://leetcode-cn.com/problems/VabMRr/
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        int sz = s.size();
        int len = p.size();
        unordered_map<char, int> ump;
        for (auto& c : p)
            ++ump[c];
        unordered_map <char, int> tar;
        int i = 0, j = 0;
        while(j<len)
            ++tar[s[j++]];
        --j;
        while (j < sz) {
            if (IsEqual(tar, ump)) 
                res.push_back(i);
            --tar[s[i++]];
            ++tar[s[++j]]; 
        }
        return res;
    }
private:
    bool IsEqual(unordered_map<char, int>& tar, unordered_map<char, int>& ump) {
        for (auto& t : ump)
            if (tar[t.first] != t.second)
                return false;
        return true;
    }
};

【516】【. 最长回文子序列】：https://leetcode-cn.com/problems/longest-palindromic-subsequence/
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int sz = s.size();
        vector<vector<int>> dp(sz,vector<int>(sz));
        for(int i = sz-1; i >= 0; --i){
            char c1 = s[i];
            dp[i][i] = 1;
            for(int j = i+1; j < sz; ++j){
                char c2 = s[j];
                if(c1 == c2)
                    dp[i][j] = dp[i+1][j-1] + 2;
                else
                    dp[i][j] = max(dp[i][j-1],dp[i+1][j]);
            }
        }
        return dp[0][sz-1];
    }
};

【459】【. 重复的子字符串】：https://leetcode-cn.com/problems/repeated-substring-pattern/
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string tmp = s+s;
        int n = s.size();
        for(int i = 1; i <= n/2; ++i){
            string tmp2(tmp.begin()+i,tmp.begin()+i+n);
            if(tmp2 == s)
                return true;
        }
        return false;
    }
};

【316】【. 去除重复字母】：https://leetcode-cn.com/problems/remove-duplicate-letters/
class Solution {
public:
    string removeDuplicateLetters(string s) {
        vector<int> rec(26,0);
        vector<bool> vis(26,false);
        for(auto& c:s)
            ++rec[c-'a'];
        string res;
        for(auto& c:s){
            if(!vis[c-'a']){
                while(!res.empty() && res.back()>c){
                    if(rec[res.back()-'a']>0){
                        vis[res.back()-'a'] = false;
                        res.pop_back();
                    }
                    else
                        break;
                }
                res += c;
                vis[c-'a'] = true;
            }
            --rec[c-'a'];
        } 
        return res;
    } 
};

【77】【. 组合】：https://leetcode-cn.com/problems/combinations/
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        N = n;
        K = k;
        vector<int> tmp;
        BackTrack(1);
        return res;
    }
private:
    void BackTrack(int cur){
        if(tmp.size() + (N-cur+1) < K)
            return;
        if(tmp.size() == K){
            res.push_back(tmp);
            return;
        }
        tmp.push_back(cur);
        BackTrack(cur+1);
        tmp.pop_back();
        BackTrack(cur+1);
    }
private:
    vector<vector<int>> res;
    vector<int> tmp;
    int N;
    int K;
};

【90】【. 子集 II】：https://leetcode-cn.com/problems/subsets-ii/
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sz = nums.size();
        sort(nums.begin(),nums.end());
        vector<int> tmp;
        vector<bool> vis(sz,false);
        BackTrack(nums, 0, tmp, vis);
        return res;
    }
private:
    void BackTrack(const vector<int>& nums, int idx,vector<int> tmp,vector<bool>& vis){
        res.push_back(tmp);
        for(int i = idx; i < sz; ++i){
            if(i>0 && !vis[i-1] && nums[i-1]==nums[i])
                continue;
            tmp.push_back(nums[i]);
            vis[i] = true;
            BackTrack(nums,i+1,tmp,vis);
            tmp.pop_back();
            vis[i] = false;
        }
    }
private:
    int sz;
    vector<vector<int>> res;
};

【93】【. 复原 IP 地址】：https://leetcode-cn.com/problems/restore-ip-addresses/
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        sz = s.size();
        ip.resize(4);
        BackTrack(s, 0, 0);
        return res;
    }
private:
    void BackTrack(const string& s, int idx, int cnt) {
        if (cnt == 4) {
            if (idx == sz) {
                string tmp;
                for (int i = 0; i < 4; ++i) {
                    tmp += to_string(ip[i]);
                    if (i < 3)
                        tmp += '.';
                }
                res.push_back(tmp);
            }
            return;
        }
        if(idx == sz)
            return;
        if (s[idx] == '0') {
            ip[cnt] = 0;
            BackTrack(s, idx + 1, cnt + 1);
        }
        int sum= 0;
        for (int i = idx; i < sz; ++i) {
            sum = sum * 10 + (s[i] - '0');
            if (sum > 0 && sum <= 255) {
                ip[cnt] = sum;
                BackTrack(s, i + 1, cnt + 1);
            }
            else
                break;
        }
    }
private:
    int sz;
    vector<string> res;
    vector<int> ip;
};

【剑指 Offer II 119】【. 最长连续序列】：https://leetcode-cn.com/problems/WhsWhI/
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int res = 0;
		set<int> st(nums.begin(), nums.end());
		vector<int> tmp(st.begin(), st.end());
		int sz = tmp.size();
		int i = 0;
		int j = 0;
		int len = 1;
		while (j < sz) {
			++j;
			if (j < sz && tmp[j - 1] + 1 == tmp[j]) {
				++len;
				continue;
			}
			else {
				res = len > res ? len : res;
				i = j;
				len = 1;
			}
		}
		return res;
    }
};

【523.】【 连续的子数组和】：https://leetcode-cn.com/problems/continuous-subarray-sum/
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int sz = nums.size();
        if(sz < 2)
            return false;
        unordered_map<int,int> ump;
        ump[0] = -1;
        int remainder = 0;
        for(int i = 0; i < sz; ++i){
            remainder = (remainder + nums[i])%k;
            if(ump.count(remainder)){
                int preindex = ump[remainder];
                if(i - preindex>=2)
                    return true;
            }
            else
                ump[remainder] = i;
        }
        return false;
    }
};

【525】【. 连续数组】：https://leetcode-cn.com/problems/contiguous-array/
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int sz = nums.size();
        unordered_map<int,int> ump;
        int cnt = 0;
        int maxlen = 0;
        ump[0] = -1;
        for(int i = 0; i < sz; ++i){
            if(nums[i])
                ++cnt;
            else
                --cnt;
            if(ump.count(cnt)){
                int preindex = ump[cnt];
                maxlen = (i-preindex)>maxlen?i-preindex:maxlen;
            }
            else
                ump[cnt] = i;
        }
        return maxlen;
    }
};

#include <iostream>
#include <unordered_map>
#include <string>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;
/*
题目一：像素放大
现在我们需要放大一张图片，图片都是由像素组成的，放大图像就是放大像素。
放大像素的过程如下：
现在原有图像像素信息如右：1 0
						  0 1
现在需要将其放大3倍,结果如右：1 1 1 0 0 0
                              1 1 1 0 0 0
							  1 1 1 0 0 0
							  0 0 0 1 1 1
							  0 0 0 1 1 1 
							  0 0 0 1 1 1
再举一个栗子，原像素信息：1 1 0
                          1 0 1
						  0 0 1
现将其放大2倍，结果如右：1 1 1 1 0 0
                         1 1 1 1 0 0
						 1 1 0 0 1 1
						 1 1 0 0 1 1
						 0 0 0 0 1 1
						 0 0 0 0 1 1
现输入原像素信息，请你输出放大后的图像
输入：第一行输入N，K，使用空格间隔
接着N行，每行N个数字，共同组成原图像，请将其放大K倍后输出
示例：
输入：2 2
      1 0
	  0 1
输出：1 1 0 0
      1 1 0 0
      0 0 1 1
	  0 0 1 1
*/
class Solution {
public:
	void BigImage(const int& N, const int& K, const vector<vector<int>>& nums) {
		for (int i = 0; i < N; ++i) {
			vector<int> tmp1(N * K);
			int idx = 0;
			for (int j = 0; j < N; ++j) {
				for (int t = 0; t < K; ++t)
					tmp1[idx++] = nums[i][j];
			}
			for (int j = 0; j < K; ++j) {
				for (int t = 0; t < N * K; ++t)
					cout << tmp1[t] << " ";
				cout << endl;
			}
		}
	}
};
int main() {
	Solution S;
	int N, K;
	while (cin >> N >> K) {
		vector<vector<int>> nums(N, vector<int>(N));
		for (int i = 0; i < N; ++i)
			for (int j = 0; j < N; ++j)
				cin >> nums[i][j];
		S.BigImage(N, K, nums);
	}
	return 0;
}
/*
题目二：组合数
若两个数m,n的最小公因数GCD(m,n)=1，最小公倍数LCM(m,n)=m*n,
那我们就称(m,n)是积为m*n的一对目标组合。
现输入一个数N，请求出积为N的目标组合的数目。
示例：
输入：30
输出：4（解释：(1,30)(2,15)(3,10)(5,6)）
*/


class Solution {
public:
	int NumofTargetCombine(const int& N) {
		unordered_map<int, int> ump;
		FindFactors(N, ump);
		int res = 0;
		for (auto& it : ump) {
			if (GCD(it.first, it.second) == 1)
				++res;
		}
		return res;
	}
private:
	void FindFactors(const int& N, unordered_map<int,int>& ump) {
		for (int i = 1; i <= sqrt(N); ++i) {
			if (N % i == 0)
				ump[i] = N / i;
		}
	}
	int GCD(int m, int n) {
		while (m != n) {
			if (m > n)
				m -= n;
			else if (m < n)
				n -= m;
			else
				break;
		}
		return m;
	}
};

int main() {
	Solution S;
	int N;
	while (cin >> N)
		cout << S.NumofTargetCombine(N) << endl;
	return 0;
}

【566】【. 重塑矩阵】：https://leetcode-cn.com/problems/reshape-the-matrix/
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
        int m = mat.size();
        int n = mat[0].size();
        if(m*n!=c*r)
            return mat;
        vector<vector<int>> res(r,vector<int>(c));
        int idx = 0;
        for(int i = 0; i < r; ++i){
            for(int j = 0; j < c; ++j){
                res[i][j] = mat[idx/n][idx%n];
                ++idx;
            }
        }
        return res;
    }
};

【575】【. 分糖果】：https://leetcode-cn.com/problems/distribute-candies/
class Solution {
public:
    int distributeCandies(vector<int>& candyType) {
        unordered_map<int,int> ump;
        for(int& x:candyType)
            ++ump[x];
        return min(candyType.size()/2,ump.size());
    }
};

【5】【. 最长回文子串】：https://leetcode-cn.com/problems/longest-palindromic-substring/
class Solution {
public:
    string longestPalindrome(string s) {
        int sz = s.size();
        int start = 0,end = 0; 
        for(int i = 0; i < sz; ++i){
            auto [left1,right1] = expand(s,i,i);
            auto [left2,right2] = expand(s,i,i+1);
            if(right1-left1 > end-start)
                end = right1, start = left1;
            if(right2-left2 > end-start)
                end = right2, start = left2;
        }
        return s.substr(start,end-start+1);
    }
private:
    pair<int,int> expand(const string& s, int left, int right){
        int sz = s.size();
        while(left>=0 && right<sz && s[left]==s[right])
            --left,++right;
        return {left+1,right-1};
    }
};

【71】【. 简化路径】：https://leetcode-cn.com/problems/simplify-path/
class Solution {
public:
    string simplifyPath(string path) {
        deque<string> dq;
        int left = 1;
        int sz = path.size();
        for(int i = 1; i < sz; ++i){
            while(i <sz && path[i] != '/')
                ++i;
            string tmp = path.substr(left,i-left);
            if(tmp == ".."){
                if(!dq.empty())
                    dq.pop_back();
            }
            else if(tmp != "." && tmp!="")
                dq.push_back(tmp);
            left = i + 1;  
        }
        string res;
        while(!dq.empty()){
            res += "/";
            res += dq.front();
            dq.pop_front();
        }
        return res==""?"/":res;
    }
};

【56】【. 合并区间】：https://leetcode-cn.com/problems/merge-intervals/
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if(!intervals.size())
            return res;
        sort(intervals.begin(), intervals.end());
        int sz = intervals.size();
        res.push_back(intervals[0]);
        for(int i = 1; i < sz; ++i){
            int left = intervals[i][0], right = intervals[i][1];
            if(left > res.back()[1])
                res.push_back(intervals[i]);
            else
                res.back()[1] = max(right, res.back()[1]);
        }
        return res;
    }
};

【6.】【 Z 字形变换】：https://leetcode-cn.com/problems/zigzag-conversion/
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows==1)
            return s;
        vector<string> tmp(numRows,"");
        int row = 0;
        int dir = 1;
        for(auto& c: s){
            tmp[row] += c;
            row += dir;
            if(row == numRows)
                row -= 2, dir = -1;
            else if(row == -1)
                row = 1, dir = 1;
        }
        string res;
        for(auto& str:tmp)
            res += str;
        return res; 
    }
};

【16.】【 最接近的三数之和】：https://leetcode-cn.com/problems/3sum-closest/
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int pre = 1e7;
        int sz = nums.size();
        for(int i = 0; i < sz; ++i){
            if(i>0 && nums[i-1]==nums[i])
                continue;
            int left = i+1, right = sz-1;
            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == target)
                    return sum;
                Update(sum, pre, target);
                if(sum > target){
                    int k = right - 1;
                    while(k>left && nums[k]==nums[right])
                        --k;
                    right = k;
                }else{
                    int k = left + 1;
                    while(k<right && nums[k]==nums[left])
                        ++k;
                    left = k;
                }
            }
        }
        return pre;
    }
private:
    void Update(const int& cur, int& pre, const int& target){
        if(abs(target-cur)<abs(target-pre))
            pre = cur;
    }
};

【22.】【 括号生成】：https://leetcode-cn.com/problems/generate-parentheses/comments/
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        string tmp;
        BackTrack(0, 0, tmp, n);
        return res;
    }
private:
    void BackTrack(int left, int right, string& tmp, const int& n){
        if(tmp.size() == 2*n){
            res.push_back(tmp);
            return;
        }
        if(left<n){
            tmp += '(';
            BackTrack(left + 1, right, tmp, n);
            tmp.pop_back();
        }
        if(right < left){
            tmp += ')';
            BackTrack(left, right + 1, tmp, n);
            tmp.pop_back();
        }
    }
private:
    vector<string> res;
};

【40】【. 组合总和 II】：https://leetcode-cn.com/problems/combination-sum-ii/
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        Target = target;
        sz = candidates.size();
        vector<int> tmp;
        vector<bool> used(sz, false);
        BackTrack(candidates, used, 0, 0, tmp);
        return res;
    }
private:
    void BackTrack(const vector<int>& nums,vector<bool> used, int idx, int sum,vector<int> tmp){
        if(sum == Target){
            res.push_back(tmp);
            return;
        }
        for(int i = idx; i < sz; ++i){
            if(i>0 && nums[i-1]==nums[i] && !used[i-1])
                continue;
            sum += nums[i];
            if(sum > Target)
                return;
            tmp.push_back(nums[i]);
            used[i] = true;
            BackTrack(nums, used, i + 1, sum, tmp);
            tmp.pop_back();
            sum -= nums[i];
            used[i] = false;
        }
    }
private:
    vector<vector<int>> res;
    int Target;
    int sz;
};

【216】【. 组合总和 III】：https://leetcode-cn.com/problems/combination-sum-iii/
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> tmp;
        BackTrack(1, 0, tmp, k, n);
        return res;
    }
private:
    void BackTrack(int idx, int sum, vector<int> tmp, int k, const int& n){
        if(sum==n && k==0){
            res.push_back(tmp);
            return;
        }
        for(int i = idx; i < 10; ++i){
            sum += i;
            if(sum > n)
                return;
            --k;
            tmp.push_back(i);
            BackTrack(i + 1, sum, tmp, k, n);
            ++k;
            sum -= i;
            tmp.pop_back();
        }
    }
private:
    vector<vector<int>> res;
};

【剑指 Offer II 080】【. 含有 k 个元素的组合】：https://leetcode-cn.com/problems/uUsW3B/
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<int> tmp;
        BackTrack(1, k, tmp, n);
        return res;
    }
private:
    void BackTrack(int idx, int k, vector<int> tmp, const int& n){
        if(k==0){
            res.push_back(tmp);
            return;
        }
        for(int i = idx; i <= n; ++i){
            tmp.push_back(i);
            --k;
            BackTrack(i+1, k, tmp, n);
            ++k;
            tmp.pop_back();
        }
    }
private:
    vector<vector<int>> res;
};

【377.】【 组合总和 Ⅳ】：https://leetcode-cn.com/problems/combination-sum-iv/
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
       vector<int> dp(target + 1);
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int& num : nums) {
                if (num <= i && dp[i - num] < INT_MAX - dp[i]) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
};

【45】【. 跳跃游戏 II】：https://leetcode-cn.com/problems/jump-game-ii/
class Solution {
public:
    int jump(vector<int>& nums) {
        int sz = nums.size();
        int end = 0;
        int maxpos = 0;
        int step = 0;
        for(int i = 0; i < sz-1; ++i){
            maxpos = max(maxpos,i + nums[i]);
            if(i == end){
                end = maxpos;
                ++step;
            }
        }
        return step;
    }
};

【57】【. 插入区间】：https://leetcode-cn.com/problems/insert-interval/
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        int sz = intervals.size();
        int pos = SeekInsertPos(intervals,newInterval);
        intervals.insert(intervals.begin()+pos, 1, newInterval);
        vector<vector<int>> res;
        res.push_back(intervals[0]);
        for(int i = 1; i <= sz; ++i){
            int left = intervals[i][0];
            int right = intervals[i][1];
            if(left<=res.back()[1])
                res.back()[1] = max(res.back()[1], right);
            else
                res.push_back(intervals[i]);
        }
        return res;
    }
private:
    int SeekInsertPos(vector<vector<int>>& intervals, vector<int>& newInterval){
        if(intervals.size()==0)
            return 0;
        int left = 0;
        int right = intervals.size()-1;
        while(left<right){
            int mid = (left+right)/2;
            if(intervals[mid][0]==newInterval[0])
                return mid;
            else if(intervals[mid][0]>newInterval[0])
                right = mid - 1;
            else
                left = mid + 1;
        }
        if(intervals[left][0]<newInterval[0])
            return left+1;
        return left;
    }
};

【79】【. 单词搜索】：https://leetcode-cn.com/problems/word-search/
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        if(m==n && n==word.size() && n==1 && word[0]==board[0][0])
            return true;
        wd = word;
        vector<vector<bool>> used(m,vector<bool> (n, false));
        for(int i = 0 ; i < m; ++i){
            for(int j = 0 ; j < n; ++j){
                if(board[i][j] == word[0]){
                    flag = false;
                    used[i][j] = true;
                    BackTrack(i, j, 1, board, used);
                    if(flag)
                        return true;
                    used[i][j] = false;
                }
            }
        }
        return false;
    }
private:
    void BackTrack(int x, int y, int idx, const vector<vector<char>>& board,vector<vector<bool>>& used){
        if(idx == wd.size()){
            flag = true;
            return;
        }
        for(int i = 0; i < 4; ++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0 || nx>=m || ny<0 || ny>=n || used[nx][ny] || board[nx][ny]!=wd[idx])
                continue;
            used[nx][ny] = true;
            BackTrack(nx, ny, idx + 1, board, used);
            used[nx][ny] = false; 
        }
    }
private:
    int m;
    int n;
    string wd;
    bool flag;
    int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};
};

【165.】【 比较版本号】：https://leetcode-cn.com/problems/compare-version-numbers/
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int sz1 = version1.size();
        int sz2 = version2.size();
        int idx1 = 0, idx2 = 0;
        while(idx1<sz1 && idx2<sz2){
            int v1 = vers(idx1,version1);
            int v2 = vers(idx2,version2);
            if(v1>v2)
                return 1;
            else if(v1<v2)
                return -1;
        }
        while(idx1<sz1){
            int v1 = vers(idx1,version1);
            if(!v1)
                continue;
            if(v1)
                return 1;
            else
                return -1;
        }
         while(idx2<sz2){
            int v2 = vers(idx2,version2);
            if(!v2)
                continue;
            if(v2)
                return -1;
            else
                return 1;
        }
        return 0;
    }
private:
    int vers(int& idx, string& version){
        int v = 0;
        int sz = version.size();
        while(idx<sz && version[idx]!='.')
            v = v*10 + (version[idx++] - '0');
        ++idx;
        return v;
    }
};

【81】【. 搜索旋转排序数组 II】：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int sz = nums.size();
        if(!sz)
            return false;
        if(sz == 1 && target == nums[0])
            return true;
        int left = 0;
        int right = sz-1;
        while(left<=right){
            int mid = (left + right)/2;
            if(nums[mid] == target)
                return true;
            if(nums[left]==nums[right] && nums[right]==nums[mid])
                ++left,--right;
            else if(nums[left]<=nums[mid]){
                if(nums[left]<=target && target<nums[mid])
                    right = mid - 1;
                else
                    left = mid + 1;
            }
            else{
                if(nums[mid]<target && target <= nums[sz-1])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return false;
    }
};

【91. 】【解码方法】：https://leetcode-cn.com/problems/decode-ways/
class Solution {
public:
    int numDecodings(string s) {
        int sz = s.size();
        vector<int> dp(sz+1,0);
        dp[0] = 1;
        for(int i = 1; i <= sz; ++i){
            if(s[i-1]!='0')
                dp[i] += dp[i-1];
            if(i>1 && s[i-2]!='0' && ((s[i-2]-'0')*10 + (s[i-1]-'0')<=26))
                dp[i] += dp[i-2];
        }
        return dp[sz];
    }
};

【95】【. 不同的二叉搜索树 II】：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(!n)
            return {};
        return generateTrees(1,n);
    }
private:
    vector<TreeNode*> generateTrees(int start, int end){
        if(start>end)
            return {nullptr};
        vector<TreeNode*> allTree;
        for(int i = start; i <= end; ++i){
            vector<TreeNode*> left = generateTrees(start,i-1);
            vector<TreeNode*> right = generateTrees(i+1,end);
            for(auto& l:left){
                for(auto& r:right){
                    TreeNode* cur = new TreeNode(i);
                    cur->left = l;
                    cur->right = r;
                    allTree.emplace_back(cur);
                }
            }
        }
        return allTree;
    }
};

【剑指 Offer 19】【. 正则表达式匹配】：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        auto matches = [&](int i, int j) {
            if (i == 0) 
                return false;
            if (p[j - 1] == '.') 
                return true;
            return s[i - 1] == p[j - 1];
        };
        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    if (matches(i, j)) 
                        f[i][j] |= f[i - 1][j - 1];
                }
            }
        }
        return f[m][n];
    }
};

【剑指 Offer II 006】【. 排序数组中两个数字之和】：https://leetcode-cn.com/problems/kLl5u1/
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int l = 0, r = numbers.size()-1;
        while(l<r){
            int cur = numbers[l] + numbers[r];
            if(cur == target)
                break;
            else if(cur>target)
                --r;
            else
                ++l;
        }
        return {l,r};
    }
};

【剑指 Offer II 009】【. 乘积小于 K 的子数组】：https://leetcode-cn.com/problems/ZVAVXX/
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        long product = 1;
        int left = 0;
        int ret = 0;
        for (int right = 0; right < nums.size(); ++right) {
            product *= nums[right];
            while (left <= right && product >= k) 
                product /= nums[left++];
            ret += (left <= right) ? right - left + 1 : 0;
        }
        return ret;
    }
};

【279.】【 完全平方数】：https://leetcode-cn.com/problems/perfect-squares/
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1);
        for(int i = 1; i <= n; ++i){
            int top =sqrt(i);
            int m = INT_MAX;
            for(int j = 1; j <= top; ++j)
                m = min(m,dp[i-j*j]);
            dp[i] = 1 + m;
        }
        return dp[n];
    }
};

【284.】【 顶端迭代器】：https://leetcode-cn.com/problems/peeking-iterator/
class PeekingIterator : public Iterator {
public:
	PeekingIterator(const vector<int>& nums) : Iterator(nums) {
	    // Initialize any member here.
	    // **DO NOT** save a copy of nums and manipulate it directly.
	    // You should only use the Iterator interface methods.
	    _next = Iterator::hasNext();
        _val = Iterator::next();
	}
	
    // Returns the next element in the iteration without advancing the iterator.
	int peek() {
       return _val;
	}
	
	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	int next() {
        int cur = _val;
	    _next = Iterator::hasNext();
        if(_next)
            _val = Iterator::next();
        return cur;
	}
	
	bool hasNext() const {
	   return _next;  
	}
private:
    bool _next;
    int _val;
};

【300.】【 最长递增子序列】：https://leetcode-cn.com/problems/longest-increasing-subsequence/
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int sz = nums.size();
        vector<int> dp(sz);
        for(int i = 0; i < sz; ++i){
            dp[i] = 1;
            for(int j = 0; j < i; ++j){
                if(nums[j]<nums[i])
                    dp[i] = max(dp[i],dp[j]+1);
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};

【725.】【 分隔链表】：https://leetcode-cn.com/problems/split-linked-list-in-parts/
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int len = 0;
        ListNode* tmp = head;
        while(tmp!=nullptr){
            tmp = tmp->next;
            ++len;
        }
        int s = len/k;
        int remainder = len%k;
        vector<ListNode*> res(k,nullptr);
        tmp = head;
        for(int i = 0; i < k && tmp!=nullptr; ++i){
            res[i] = tmp;
            ListNode* tail = tmp;
            int l = s + (i<remainder?0:-1);
            while(l>0){
                --l;
                tail = tail->next;
            }
            if(tail != nullptr){
                tmp = tail->next;
                tail->next = nullptr;
            } 
        }
        return res;
    }
};

【146.】【 LRU 缓存机制】：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/
struct DLinkNode{
    int key;
    int val;
    DLinkNode* prev;
    DLinkNode* next;
    DLinkNode():key(0), val(0), prev(nullptr), next(nullptr) {}
    DLinkNode(int _key, int _value): key(_key), val(_value), prev(nullptr), next(nullptr){}
};

class LRUCache {
public:
    LRUCache(int _capacity):capacity(_capacity),size(0) {
        head = new DLinkNode();
        tail = new DLinkNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if(!cache.count(key))
            return -1;
        DLinkNode* tmp = cache[key];
        MovetoHead(tmp);
        return tmp->val;
    }
    
    void put(int key, int value) {
        if(!cache.count(key)){
            DLinkNode* node = new DLinkNode(key, value);
            cache[key] = node;
            AddtoHead(node);
            ++size;
            if(size>capacity){
                DLinkNode* tmp = RemoveTail();
                cache.erase(tmp->key);
                delete tmp;
                --size;
            }
        }else{
            DLinkNode* tmp = cache[key];
            tmp->val = value;
            MovetoHead(tmp);
        }
    }
private:
    void MovetoHead(DLinkNode* node){
        RemoveNode(node);
        AddtoHead(node);
    }
    DLinkNode* RemoveTail(){
        DLinkNode* node = tail->prev;
        RemoveNode(node);
        return node;
    }
    void AddtoHead(DLinkNode* node){
        node->next = head->next;
        node->prev = head;
        node->next->prev = node;
        head->next = node;
    }
    void RemoveNode(DLinkNode* node){
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
private:
    unordered_map<int,DLinkNode*> cache;
    int capacity; 
    int size;
    DLinkNode* head;
    DLinkNode* tail;
};

【430.】【 扁平化多级双向链表】：https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/
class Solution {
public:
    Node* flatten(Node* head) {
        dfs(head);
        return head;
    }
private:
    Node* dfs(Node* head){
        Node* cur = head;
        Node* last = nullptr;
        while(cur!=nullptr){
            Node* next = cur->next;
            if(cur->child){
                Node* last_child = dfs(cur->child);
                next = cur->next;
                cur->next = cur->child;
                cur->child->prev = cur;
                if(next){
                    last_child->next = next;
                    next->prev = last_child;
                }
                cur->child = nullptr;
                last = last_child;
            }
            else
                last = cur;
            cur = next;
        }
        return last;
    }
};

【剑指 Offer II 095.】【 最长公共子序列】：https://leetcode-cn.com/problems/qJnOS7/
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i = 1; i <= m; ++i){
            char c1 = text1[i-1];
            for(int j = 1; j <= n; ++j){
                if(c1 == text2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[m][n];
    }
};

【583.】【 两个字符串的删除操作】：https://leetcode-cn.com/problems/delete-operation-for-two-strings/
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i = 1; i <= m; ++i){
            char c1 = word1[i-1];
            for(int j = 1; j <= n; ++j){
                if(c1 == word2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return m+n-2*dp[m][n];
    }
};

【451】【. 根据字符出现频率排序】：https://leetcode-cn.com/problems/sort-characters-by-frequency/
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char,int> ump;
        for(auto& c:s)
            ++ump[c];
        vector<pair<char,int>> vec(ump.begin(),ump.end());
        sort(vec.begin(),vec.end(),cmp);
        string res;
        for(auto& t:vec)
            for(int i = 0; i < t.second; ++i)
                res += t.first;
        return res;
    }
private:
    static bool cmp(const pair<char,int>& p1,const pair<char,int>& p2){
        return p1.second>p2.second;
    }
};

【42】【. 接雨水】：https://leetcode-cn.com/problems/trapping-rain-water/
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        int left = 0,right = height.size()-1;
        int leftmax = 0,rightmax = 0;
        while(left<right){
            leftmax = max(leftmax,height[left]);
            rightmax = max(rightmax,height[right]);
            if(height[left] < height[right]){
                res += leftmax - height[left];
                ++left;
            }
            else{
                res += rightmax -height[right];
                --right; 
            }
        }
        return res;
    }
};

【639】【. 解码方法 II】：https://leetcode-cn.com/problems/decode-ways-ii/
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        int a=0, b=1, c=0;
        for(int i = 1; i <= n; ++i){
            c = (long long)b*CountOneDigit(s[i-1])%mod;
            if(i>1)
                c = (c + (long long)a*CountTwoDigit(s[i-2],s[i-1])) %mod;
            a = b;
            b = c; 
        }
        return c;
    }
private:
    int CountOneDigit(const char& c){
        if(c == '0')
            return 0;
        return c=='*'?9:1;
    }
    int CountTwoDigit(const char& c1, const char& c2){
        if(c1==c2 && c2=='*')
            return 15;
        if(c1=='*')
            return c2<='6'?2:1;
        if(c2=='*'){
            if(c1=='1')
                return 9;
            else if(c1=='2')
                return 6;
            return 0;                
        }
        return c1!='0' && (c1-'0')*10 + (c2-'0')<=26;
    }
private:
    static const int mod = 1000000007;
};