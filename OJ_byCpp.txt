LeetCode【1】:https://leetcode-cn.com/problems/two-sum/
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int left = 0;
    int right = 0;
    *returnSize = 2;
    int *res = (int *)malloc(sizeof(int)*2);
    for(left = 0;left<numsSize-1;left++){
        for(right=left+1;right<numsSize;right++){
           if(target - nums[left] == nums[right] )
           {
               res[0] = left,res[1] = right;
               return res; 
           }
        }
    }
    return res;
}

LeetCode【27】：https://leetcode-cn.com/problems/remove-element/
int removeElement(int* nums, int numsSize, int val){
    int k = 0,i;
	for (i = 0; i < numsSize; i++) {
		if (nums[i] != val) { //不等的数字覆盖
			nums[k++] = nums[i];
		}
	}
	return k;
}

LeetCode【709】:https://leetcode-cn.com/problems/to-lower-case/
char * toLowerCase(char * str){
    int len = strlen(str);      
    char* dst = (char*)malloc(len + 1);
    char* st = dst;   //保存起始位置
    if (NULL != dst) {
        memset(dst, '\0', len + 1); 
        while (*str) {
            if ((*str >= 'A') && (*str <= 'Z')) {  //只将大写转小写
                *dst = *str + 32;
            }
            else {
                *dst = *str;
            }
            str++;
            dst++;
        }
    }
    return st;
}

LeetCode【189】:https://leetcode-cn.com/problems/rotate-array/
void Reverse(int* nums, int start, int end)
{
    while (start < end) {
        int tmp = nums[end];
        nums[end] = nums[start];
        nums[start] = tmp;
        end--, start++;
    }
}
void rotate(int* nums, int numsSize, int k){
    k %= numsSize;
    Reverse(nums, 0, numsSize - 1);
    Reverse(nums, 0, k - 1);
    Reverse(nums, k, numsSize - 1);
}

LeetCode【35】:https://leetcode-cn.com/problems/search-insert-position/
int searchInsert(int* nums, int numsSize, int target){
    int left = 0;
	int right = numsSize - 1;
	int mid, flag;
	while (left <= right) {
		mid = (left + right) / 2;
		if (nums[mid] > target) {
			right = mid - 1;
			flag = 0; //说明:最后一次right减小引发的循环条件不满足,此时target>nums[right]
		}
		else if (nums[mid] < target) {
			left = mid + 1;
			flag = 1;//说明:最后一次left增大引起的循环条件不满足,此时target<nums[left]
		}
		else {
			return mid;//target存在与nums中且被找到
		}
	}
	return  flag == 0 ? right + 1 : left; //target比nums[left-1]大，但比nums[left]小，所以插的位置就是left
}

LeetCode【383】:https://leetcode-cn.com/problems/ransom-note/
bool canConstruct(char* ransomNote, char* magazine) {
    int num1[26] = {0};
    int num2[26] = {0};
    int k1 = strlen(ransomNote);
    int k2 = strlen(magazine);
    for(int i=0;i<k1;i++){
        num1[ransomNote[i]-'a']++;
    }
    for(int i=0;i<k2;i++){
        num2[magazine[i]-'a']++;
    }
    for(int i = 0;i<26;i++){
        if(num1[i]>num2[i]){
            return false;
        }
    }
    return true;
}

LeetCode【9】:https://leetcode-cn.com/problems/palindrome-number/
int LenofNum(int x)
{
    int cnt = 1;
    while (x /= 10) {
        cnt++;
    }
    return cnt;
}
int isPalindrome(int x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) { //负数及个位为0的非0数必不是回文数
        return false;
    }
    int k = LenofNum(x);
    for (int i = 0; i < k / 2; i++) {//计算一半就行
        int h = x / (int)pow(10, k - i - 1) % 10;  //获取高位数字
        int l = x / (int)pow(10, i) % 10;//获取低位数字
            if (h != l) {
                return false;
            }
    }
    return true;
}

LeetCode【58】:https://leetcode-cn.com/problems/length-of-last-word/
int lengthOfLastWord(char * s){
   int len = strlen(s), lastWordLen = 0;
    if (len == 0) return 0;

    for (int i = len - 1; i >= 0; i--) {
        if (s[i] != ' ') lastWordLen++;
        if (s[i] == ' ' && lastWordLen > 0) break;
    }

    return lastWordLen;
}

LeetCode【88】:https://leetcode-cn.com/problems/merge-sorted-array/
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    m--;
    n--; 
    for (int t = nums1Size - 1; t >= 0 && n >= 0 ; t--) {
        if (m < 0) { 
            nums1[t] = nums2[n--];
        }
        else{
            nums1[t] = nums2[n] > nums1[m] ? nums2[n--] : nums1[m--];
        }
    }
}

LeetCode【217】:https://leetcode-cn.com/problems/contains-duplicate/
int Cmp(const void* a,const void* b)
{
    return *(int*)a-*(int*)b;
}
bool containsDuplicate(int* nums, int numsSize){
    if(numsSize<=1)
        return false;
    else{
        qsort(nums,numsSize,sizeof(int),Cmp);
        for(int i = 0;i<numsSize-1;i++){
            if(nums[i]==nums[i+1])
            return true;
        }
    }
    return false;
}

LeetCode【925】:https://leetcode-cn.com/problems/long-pressed-name/
bool isLongPressedName(char * name, char * typed){
    int n = strlen(name);
    int m = strlen(typed);
    int i=0,j=0;
     while (j < m) {
        if (i < n && name[i] == typed[j]) {//一样则同时后移
            i++;
            j++;
        } else if (j > 0 && typed[j] == typed[j - 1]) {//不一样，但属于长按导致1
            j++;
        } else {//不对
            return false;
        }
    }
    return i == n;
}

LeetCode【977】:https://leetcode-cn.com/problems/squares-of-a-sorted-array/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    int* p =(int*)malloc(sizeof(int)*numsSize);
    int end = numsSize - 1;
    int start = 0;
    int i = end;
    while(start<=end){
        if(abs(nums[start])>=abs(nums[end]))
            p[i--] = pow(nums[start++],2);
        else
            p[i--] = pow(nums[end--],2);
    }
    *returnSize = numsSize;
    return p;
}

LeetCode【917】:https://leetcode-cn.com/problems/reverse-only-letters/
char * reverseOnlyLetters(char * S){
        int len = strlen(S);
    if (len <= 1)
        return S;
    char* str = (char*)malloc(len + 1);
    str[len] = '\0';
    char* stack = (char*)malloc(len + 1);
    int top = 0;
    int i = 0;
    while (i < len) {
        if (isalpha(S[i])) {
            stack[top++] = S[i];
        }
        i++;
    }
    i = 0;
    while (i < len) 
        str[i++] = isalpha(S[i]) ? stack[--top] : S[i];
    return str;
}

LeetCode【905】:https://leetcode-cn.com/problems/sort-array-by-parity/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortArrayByParity(int* A, int ASize, int* returnSize) {
    int left = 0;
    int right = ASize - 1;
    while (left <= right) {
        while (left<=right && !(A[left] % 2))
            left++;
        while (left<=right && A[right] % 2)
            right--;
        if (left <= right) {
            int tmp = A[left];
            A[left] = A[right];
            A[right] = tmp;
        }
    }
    *returnSize = ASize;
    return A;
}
LeetCode【724】:https://leetcode-cn.com/problems/find-pivot-index/
int pivotIndex(int* nums, int numsSize) {
    int sum = 0;
    int sumleft = 0;
    for (int i = 0; i < numsSize; i++) 
        sum += nums[i];
    for(int i = 0;i<numsSize;i++){
        if(2*sumleft+nums[i]==sum)
            return i;
        sumleft+=nums[i];
    }
    return -1;
}

LeetCode【66】:https://leetcode-cn.com/problems/plus-one/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* plusOne(int* digits, int digitsSize, int* returnSize){
    int * res = (int *)malloc(sizeof(int)*(digitsSize+1));
    int flag = 0;
    res[0] = 0;
    for(int i = digitsSize - 1;i>=0;i--){
        if(i==digitsSize - 1)
            res[i+1] = digits[i] + 1;
        else
            res[i+1] = digits[i]+flag;
        res[i+1]>9?(res[i+1]%=10,flag = 1):(res[i+1],flag=0);
    }
    res[0]+=flag;
    *returnSize = res[0]==0?digitsSize:digitsSize+1;
    return res[0]==0?res+1:res;
}

LeetCode【414】:https://leetcode-cn.com/problems/third-maximum-number/
int thirdMax(int* nums, int numsSize){
    if(1 == numsSize)
        return nums[0];
    else if(2 == numsSize)
        return nums[0]>nums[1]?nums[0]:nums[1];
    else{
        long first = LONG_MIN,second = LONG_MIN,third = LONG_MIN;
        for(int i = 0;i<numsSize;i++){
            if(nums[i]==third||nums[i]==second||nums[i]==first)
                continue;
            if(nums[i]>first){
                third = second;
                second = first;
                first = nums[i];
            }else if(nums[i]>second&&nums[i]<first){
                third = second;
                second = nums[i];
            }else if(nums[i]>third&&nums[i]<second)
                third = nums[i];
        }     
        return third==LONG_MIN?first:third;
    }
}

LeetCode【8】【字符串转数字】：https://leetcode-cn.com/problems/string-to-integer-atoi/
int myAtoi(char * s){
	char *ptr = s;
    int flag = 1;
    long int res = 0;
    while((*ptr) == ' ')
        ptr++;
    if(*ptr == '-'){
        flag = -1;
        ptr++;
    }else if(*ptr == '+'){
        flag = 1;
        ptr++;
    }
    while(isdigit(*ptr)){
        res=(res*10+*ptr-'0');
        if((int)res != res)
            break;
        ptr++;
    }
    if(isdigit(*ptr))
        if(flag == -1)
            return INT_MIN;
        else
            return INT_MAX;
    return res*flag;
}

LeetCode【34】【寻找目标数字的索引】：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
int* searchRange(int* nums, int numsSize, int target, int* returnSize){
    *returnSize = 2;
    int* res =(int*)malloc(sizeof(int)*2);
    res[0]=res[1]=-1;
    int left = 0,right = numsSize - 1;
    while(left<=right){//先找到target
        int mid = (left+right)>>1;
        if(nums[mid]>target)
            right = mid - 1;
        else if(nums[mid]<target)
            left = mid + 1;
        else{
            left = right = mid;//向两边找
            while(left - 1>=0 && !(nums[left-1]^target))
                left--;
             while(right + 1<=numsSize - 1 && !(nums[right+1]^target))
                right++;
            res[0] = left,res[1] = right;
            break;
        }
    }
    return res;
}

LeetCode【125】【验证回文字符串】:https://leetcode-cn.com/problems/valid-palindrome/
bool isPalindrome(char * s){
    int n = strlen(s);
    int left = 0;
    int right = n-1;
    while(left<=right){
        if(!isalnum(s[left])){
            left++;
            continue;
        }
        while(!isalnum(s[right])){
            right--;
            continue;
        }
        if(tolower(s[left]) != tolower(s[right]))
            return false;
        left++,right--;
    }
    return true;
}

LeetCode【443】【压缩字符串】：https://leetcode-cn.com/problems/string-compression/
static int _len(int k)
{
    int cnt = 1;
    while(k/=10)
        cnt++;
    return cnt;
}
int compress(char* chars, int charsSize){
    if(charsSize<2)//不需要压缩
        return charsSize;
    int follow = 0;
    int pre = 0;
    int t = 0;
    while(pre<charsSize){
        while(pre<charsSize&&chars[follow]==chars[pre])//出此循环说明pre已到下一个字符
            pre++;
        chars[t] = chars[follow];//将字符填入
        t++;
        int k = pre - follow;//计算与chars[follow]相同字符的数目
        int nums = _len(k);//获取k的位数
        while(k>1&&nums)//只有个数大于1才能填入计数
            chars[t++] = k/(int)pow(10,--nums)%10+'0';//分数位填入
        if(pre<charsSize)//字符数组未遍历完
            follow = pre;
        else //遍历完
            break;
    }
    return t;
}
LeetCode【150】【根据逆波兰表示法，求表达式的值】：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/
int evalRPN(char ** tokens, int tokensSize){
    int* stack = (int*)malloc((tokensSize/2+1)*sizeof(int));
    int top = -1;
    int n1 = 0,n2 = 0;
    for(int i = 0;i<tokensSize;i++){
        if(!strcmp(tokens[i],"+")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 + n2; 
        }
        else if(!strcmp(tokens[i],"*")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 * n2; 
        }    
        else if(!strcmp(tokens[i],"-")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n2 - n1; 
        }     
        else if(!strcmp(tokens[i],"/")){
             n1 = stack[top--],n2 = stack[top--];
             stack[++top] = n2 / n1; 
        }
        else
            stack[++top] = atoi(tokens[i]);//字符转数字
    }
    return stack[top];
}

LeetCode【38】【外观数列】：https://leetcode-cn.com/problems/count-and-say/
char * countAndSay(int n){
    int size = 10000;
    char* strold = (char*)malloc(size);
    char* strnew = (char*)malloc(size);
    memset(strold,'\0',size),memset(strnew,'\0',size);
    strold[0] = '1';
    int cnt = 0;
    int k = 0;
    char *ptr = strold;
    while(--n){
        while(*ptr){
            cnt = 0;
            char key = *ptr;
            while(*ptr && *ptr == key)
                cnt++,ptr++;
            strnew[k++] = cnt + '0';
            strnew[k++] = key;
        }
        memcpy(strold,strnew,strlen(strnew));
        memset(strnew,'\0',strlen(strnew));
        ptr = strold;
        k = 0;
    }
    return strold;
}

【剑指Offer21】【调整数组顺序使奇数位于偶数之前】：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/
int* exchange(int* nums, int numsSize, int* returnSize){
    int left = 0,right = numsSize - 1;
    *returnSize = numsSize;
    while(left < right){
        while(left < right && nums[left]%2)
            left++;
        while(right>left && !(nums[right]%2))
            right--;
        int tmp = nums[left];
        nums[left] = nums[right];
        nums[right] = tmp;
    }
    return nums;
}

LeetCode【167】【两数之和】：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/
int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(2*sizeof(int));
    res[0]=-1,res[1]=-1;
    int left = 0,right = numbersSize - 1;
    while(left<right){
        if(numbers[left]+numbers[right]>target)
            right--;
        else if(numbers[left]+numbers[right]<target)
            left++;
        else{
            res[0]=left+1,res[1]=right+1;
            break;
        }
    }
    return res;
}

LeetCode【168】【Excel表列名称】：https://leetcode-cn.com/problems/excel-sheet-column-title/
char * convertToTitle(int n){
    int size = 10000;
    char* res = (char*)malloc(size);
    int i = 0;
    memset(res,'\0',size);
    while(n){
        n-=1;
        int c = n%26;
        res[i++] = c  + 'A';
        n/=26;
    } 
    int len = strlen(res);
    int half = len/2;
    i = 0;
    while(i<half){
        char tmp = res[len - i - 1];
        res[len - i - 1] = res[i];
        res[i] = tmp;
        i++;
    }
    return res;
}

LeetCode【171】【Excel表列序号】：https://leetcode-cn.com/problems/excel-sheet-column-number/
int titleToNumber(char * s){
    int res = 0;
    int len = strlen(s);
    int i = len - 1;
    while(i > -1){
        res += (int)(*s - 64)*(int)pow(26,i);
        s++;
        i--;
    }
    return res;
}

LeetCode【112】【路径总和】：https://leetcode-cn.com/problems/path-sum/
bool IsEuqal(struct TreeNode* root,int target,int sum){
    if(NULL == root)
        return false;
    sum += root->val;
    if(sum == target && root->left == NULL && root->right == NULL)
        return true;
    return IsEuqal(root->left,target,sum) || IsEuqal(root->right,target,sum);
}
bool hasPathSum(struct TreeNode* root, int targetSum){
    int sum = 0;
    return IsEuqal(root,targetSum,0);
}

LeetCode【121】【买卖股票的最佳时机I】：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int buy = 0;
    int profit =0;
    int i = 0;
    while(i < pricesSize){
        buy = prices[i]<prices[buy]?i:buy;
        profit = profit>(prices[i]-prices[buy])?profit:prices[i]-prices[buy];
        i++;
    }
    return profit;
}

LeetCode【122】【买卖股票的最佳时机II】
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int profit = 0;
    for(int i = 1;i<pricesSize;i++){
        profit += fmax(0,prices[i]-prices[i-1]);
    }
    return profit;
}

LeetCode【258】【各位相加】：https://leetcode-cn.com/problems/add-digits/
int addDigits(int num){
    if(num < 10)
        return num;
    else{
        int res = 0;
        while(num){
            res += (num%10);
            num/=10;
        }
        num = addDigits(res);
        return num; 
    }
}

【剑指Offer58-II】【左旋转字符串】：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/
char* reverseLeftWords(char* s, int n){
    int len = strlen(s);
    char* res = (char*)malloc(len + 1);
    char* p = res;
    memset(res,'\0',len + 1);
    n = n % len;
    char* tmp = s + n;
    strcpy(p,tmp);
    while(*p)
        p++;
    while(n--){
        *p = *s;
        s++,p++;
    }
    return res;
}

【剑指Offer28】【对称的二叉树】：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/
bool _Issymmetric(struct TreeNode* p,struct TreeNode* q)
{
    if(NULL == p && NULL == q)
        return true;
    if(NULL == p || NULL == q)
        return false;
    return (p->val == q->val) && _Issymmetric(p->left,q->right) && _Issymmetric(p->right,q->left);
}
bool isSymmetric(struct TreeNode* root){
    if(NULL == root)
        return true;
    return _Issymmetric(root->left,root->right);
}

【剑指Offer52】【两个链表的第一个公共节点】：https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode* A = headA;
    struct ListNode* B = headB;
    while(A != B){
        if(A == NULL)
            A = headB;
        else
            A = A->next;
        if(B == NULL)
            B = headA;
        else
            B = B->next;
    }
    return A;
}

【剑指Offer26】【树的子结构】：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
bool IsSame(struct TreeNode* p,struct TreeNode* q){
    if(q == NULL)
        return true;
    if(p == NULL)
        return false;
    return (p->val == q->val) && IsSame(p->left,q->left) && IsSame(p->right,q->right);
}
bool isSubStructure(struct TreeNode* A, struct TreeNode* B){
    if(A == NULL || B == NULL)
        return false;
    if(IsSame(A,B))
        return true;
    return isSubStructure(A->left,B) || isSubStructure(A->right,B);
}

【剑指offer22】【链表中倒数第K个节点】：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
【方法1】
int LenofList(struct ListNode* head){
    int n = 0;
    while(head){
        head = head->next;
        n++;
    }
    return n;
}
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    int len = LenofList(head);
    if(k > len)
        return NULL;
    while(len != k){
        head = head->next;
        len--;
    }
    return head;
}
【方法2】：双指针
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    struct ListNode* pre = head;
    while(k && pre != NULL){
        pre = pre->next;
        k--;
    }
    while(pre != NULL){
        pre = pre->next;
        head = head->next;
    }
    return k==0?head:pre;
}

【LCP01】【猜数字】：https://leetcode-cn.com/problems/guess-numbers/
int game(int* guess, int guessSize, int* answer, int answerSize){
    int cnt = 0;
    for(int i = 0;i<guessSize;i++)
       cnt += (guess[i]==answer[i]?1:0);
    return cnt;
}

【LCP18】【早餐组合】：https://leetcode-cn.com/problems/2vYnGI/
void ShellInsert(int *a,int dk,int size){
    for(int i = dk;i < size;i++){
        int temp = a[i];
        int j = 0;
        for(j = i - dk;j >= 0 && temp < a[j];j-=dk)
            if(temp < a[j])
                a[j+dk] = a[j];
        a[j+dk] = temp;
    }
}
void Sort(int* a,int size){
    int dk = size;
    while(dk/=2)
        ShellInsert(a,dk,size);
}
int breakfastNumber(int* staple, int stapleSize, int* drinks, int drinksSize, int x){
   Sort(drinks,drinksSize);
   int cnt = 0;
   for(int i = 0;i < stapleSize; i++){
        int left = 0,right = drinksSize - 1,mid = 0;
        while(left <= right){
            mid = (left+right)>>1;
            int tmp = staple[i]+drinks[mid];
            if(tmp>x)
                right = mid - 1;
            else
                left = mid + 1;
        }
        cnt += left;
        cnt %= 1000000007; 
   }
   return cnt;
}

LeetCode【107】【二叉树的层序遍历】：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/
int Height(struct TreeNode* root){
     if(NULL == root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r; 
 }
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
        if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = Height(root);//树深
    int** levelorder = (int**)malloc(sizeof(int*)*h);//开辟空间，存储数组指针
    *returnSize = h;//数组指针的数目 = 树深
    *returnColumnSizes =  (int *)malloc(sizeof(int)*h);//
    
    struct TreeNode*q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root;
    q1_size++;
    int level = 0;
    while(level<h){
        levelorder[h-1-level] = (int *)malloc(sizeof(int)*q1_size);
        for(int i = 0;i<q1_size;i++)
            levelorder[h-1-level][i] = q1[i]->val;
        (*returnColumnSizes)[h-1-level] = q1_size;
        for(int i = 0;i<q1_size;i++){//q1里的左右孩子存入q2，获得下一层数据
            if(q1[i]->left != NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right != NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        level++;
    }
    return levelorder;
}

LCP【16】【速算机器人】：https://leetcode-cn.com/problems/nGK0Fy/
int calculate(char* s){
    int x = 1,y = 0;
    while(*s){
        if(*s == 'A')
            x = 2*x + y;
        else
            y = 2*y + x;
        s++;
    }
    return x+y;
}

LCP【11】【期望个数统计】：https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji/
void Sort(int* scores,int num){
    int dk = num;
    while(dk/=2){
        for(int i = dk;i<num;i++){
            int tmp = scores[i];
            if(tmp<scores[i-dk]){
                int j = 0;
                for(j=i-dk;j>=0&&tmp<scores[j];j-=dk)
                    scores[j+dk]=scores[j];
                scores[j+dk] = tmp;
            }
        }
    }
}
int expectNumber(int* scores, int scoresSize){
    int cnt = 1;
    Sort(scores,scoresSize);
    for(int i = 1;i<scoresSize;i++){
        if(scores[i]!=scores[i-1])
            cnt+=1;
    } 
    return cnt;
}

LCP【06】【拿硬币】：https://leetcode-cn.com/problems/na-ying-bi/
int minCount(int* coins, int coinsSize){
    int cnt = 0;
    for(int i = 0;i<coinsSize;i++)
        cnt += coins[i]%2?(coins[i]/2+1):(coins[i]/2);
    return cnt;
}

LCP【02】【分式化简】：https://leetcode-cn.com/problems/deep-dark-fraction/
int* fraction(int* cont, int contSize, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    int son = 1; //最后一分数，分子为1
    int mother = cont[contSize-1];//分母为数组最后一个元素
    int tmp = 0;//提供交换功能
    for(int i = contSize - 2;i>=0;i--){
        tmp = mother;//保存上次分母
        mother = mother*cont[i]+son;//计算新分母
        son = tmp;//分子继承tmp
    }
    res[0] = mother;//因为数组首元素计算完成后未发生分子分母交换,此处存储时反序即可
    res[1] = son;
    return res;
}

【剑指offer15】【二进制中1的个数】https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
int hammingWeight(uint32_t n) {
    int cnt = 0;
    for(int i = 0;i<32;i++){
        if((n>>i)&1)
            cnt++;
    }
    return cnt;
}

【剑指offer17】：打印从1到最大的n位数
int* printNumbers(int n, int* returnSize){
    int max = pow(10,n) - 1;
    *returnSize = max;
    int* res = (int*)malloc(sizeof(int)*max);
    for(int i = 0;i < max;i++)
        res[i] = i + 1;
    return res;
}

【LCP22】【黑白方格画】：https://leetcode-cn.com/problems/ccw6C7/
int factorail(int n,int m){
    int son = 1,mother = 1; 
    for(int k = n;k>n-m;k--)
        son*=k;
    for(int k = 1;k<=m;k++)
        mother*=k;
    return son/mother;
}
int paintingPlan(int n, int k){
    if(k==n){
        if(k==1)//n=k=1
            return 1;
        else//n==k!=1
            return 2*n;
    }
    if(k==n*n || k==0)//白板或者黑板
        return 1;
    if(k<n)//一行都画不满，不让进循环，否则浪费空间时间
        return 0;
    int cnt = 0;
    for(int i = 1;i<n;i++){
        int res = k - i*n;
        if(res>0){
            int flag = res%(n-i)==0?res/(n-i)<n?res/(n-i):0:0;
            if(flag)
                cnt+=factorail(n,i)*factorail(n,flag);
        }
        else if(res == 0)
            cnt += 2*factorail(n,i);
        else
            continue;
    }
    return cnt;
}

【剑指Offer18】【删除链表的节点】：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/
struct ListNode* deleteNode(struct ListNode* head, int val){
    if(NULL == head)
        return head;
    struct ListNode* p = head;
    struct ListNode* pre = NULL;
    while(p){
        if(p->val == val && p == head)
            head = p->next;
        else if(p->val == val)
            pre->next = p->next;
        pre = p;
        p=p->next;
    }
    return head;
}

【剑指offer27】【二叉树的镜像】：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/
struct TreeNode* mirrorTree(struct TreeNode* root){
    if(NULL == root)
        return NULL;
    struct TreeNode* tmp = root->right;
    root->right = root->left;
    root->left = tmp;
    mirrorTree(root->left);
    mirrorTree(root->right);
    return root;
}

【剑指offer32】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
int height(struct TreeNode* root){
    if(NULL == root)
        return 0;
    int h_l = height(root->left)+1;
    int h_r = height(root->right)+1;
    return h_l>h_r?h_l:h_r;
 }
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = height(root);
    int** res = (int**)malloc(sizeof(int*)*h);
    *returnSize = h;
    *returnColumnSizes = (int*)malloc(sizeof(int)*h);

    struct TreeNode* q1[1000],*q2[1000];
    int q1_size =0,q2_size=0;
    q1[0]=root;
    q1_size++;
    int layer = 0;
    while(layer<h){
        res[layer] = (int*)malloc(sizeof(int)*q1_size);
        for(int i= 0;i<q1_size;i++)
            res[layer][i] = q1[i]->val;
        (*returnColumnSizes)[layer] = q1_size;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left!=NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right!=NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode *)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        layer++;
    }
    return res;
}

【剑指offer42】:最大子序和
int maxSubArray(int* nums, int numsSize){
    int submax = nums[0];
    int max = nums[0];
    for(int i= 1;i<numsSize;i++){  
        if(submax<0)
            submax = nums[i];
        else  
            submax += nums[i];
        max = submax>max?submax:max; 
    }
    return max;
}

【LeetCode151】【剑指offer58】【翻转单词顺序】：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/
int len = strlen(s);
    if (len == 0)
        return s;
    char* res = (char*)malloc(len + 1);
    memset(res, ' ', len + 1);
    int i = len;
    char* pre = s;
    char* help = NULL;
    char* target = NULL;
    while (*pre) {
        while (*pre && *pre == ' ')//跳空格
            pre++;
        help = pre;//help指向单词首字母
        while (*pre && *pre != ' ')
            pre++;
        target = pre;//target指向单词右侧
        if (*pre == '\0') {//最后一个单词，pre会指向'\0'
            res[i--] = ' ';
            pre--;
        }
        while (help-1 != pre) {//后退式复制带空格
            res[i--] = *pre;
            pre--;
        }
        pre = target;//复制完成pre回到空格处，寻找下一个单词
    }
    res[len] = '\0';//原本此处被放空格
    while (*res == ' ')
        res++;
    return res;
}

LeetCode【202】【快乐数】:https://leetcode-cn.com/problems/happy-number/
int helper(int n){
    int res = 0;
    while(n){
        int tmp = n%10;
        res += tmp*tmp;
        n/=10;
    }
    return res;
}
bool isHappy(int n){
    int slow = n,fast = n;
    do{
        slow = helper(slow);
        fast = helper(helper(fast));
    }while(slow!=fast);
    return slow==1;
}

LeetCode【461】【汉明距离】：https://leetcode-cn.com/problems/hamming-distance/
int hammingDistance(int x, int y){
    int n = x^y;
    int res = 0;
    for(int i = 0;i<32;i++)
        if((n>>i)&1)
            res++;
    return res;
}

LeetCode【415】【字符串相加】：https://leetcode-cn.com/problems/add-strings/
char * addStrings(char * num1, char * num2){
    int len1 = strlen(num1);
    int len2 = strlen(num2);
    char* long_s,*short_s;
    len1>len2?(long_s = num1,short_s = num2):(long_s = num2,short_s = num1);
    len1 = strlen(long_s),len2 = strlen(short_s);
    char* res = (char*)malloc(sizeof(char)*(len1+2));//预留结束符与前导位置
    memset(res,'0',len1+2);
    res[len1+1] = '\0';
    int flag = 0;
    for(int i = len1-1;i>=0;i--){
        int tmp = 0;
        if(i-len1+len2>=0)
            tmp = flag + (long_s[i]-'0')+(short_s[i-len1+len2]-'0');
        else
            tmp = flag + long_s[i]-'0';
        res[i+1]= tmp % 10 + '0';
        if(tmp>9)
            flag = 1;
        else
            flag = 0;
    }
    if(flag == 1)
        res[0]='1';
    else 
        return res + 1;
    return res; 
}

LeetCode【412】【Fizz Buzz】：https://leetcode-cn.com/problems/fizz-buzz/
char ** fizzBuzz(int n, int* returnSize){
    int cnt = 0;
    *returnSize = n;
    char** res = (char**)malloc(sizeof(char*)*n);
    for(int i =1;i<=n;i++){
        if(i%5==0&&i%3==0){
            char* tmp = (char*)malloc(sizeof(char)*9);
            memset(tmp,'\0',9);
            strcat(tmp,"FizzBuzz");
            res[i-1] = tmp;
        }else if(i%5==0){
            char* tmp = (char*)malloc(sizeof(char)*5);
            memset(tmp,'\0',5);
            strcat(tmp,"Buzz");
            res[i-1] = tmp;
        }else if(i%3==0){
            char* tmp = (char*)malloc(sizeof(char)*5);
            memset(tmp,'\0',5);
            strcat(tmp,"Fizz");
            res[i-1] = tmp;
        }else{
            int cnt = 0;
            int num = i;
            while(num){
                cnt++;
                num/=10;
            }
            char* tmp = (char*)malloc(sizeof(char)*(cnt+1));
            memset(tmp,'\0',cnt+1);
            for(int j =0;j<cnt;j++){
                tmp[j] = i/(int)pow(10,cnt-j-1)%10+'0';
            }
            res[i-1] = tmp;
        }
    }
    return res;
}

LeetCode【434】【字符串中的单词数】：https://leetcode-cn.com/problems/number-of-segments-in-a-string/
int countSegments(char * s){
    int cnt = 0;
    char* pre = s;
    while(*pre){
        while(*pre && *pre == ' ')//越过空格
            pre++;
        while(*pre && *pre != ' ')//寻找单词后的空格
            pre++;
        if (*(pre-1)!=' ')
            cnt++;
    }
    return cnt;
}

LeetCode【441】【排列硬币】：https://leetcode-cn.com/problems/arranging-coins/
int arrangeCoins(int n){
    int cnt=0;
    for(int i=1;n>=0;i++){
        n-=i;
        cnt++;
    }
    return cnt-1;
}

LeetCode【448】【找到所有数组中消失的数字】：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){
    int* res = (int*)malloc(sizeof(int)*(numsSize/2));
    int cnt = 0;
    for(int i = 0;i<numsSize;i++){
      if(nums[abs(nums[i])-1]>0)
        nums[abs(nums[i])-1] *= -1;
    }
    for(int i = 0;i<numsSize;i++){
      if(nums[i]>0)
        res[cnt++] = i + 1;
    }    
    *returnSize = cnt;
    return res;
}

LeetCode【409】【最长回文串】：https://leetcode-cn.com/problems/longest-palindrome/
int longestPalindrome(char * s){
    int cnt[128]={0},res = 0;
    for(int i = 0;i<strlen(s);i++)
        cnt[s[i]]++;
    for(int i =0;i<128;i++)
        res += cnt[i]/2*2;
    return res<strlen(s)?res+1:res;
}

LeetCode【404】【左叶子之和】：https://leetcode-cn.com/problems/sum-of-left-leaves/
bool isleaf(struct TreeNode* root){
    return !root->left && !root->right;
}
int dfs(struct TreeNode* root){
    int ans = 0;
    if(root->left)
        ans += isleaf(root->left)?root->left->val:dfs(root->left);
    if(root->right && !isleaf(root->right))
        ans += dfs(root->right);
    return ans;
}
int sumOfLeftLeaves(struct TreeNode* root){
    return root?dfs(root):0; 
}

LeetCode【405】【数字转化为十六进制数】：https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/
char * toHex(int num){
    if(0 == num)
        return "0";
    char *s = "0123456789abcdef";
    int index = 0;
    char* res = (char*)malloc(9);
    memset(res,'0',9);
    res[8] = '\0';
    for(int i = 0;i < 8; i++)
        res[7-i] = s[((unsigned int)num>>4*i)&(0xf)];
    while(*res == '0')
        res++;
    return res;
}

LeetCode【401】【二进制手表】：https://leetcode-cn.com/problems/binary-watch/
int bitnum(int n){
     int cnt = 0;
     while(n){
        if(n&1)
            cnt++;
        n>>=1;
     }
     return cnt;
 }
char ** readBinaryWatch(int num, int* returnSize){
    *returnSize = 0;
     for(int h = 0;h < 12; h++){
        for(int m = 0;m < 60; m++){
            int k = bitnum(h) + bitnum(m);
            if(k == num)
                (*returnSize)++;
        }
    }
    char** res = (char**)malloc(sizeof(char*)*(*returnSize));
    int i = 0;
    for(int h = 0;h < 12; h++){
        for(int m = 0;m < 60; m++){
            int k = bitnum(h) + bitnum(m);
            if(k == num){
                res[i] = (char*)malloc(6);
                sprintf(res[i++],"%d:%02d",h,m);
            }
        }
    }
    return res;
}

LeetCode【231】【2的幂】：https://leetcode-cn.com/problems/power-of-two/
bool isPowerOfTwo(int n){
    return n > 0 && !(n & (n-1));
}

LeetCode【326】【3的幂】：https://leetcode-cn.com/problems/power-of-three/
bool isPowerOfThree(int n){
    if (n < 1)
        return false;
    while(n%3 == 0)
        n/=3;
    return n==1?true:false;
}

LeetCode【342】【4的幂】：https://leetcode-cn.com/problems/power-of-four/
bool isPowerOfFour(int n){
    if(n<1)
        return false;
    while(n%4==0)
        n/=4;
    return n==1?true:false;
}

LeetCode【371】【两整数之和】：https://leetcode-cn.com/problems/sum-of-two-integers/
int getSum(int a, int b){
    while(b!=0){
        int tmp = a^b;
        b = ((unsigned int)(a&b) << 1);
        a = tmp;
    }
    return a;
}

LeetCode【374】【猜数字大小】：https://leetcode-cn.com/problems/guess-number-higher-or-lower/
int guessNumber(int n){
	int low = 1;
    int high = n;
    while(low<=high){
        int mid = low+(high-low)/2;
        int res = guess(mid);
        if(res == 0)
            return mid;
        else if(res < 0)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return -1;
}

LeetCode【389】【找不同】：https://leetcode-cn.com/problems/find-the-difference/
char findTheDifference(char * s, char * t){
    int sn[26]={0};
    int ls = strlen(s),lt = strlen(t);
    for(int i = 0;i<ls;i++)
        sn[s[i]-'a']++;
    for(int i = 0;i<lt;i++){
        sn[t[i]-'a']--;
        if (sn[t[i] - 'a'] < 0) {
            return t[i];
        }
    }
    return ' ';
}

面试题【01.01】【判定字符串是否唯一】：https://leetcode-cn.com/problems/is-unique-lcci/
bool isUnique(char* astr){
    int num[26] = {0};
    int len = strlen(astr);
    for(int i=0;i<len;i++)
        num[astr[i]-'a']++;
    for(int i=0;i<26;i++)
        if(num[i]>1)
            return false;
    return true;
}

面试题【01.02】【判定是否为字符重排】：https://leetcode-cn.com/problems/check-permutation-lcci/
bool CheckPermutation(char* s1, char* s2){
    int nums[26]={0};
    int ls1 = strlen(s1),ls2 = strlen(s2);
    for(int i = 0;i<ls1;i++)
        nums[s1[i]-'a']++;
    for(int i = 0;i<ls2;i++)
        nums[s2[i]-'a']--;
    for(int i = 0;i<26;i++)
        if(nums[i]!=0)
            return false;
    return true;
}

面试题【01.06】【字符串压缩】：https://leetcode-cn.com/problems/compress-string-lcci/
static int _len(int k)
{
    int cnt = 1;
    while(k/=10)
        cnt++;
    return cnt;
}
char* compressString(char* S){
    int charsSize = strlen(S);
    int size = 100000;
    char* chars = (char*)malloc(1000001);
    memset(chars,'\0',size+1);
    int follow = 0;
    int pre = 0;
    int t = 0;
    while(pre<charsSize){
        while(pre<charsSize&&S[follow]==S[pre])//出此循环说明pre已到下一个字符
            pre++;
        chars[t] = S[follow];//将字符填入
        t++;
        int k = pre - follow;//计算与chars[follow]相同字符的数目
        int nums = _len(k);//获取k的位数
        while(nums)//只有个数大于1才能填入计数
            chars[t++] = k/(int)pow(10,--nums)%10+'0';//分数位填入
        if(pre<charsSize)//字符数组未遍历完
            follow = pre;
        else //遍历完
            break;
    }
    return strlen(chars)>=charsSize?S:chars;
}

LeetCode【268】【丢失的数字】：https://leetcode-cn.com/problems/missing-number/
int missingNumber(int* nums, int numsSize){
    int tmp=0;
    for(int i = 0;i<numsSize;i++)
        tmp^=nums[i],tmp^=i;
    for(int i = 0;i<=numsSize;i++)
        tmp ^= i;
    return tmp;
}

LeetCode【242】【有效的字母异位词】：https://leetcode-cn.com/problems/valid-anagram/
bool isAnagram(char * s, char * t){
    int lens = strlen(s);
    int lent = strlen(t);
    if(lens != lent)
        return false;
    int num[26]={0};
    for(int i = 0;i<lens;i++){
            num[s[i]-'a']++;
            num[t[i]-'a']--;
    }
    for(int i = 0;i<26;i++)
        if(num[i]>0)
            return false;
    return true;
}

LeetCode【153】【寻找旋转排序数组的最小值】：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/
int findMin(int* nums, int numsSize){
    int left = 0,right = numsSize - 1;
    while(left<right){
        int mid = left+(right-left)/2;
        if(nums[mid]>nums[right])
            left = mid + 1;
        else
            right = mid;
    }
    return nums[left];
}

剑指offer/LeetCode【11/154】【旋转数组的最小数字】：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/
int minArray(int* numbers, int numbersSize){
    int left = 0,right = numbersSize-1;
    while(left<right){
        int mid=left+(right-left)/2;
        if(numbers[mid]>numbers[right])
            left = mid + 1;
        else if(numbers[mid] == numbers[right])
            right--;
        else
            right = mid;
    }
    return numbers[left];
}

LeetCode【367】【有效的完全平方数】：https://leetcode-cn.com/problems/valid-perfect-square/
bool isPerfectSquare(int num){
    int i = -1;
    while(num>0){
        i+=2;
        num-=i;
    }
    return num==0?true:false;
}

剑指offer【06】【从头到尾打印链表】：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/
int* reversePrint(struct ListNode* head, int* returnSize){
    int len = 0;
    struct ListNode* p = head;
    while(p){
        p = p->next;
        len++;
    }
    *returnSize = len;
    p = head;
    int* res = (int*)malloc(sizeof(int)*len);
    for(int i = len - 1;i>=0;i--){
        res[i] = p->val;
        p = p->next;
    }
    return res;
}

剑指offer【16】【数值的整数次方】：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/
double myPow(double x, int n){
    double res = 1.0;
    long int y = (long int)n;
    if(n<0){
        x= 1.0/x;
        y=-y;
    }
    while(y){
        if(y&1)
            res*=x;
        x*=x;
        y/=2;
    }
    return res;
}

剑指offer【05】【替换空格】：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/
char* replaceSpace(char* s){
    int len = strlen(s);
    char*res = (char*)malloc(sizeof(char)*3*len+1);
    memset(res,'\0',3*len+1);
    int cnt = 0;
    for(int i = 0;i<len;i++){
        if(s[i] == ' '){
            strcat(res,"%20");
            cnt+=3;
        }
        else
            res[cnt++] = s[i];
    }
    return res;
}

剑offer【09】【用两个栈实现队列】：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/
#define NUM 10000
typedef struct {
    int *s1 ;
    int len_s1;
    int *s2;
    int len_s2;
} CQueue;

CQueue* cQueueCreate() {
    CQueue* Q = (CQueue*)malloc(sizeof(CQueue));
    Q->s1 = (int*)malloc(sizeof(int)*NUM);
    Q->s2 = (int*)malloc(sizeof(int)*NUM);
    Q->len_s1 = -1;
    Q->len_s2 = -1;
    return Q;
}

void cQueueAppendTail(CQueue* obj, int value) {
    if(obj->len_s1>=10000)
        return;
    obj->s1[++obj->len_s1] = value;
}

int cQueueDeleteHead(CQueue* obj) {
    if(obj->len_s2 == -1 && obj->len_s1 == -1)
        return;
    if(obj->len_s2 == -1){
        while(obj->len_s1 != -1)
            obj->s2[++obj->len_s2] = obj->s1[obj->len_s1--];
    }
    return obj->s2[obj->len_s2--];
}

void cQueueFree(CQueue* obj) {
    free(obj->s1);
    free(obj->s2);
    obj->s1 = NULL;
    obj->s2 = NULL;
    obj->len_s1 = -1;
    obj->len_s2 = -1;
}

剑指offer【29】【顺时针打印矩阵】：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/
int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    if(matrixSize == 0 || matrixColSize[0] == 0){
        *returnSize = 0;
        return NULL;
    }
    int all = matrixSize*matrixColSize[0];
    int* res = (int*)malloc(sizeof(int)*all);
    *returnSize = all;
    int left = 0,right = matrixColSize[0]-1 ;
    int top = 0,bottom = matrixSize-1;
    int cnt = 0;
    while(cnt<all){
        int l = left,r = right,t = top,b = bottom;
       while(cnt<all && l<=right)
           res[cnt++]=matrix[top][l++];
        t++;
        while(cnt<all && t<=bottom)
            res[cnt++]=matrix[t++][right];
        r--;
        while(cnt<all && r>=left)
            res[cnt++]=matrix[bottom][r--];
        b--;
        while(cnt<all && b>top)
            res[cnt++]=matrix[b--][left];
        left++;
        right--;
        top++; 
        bottom--;
    }
    return res;      
}

LeetCode【392】【判断子序列】：https://leetcode-cn.com/problems/is-subsequence/
bool isSubsequence(char * s, char * t){
    if(NULL == t && NULL == s)
        return true;
    if(NULL == s)
        return true;
    if(NULL == t)
        return false;
    while(*t){
        if(*t == *s)
            s++;
        t++;
    }
    return *s == '\0';
}

LeetCode【400】【第N位数字】：https://leetcode-cn.com/problems/nth-digit/
int helper(long int n){
    int cnt = 0;
    while(n>0){
        n -= 9*(long int)pow(10,cnt)*(cnt+1);
        cnt++;
    }
    return cnt;
}
int findNthDigit(int n){
    int pos = helper(n);//确定处于几位数范围
    int cnt = 0;
    while(cnt < pos - 1)//计算剩余的部分,刨去位数<pos的区间
        n-=(9*(int)pow(10,cnt++)*cnt);
    int start = (int)pow(10,pos-1);//最小的pos位数
    int count = n / pos,res = n % pos; //计算第n个数字位置之前有多少整数及余数
    int flag = res>=1?1:0; 
    int num = start + count - 1 + flag;//计算第n个数字位于哪个数字上
    res = n - (num-start)*pos; //计算位于num的第几位
    return (num/(int)pow(10,pos-res))%10;
}

LeetCode【397】【整数替换】：https://leetcode-cn.com/problems/integer-replacement/
int integerReplacement(int n){
    int cnt = 0;
    while(n>1){
        if(n == INT_MAX)//上界单独处理
            n--,n/=2,n++,cnt++;
        else if(!(n%2))//偶数
            n>>=1;
        else //奇数
            n += ((n & 2) == 0 || n == 3)?-1:1;//0x？？？？？？？[??01]及0x11减1，其他++1；
        cnt++;
    }
    return cnt;
}

LeetCode【2】【两数相加】：https://leetcode-cn.com/problems/add-two-numbers/
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode* addres = NULL;
    struct ListNode* p = addres;
    int flag = 0;
    while(l1||l2){
        int n1 = l1?l1->val:0;
        int n2 = l2?l2->val:0;
        int tmp = n1 + n2 + flag;
        flag = tmp>9?1:0;
        if (!addres){
            p = addres = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->val = tmp%10;
            p->next = NULL; 
        }
        else{
            p->next = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->next->val = tmp%10;
            p->next->next = NULL;
            p = p->next;
        }
        if(l1)
            l1=l1->next;
        if(l2)
            l2=l2->next;
    }
    if(flag > 0){
         p->next = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->next->val = flag;
            p->next->next = NULL;
    }
    return addres;
}

LeetCode【492】【构造矩形】：https://leetcode-cn.com/problems/construct-the-rectangle/
int* constructRectangle(int area, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    int l = sqrt(area);
    while(area%l)
        l++;
    int w = area/l;
    res[0] = l>w?l:w;
    res[1] = l>w?w:l;
    return res;
}

LeetCode【344】【反转字符串】：https://leetcode-cn.com/problems/reverse-string/
void reverseString(char* s, int sSize){
    for(int i = 0;i<sSize/2;i++){
        char tmp = s[sSize-1-i];
        s[sSize-i-1]=s[i];
        s[i] = tmp;
    }
}

LeetCode【263】【丑数】：https://leetcode-cn.com/problems/ugly-number/
bool isUgly(int num){
    if(num<1)
        return false;
    if(1 == num)
        return true;
    while((num != 2) && (num != 3) && (num != 5)){
        if(num%2==0)
        num/=2;
        else if(num%3==0)
            num/=3;
        else if(num%5==0)
            num/=5;
        else
            return false;
    }
    return true;
}

LeetCode【283】【移动0】：https://leetcode-cn.com/problems/move-zeroes/
void moveZeroes(int* nums, int numsSize){
    int left = 0,right = left;
    while(right<numsSize){
        while(left < numsSize - 1  && nums[left] != 0)
            left++;
        right = left + 1;
        while(right < numsSize && nums[right] == 0)
            right++;
        if(right<numsSize){
            nums[left] = nums[right];
            nums[right] = 0;
            left++;
        }
    }
}

LeetCode【303】【区域和检索-数组不可变】：https://leetcode-cn.com/problems/range-sum-query-immutable/
typedef struct {
    int *num;
    int *sum;
} NumArray;

NumArray* numArrayCreate(int* nums, int numsSize) {
    NumArray* res = (NumArray*)malloc(sizeof(NumArray));
        return NULL;
    res->num = nums;
    res->sum = (int *)malloc(sizeof(int)*numsSize);
    int tmp = 0;
    for(int i = 0;i<numsSize;i++){
        res->sum[i] = tmp + res->num[i];
        tmp+=res->num[i];
    }
    return res;
}

int numArraySumRange(NumArray* obj, int i, int j) {
    if(i==0)
        return obj->sum[j];
    return obj->sum[j]-obj->sum[i-1];
}

void numArrayFree(NumArray* obj) {
    free(obj);
}

/**
 * Your NumArray struct will be instantiated and called as such:
 * NumArray* obj = numArrayCreate(nums, numsSize);
 * int param_1 = numArraySumRange(obj, i, j);
 
 * numArrayFree(obj);
*/

剑指offer【14-1】【减绳子】：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/
int cuttingRope(int n){
    if(n==2)
        return 1;
    if(n==3)
        return 2;
    int res = 1;
    while(n){
        if(n==1)
            return res/3*4;
        else if(n==2)
            return res*2;
        else{
            n-=3;
            res*=3;
        }
    }
    return res;
}

LeetCode【349】【两个数组的交集】：https://leetcode-cn.com/problems/intersection-of-two-arrays/
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    Sort(nums1,0,nums1Size);
    Sort(nums2,0,nums2Size);
    int len = nums1Size<nums2Size?nums1Size:nums2Size;
    int * res = (int*)malloc(sizeof(int)*len);
    int cnt =  0;
    int index1 = 0,index2 = 0;
    while(index1<nums1Size&&index2<nums2Size){
        int num1 = nums1[index1],num2 = nums2[index2];
        if(num1 == num2){
            if(cnt == 0 || nums1[index1] != res[cnt-1])
                res[cnt++] = nums1[index1]; 
            index1++;
            index2++;
        }else if(num1<num2)
            index1++;
        else
            index2++;
    }
    *returnSize = cnt;
    return res;
}


LeetCode【350】【l两个数组的交集II】：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/
int QkPass(int* a,int left,int right){
     int low = left,high = right - 1;
     int key = a[low];
     while(low<high){
        while(low<high && a[high]>=key)
            high--;
        a[low] = a[high];
        while(low<high && a[low]<key)
            low++;
        a[high] = a[low];
     }
    a[low] = key;
    return low;
 }
 void Sort(int* a,int left,int right){
     if(left<right){
         int pos = QkPass(a,left,right);
         Sort(a,left,pos);
         Sort(a,pos+1,right);
     }
 }
int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    Sort(nums1,0,nums1Size);
    Sort(nums2,0,nums2Size);
    int len = nums1Size<nums2Size?nums1Size:nums2Size;
    int * res = (int*)malloc(sizeof(int)*len);
    int cnt =  0;
    int index1 = 0,index2 = 0;
    while(index1<nums1Size&&index2<nums2Size){
        int num1 = nums1[index1],num2 = nums2[index2];
        if(num1<num2)
            index1++;
        else if(num1>num2)
            index2++;
        else{
            res[cnt++] = nums1[index1]; 
            index1++;
            index2++;
        }
    }
    *returnSize = cnt;
    return res;
}

剑指offer【48】【最长不含重复字符的子字符串】：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/
int lengthOfLongestSubstring(char* s){
    int len = strlen(s);
    int alpha[128]={0};//标志数组
    char* front = s,*rear = s;
    int cnt = 0;
    int max = 0;
    while(*front){
        if(alpha[*front]==0){//未出现过
            alpha[*front] = 1;
            cnt++;
        }else{
            while(*rear != *front){//出现重复字符
                alpha[*rear]=0;
                rear++;
                cnt--; 
            }
            rear++;
        }
        front++;
        max = max>cnt?max:cnt;
    }
    return max;
}

LeetCode【48】【旋转图像】：https://leetcode-cn.com/problems/rotate-image/
void rotate(int** matrix, int matrixSize, int* matrixColSize){
    for(int i = 0;i<matrixSize/2;i++){
        for(int j = 0;j<(matrixSize+1)/2;j++){
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[matrixSize-1-j][i];
            matrix[matrixSize-1-j][i] = matrix[matrixSize-1-i][matrixSize-1-j];
            matrix[matrixSize-1-i][matrixSize-1-j] = matrix[j][matrixSize-1-i];
            matrix[j][matrixSize-1-i] = tmp;
        }
    }
}

剑指offer【62】【圆圈中最后剩下的数字】：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/
int f(int n,int m){
    int  x = 0;
    if(n == 1)//长度为1，索引为00
        return 0;
    else
        x = f(n-1,m);
    return (m + x) % n; //每次删除一个，0索引处于m+x处，溢出取模 
}
int lastRemaining(int n, int m) {
    return f(n,m);  
}

剑指offer【59-I】【滑动窗口的最大值】：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    if(numsSize == 0){
        *returnSize = 0;
        return NULL;
    }
    *returnSize = numsSize - k + 1;//返数字数目可推导得到
    int* res = (int*)malloc(sizeof(int)*(*returnSize));
    int left = 0,right = k - 1;
    int count = 0;
    int maxindex = 0;
    while(right<numsSize){
        if(maxindex == 0 || maxindex < left){//第一个窗口 || 最大值索引已不在新窗口内
            int j = left;
            maxindex = left;
            while(j<=right){//寻找新的最大值索引
                if(nums[maxindex]<nums[j])
                    maxindex=j;
                j++;
            }
        }else{//最大值索引仍在窗口内
            if(nums[right]>nums[maxindex])//新进窗口的值最大
                maxindex = right;
        }
        res[count++] = nums[maxindex];//最大值写入
        left++,right++; //窗口移动
    }
    return res;
}

【单调队列解法】：
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    if(k == 1){
        *returnSize = numsSize;
        return nums;
    }
    if(numsSize == 0){
        *returnSize = 0;
        return NULL;
    }
    *returnSize = numsSize + 1 - k;
    int* res = (int*)malloc(sizeof(int)*(*returnSize));
    int* deque = (int*)malloc(sizeof(int)*numsSize);//单调队列
    int ql = 0,qr = 0;//队列索引
    int left = 0;//数组索引
    int cnt = 0;
    while(left<numsSize){
        while(ql != qr && nums[left] > nums[deque[qr-1]])//栈尾元素小于将入队元素
            qr--;//之所以是>而不>=，原因在于尽可能令最大值的索引小
        deque[qr++] = left;//入队
        if(left >= k - 1){//窗口
            res[cnt++] = nums[deque[ql]];
            if(ql != qr && deque[ql] <= left -k + 1)
                ql++;
        }
        left++;
    }
    return res;
}

剑指offer【61】【扑克牌中的顺子】：https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/
bool isStraight(int* nums, int numsSize){
    for(int i = 1;i<numsSize;i++){
        if(nums[i]<nums[i-1]){
            int key = nums[i];
            int j = i - 1;
            for( ;j>=0&&nums[j]>key;j--)
                nums[j+1]=nums[j];
            nums[j+1] = key;
        }
    }
    int left = 0;
    for(int i = 0;i<numsSize - 1;i++){
        if(nums[i]==0)//跳过0，并将left定在最小值的索引处
            left++;
        else if(nums[i] == nums[i+1])//前两个重复
            return false;
        else{}
    }
    return nums[numsSize-1]-nums[left]<5?true:false;
}

剑指offer【64】【求1+2+……+n】:https://leetcode-cn.com/problems/qiu-12n-lcof/
int sumNums(int n){
    //-1 & x = x
    //10000的二进制：10 0111 0001 0000，最高位对应2^13
    int n1 = (n&-((n+1)>>0&1))<<0;//n+1的最低位是否为1，为1说明结果里含n
    int n2 = (n&-((n+1)>>1&1))<<1;//n+1的次低位是否位1，为1说明结果里含有2*n
    int n3 = (n&-((n+1)>>2&1))<<2;//n+1的较低位是否位1，为1说明结果里含有4*n
    int n4 = (n&-((n+1)>>3&1))<<3;
    int n5 = (n&-((n+1)>>4&1))<<4;
    int n6 = (n&-((n+1)>>5&1))<<5;
    int n7 = (n&-((n+1)>>6&1))<<6;
    int n8 = (n&-((n+1)>>7&1))<<7;//eg,n=5,result=5*6/2=15
    int n9 = (n&-((n+1)>>8&1))<<8;//6 = 2^1 + 2^2
    int n10 = (n&-((n+1)>>9&1))<<9;//result = (5^1 + 5^2)/2 
    int n11 = (n&-((n+1)>>10&1))<<10;
    int n12 = (n&-((n+1)>>11&1))<<11;
    int n13 = (n&-((n+1)>>12&1))<<12;
    int n14 = (n&-((n+1)>>13&1))<<13;
    //上述过程即把n+1拆分为2的幂和，之后分别与n相乘
    return (n1+n2+n3+n4+n5+n6+n7+n8+n9+n10+n11+n12+n13+n14)>>1;//n*(n+1)/2
}

剑指offer【66】【构建乘积数组】：https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/
int* constructArr(int* a, int aSize, int* returnSize){
    if(aSize==0){
        *returnSize = 0;
        return NULL;
    }
    *returnSize = aSize;
    int* res = (int*)malloc(sizeof(int)*aSize);
    int* left = (int*)malloc(sizeof(int)*aSize);
    int* right = (int*)malloc(sizeof(int)*aSize);
    left[0]=1,right[aSize-1]=1;
    for(int i = 1;i<aSize;i++)
        left[i]=a[i-1]*left[i-1];
    for(int i = aSize - 2;i>=0;i--)
        right[i]=right[i+1]*a[i+1];
    for(int i = 0;i<aSize;i++)
        res[i]=left[i]*right[i];
    return res;
}

面试题【01.04】【回文排列】：https://leetcode-cn.com/problems/palindrome-permutation-lcci/
bool canPermutePalindrome(char* s){
    int cnt[128]={0};
    for(int i = 0;i<strlen(s);i++)
        cnt[s[i]]++;
    int flag = 0;
    for(int i = 0;i<128;i++){
        if(cnt[i]%2)
            flag++;
        if(flag > 1)
            return false;
    }
    return true;   
}

LeetCode【537】【复数乘法】：https://leetcode-cn.com/problems/complex-number-multiplication/
char * complexNumberMultiply(char * a, char * b){
    int x1 = atoi(a),x2 = atoi(b);
    while(*a!='+')
        a++;
    a++;
    while(*b!='+')
        b++;
    b++;
    int y1 = atoi(a),y2=atoi(b);
    int x = x1*x2-y1*y2;//实部
    int y = x1*y2+x2*y1;//虚部
    char *res = (char*)malloc(15);//-10000+-10000i
    sprintf(res,"%d+%di",x,y);
    return res;
} 

LeetCode【520】【检测大写字母】：https://leetcode-cn.com/problems/detect-capital/
bool detectCapitalUse(char * word){
    if('a' <= *word && *word<='z'){//首字母小写
        while(*word){//纯小写
            if('A'<=*word && *word <= 'Z')//出现大写
                return false;
            word++;
        }
    }else{//首字母大写
        word++;//第二个字母
        if('a' <= *word && *word <= 'z'){//第二个字母小写
            while(*word){//纯小写
                if('A' <= *word && *word <= 'Z')//出现大写
                    return false;
                word++;
            }
        }else{//第二个字母大写
            while(*word){//要求纯大写
                if(islower(*word))
                    return false;
                word++;
            }
        }
    }
    return true;
}

LeetCode【540】【有序数组中的单一元素】：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/
int singleNonDuplicate(int* nums, int numsSize){
    int left = 0,right = numsSize-1;
    while(left<right){
        int mid = left + ((right-left)>>1);
        if(mid%2)
            mid--;
        if(nums[mid] == nums[mid+1])
            left = mid + 2;
        else
            right = mid;
    }
    return nums[left];
}

LeetCode【485】【最大连续 1 的个数】：https://leetcode-cn.com/problems/max-consecutive-ones/
int findMaxConsecutiveOnes(int* nums, int numsSize){
    int cnt = 0;
    int max = 0;
    for(int i = 0;i<numsSize;i++){
        if(nums[i]==0){
            max = max>cnt?max:cnt;
            cnt = 0;
        }else
            cnt++;
    }
    return max >cnt?max:cnt;
}

LeetCode【面试题01.08】【零矩阵】：https://leetcode-cn.com/problems/zero-matrix-lcci/
void setZeroes(int** matrix, int matrixSize, int* matrixColSize){
    if(matrixSize == 0 || matrixColSize[0] == 0)
        return;
    int* row = (int*)malloc(sizeof(int)*matrixSize);
    int* col = (int*)malloc(sizeof(int)*matrixColSize[0]);
    memset(row,0,sizeof(int)*matrixSize);
    memset(col,0,sizeof(int)*matrixColSize[0]);
    for(int i = 0;i<matrixSize;i++){
        for(int j = 0;j<matrixColSize[0];j++)
            if(matrix[i][j]==0){
                row[i] = 1;
                col[j] = 1;
            }
    }
    int tmp =0;
    while(tmp<matrixSize){
        if(row[tmp] == 1){
            int j = 0;
            while(j<matrixColSize[0])
                matrix[tmp][j++] = 0;
        }
        tmp++;
    }
    tmp = 0;
    while(tmp<matrixColSize[0]){
        if(col[tmp] == 1){
            int i = 0;
            while(i<matrixSize)
                matrix[i++][tmp] = 0;
        }
        tmp++;
    }
}

剑指offer【56-II】【数组中数字出现的次数II】：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/
int singleNumber(int* nums, int numsSize){
    int dk = numsSize;
    while(dk/=2){
        for(int i = dk;i<numsSize;i++){
            if(nums[i]<nums[i-dk]){
                int tmp = nums[i];
                int j = 0;
                for(j = i-dk;j>=0&&tmp<nums[j];j-=dk)
                    nums[j+dk] = nums[j];
                nums[j+dk] = tmp; 
            }
        }
    }
    for(int i = 0;i<numsSize-1;i+=3)
        if(nums[i]!=nums[i+1])
            return nums[i];
    return nums[numsSize-1];
}

面试题【01.05】【一次编辑】：https://leetcode-cn.com/problems/one-away-lcci/
bool oneEditAway(char* first, char* second){
    int len1 = strlen(first);
    int len2 = strlen(second);
    if(fabs(len1-len2)>1)//三个操作使得两字符串长度差不大于1
        return false;
    if(len1 == len2){//换 or 不变
        int cnt = 0;
        for(int i = 0;i<len1;i++){
            if(first[i]!=second[i])
                cnt++;
            if(cnt>1)
                return false;
        }
    }else{//删
        char* longs = len1>len2?first:second;
        char* shorts = len1>len2?second:first;
        int len = strlen(longs);
        int flag = 1;
        int index1 = 0,index2 = 0;
        while(index1<len){
            if(longs[index1]!=shorts[index2]){
                if(flag){
                    flag = 0;
                    index1++;
                }else
                    return false;
            }else
                index1++,index2++;
        }
    } 
    return true;
}

面试题【01.09】【字符串轮转】：https://leetcode-cn.com/problems/string-rotation-lcci/
bool isFlipedString(char* s1, char* s2){
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    if(len1!=len2)
        return false;
    if((!len1) && len1 == len2)
        return true;
    char *a =(char*)malloc(2*len1+1);
    memset(a,'\0',2*len1+1); 
    strcat(a,s1);
    strcat(a,s1);
    int i = 0;
    while(i<len1){
        if(a[i]==s2[0]){//遇见与s2首字母相同的字母
            char tmp = a[i+len1];//只比较len1长度
            a[i+len1] = '\0';
            if(strcmp(a+i,s2)==0)//是
                return true;
            a[i+len1] = tmp;//否则将字母放回
        }
        i++;//继续向后
    }
    return false;
}

面试题【02.03】【删除中间节点】：https://leetcode-cn.com/problems/delete-middle-node-lcci/
void deleteNode(struct ListNode* node) {
    struct ListNode *p = node->next;
    node->val = p->val;
    node->next = p->next;
    free(p);
}
 
面试题【02.01】【移除重复节点】：https://leetcode-cn.com/problems/remove-duplicate-node-lcci/
struct ListNode* removeDuplicateNodes(struct ListNode* head){
    if(head == NULL || head->next == NULL)//空表或单节点
        return head;
    struct ListNode* rear = head;
    struct ListNode* front = rear->next;
    struct ListNode* t=rear;;
    while(rear){
        while(front&&front->val != rear->val){//出此循环：front == NULL or front->val = rear->val
            t = t->next;
            front = front->next;
        }
        if(front){//重复节点
            t->next = front->next;
            free(front);
            front = t->next;
            continue;//继续向后查找
        }
        rear = rear->next;
        if(rear){
            front = rear->next;
            t = rear;
        }
    }
    return head;
}

面试题【02.02】【返回倒数第k个节点】：https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/
int kthToLast(struct ListNode* head, int k){
    struct ListNode* front = head;
    struct ListNode* rear = head;
    while(k--)
        front = front->next;
    while(front){
        front = front->next;
        rear = rear->next;
    }
    return rear->val;
}

LeetCode【36】【有效的数独】：https://leetcode-cn.com/problems/valid-sudoku/
bool isValidSudoku(char** board, int boardSize, int* boardColSize){
    int* row = (int*)malloc(sizeof(int)*9);
    int* col = (int*)malloc(sizeof(int)*9);
    for(int i = 0;i <9 ;i++){
        memset(row,0,sizeof(int)*9);
        memset(col,0,sizeof(int)*9);
        for(int  j = 0;j<9;j++){//统计数字出现次数
            if(board[i][j]!='.')
                row[board[i][j]-'0'-1]++;
            if(board[j][i]!='.')
                col[board[j][i]-'0'-1]++;
        }
        for(int k = 0;k<9;k++)//检测同一行/同一列是否有重复数字
            if(row[k]>1||col[k]>1)
                return false;
    }
    for(int i = 0;i<9;i++){//i代表子九宫的编号
        int r_min = i/3*3,c_min = i%3*3; //从编号解出子九宫的行列初始值
        memset(row,0,sizeof(int)*9);
        for(int k = r_min;k<r_min+3;k++)//统计子九宫数字出现次数
            for(int t = c_min;t<c_min+3;t++)
                if(board[k][t]!='.')
                    row[board[k][t]-'0'-1]++;
        for(int k = 0;k<9;k++)
            if(row[k]>1)
                return false;
    }
    return true;
}

LeetCode【7】【整数反转】：https://leetcode-cn.com/problems/reverse-integer/
int reverse(int x){
    int res = 0;
    while(x/10){
        res = res*10+x%10;
        x/=10;
    }
    if((res>INT_MAX/10)||((res==INT_MAX/10)&&(x>7)))   
        return 0;
    else if((res<INT_MIN/10)||((res==INT_MIN/10)&&(x<-8)))  
        return 0;
    else    
        return res*10+x;
}

LeetCode【387】【字符串中的第一个唯一字符】：https://leetcode-cn.com/problems/first-unique-character-in-a-string/
int firstUniqChar(char * s){
    int count[26]={0};
    for(int i = 0;i<strlen(s);i++)
        count[s[i]-'a']++;
    char* str = s;
    while(*str){
        if(count[*str-'a']==1)
            return str-s;
        str++;
    }
    return -1;
}

LeetCode【19】【删除链表的倒数第N个节点】：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    int shift = n - 1;
    struct ListNode* pre = head;
    struct ListNode* rear = head;
    struct ListNode* t = head;
    while(shift--)
        pre=pre->next;
    if(!pre->next){
        t = head->next;
        free(head);
        return t;
    }
    while(pre->next){
        pre = pre->next;
        t = rear;
        rear = rear->next;
    }
    t->next=rear->next;
    free(rear);
    return head;
}

LeetCode【278】【第一个错误的版本】：https://leetcode-cn.com/problems/first-bad-version/
int firstBadVersion(int n) {
    int left = 1,right = n;
    while(left<right){
        int mid = left +(right-left)/2;
        if(isBadVersion(mid))
            right = mid;
        else
           left = mid + 1;
    }
    return left;
}

LeetCode【198】【打家劫舍】：https://leetcode-cn.com/problems/house-robber/
int rob(int* nums, int numsSize){
    if(numsSize == 0)
        return 0;
    if(numsSize == 1)
        return nums[0];
    int res[3] = {nums[0],fmax(res[0],nums[1]),0};
    if(numsSize == 2)
        return res[1];
    for(int i = 2;i<numsSize;i++){
        res[2] = fmax(res[1],nums[i]+res[0]);
        res[0]=res[1];
        res[1] = res[2];
    }
    return res[2];
}

LeetCode【213】【打家劫舍II】：https://leetcode-cn.com/problems/house-robber-ii/
int rob(int* nums, int numsSize){
    if(numsSize==1)
        return nums[0];
    if(numsSize==2)
        return nums[0]>nums[1]?nums[0]:nums[1];
    int dp1[3] = {nums[0],fmax(nums[0],nums[1]),0};//不打劫最后一家 0：numsSize-2
    int dp2[3] = {nums[1],fmax(nums[1],nums[2]),0};//不打劫第一家   1：numsSize-1
    if(numsSize==3)//3家人偷不到dp[2]
        return dp1[1]>dp2[1]?dp1[1]:dp2[1];
    for(int i = 2;i<numsSize;i++){
        if(i<numsSize-1){//[2,numsSize-2]
            dp1[2] = fmax(dp1[1],nums[i]+dp1[0]);
            dp1[0] = dp1[1];
            dp1[1] = dp1[2];
        }
        if(i>2){//[3,numsSize-1]
            dp2[2] = fmax(dp2[1],nums[i]+dp2[0]);
            dp2[0] = dp2[1];
            dp2[1] = dp2[2];
        }
    }
    return dp1[2]>dp2[2]?dp1[2]:dp2[2];
}

LeetCode【337】【打家劫舍III】：https://leetcode-cn.com/problems/house-robber-iii/submissions/
int rob(struct TreeNode* root){
    if(!root)
        return 0;
    int RobSum = root->val;//偷父节点
    if(root->left)//偷左孩子的孩子
        RobSum += rob(root->left->left) + rob(root->left->right);
    if(root->right)//偷右孩子的孩子
        RobSum += rob(root->right->left) + rob(root->right->right);
    int NorRob = rob(root->left)+rob(root->right);//不偷父节点，偷孩子
    return RobSum>NorRob?RobSum:NorRob;
}

剑指offer【03】【数组中重复的数字】：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/
int findRepeatNumber(int* nums, int numsSize){
    int* count = (int*)malloc(sizeof(int)*numsSize);
    memset(count,0,sizeof(int)*numsSize);
    int i = 0;
    for(;i<numsSize;i++){
        if(count[nums[i]]==0)
            count[nums[i]]++;
        else
            break;
    } 
    return nums[i];
}

LeetCode【384】【打乱数组】：https://leetcode-cn.com/problems/shuffle-an-array/
typedef struct {
    int* src;
    int* record;
    int size;
} Solution;


Solution* solutionCreate(int* nums, int numsSize) {
    Solution* obj = (Solution*)malloc(sizeof(Solution));
    obj->src = (int*)malloc(sizeof(int)*numsSize);
    obj->record = (int*)malloc(sizeof(int)*numsSize);
    obj->size = numsSize;
    for(int i = 0;i<numsSize;i++){
        obj->record[i] = nums[i];
        obj->src[i] = nums[i];
    }
    return obj;
}

/** Resets the array to its original configuration and return it. */
int* solutionReset(Solution* obj, int* retSize) {
    *retSize = obj->size;
    for(int i = 0;i<obj->size;i++)
        obj->src[i] = obj->record[i];
    return obj->src;
}

/** Returns a random shuffling of the array. */
int* solutionShuffle(Solution* obj, int* retSize) {
    *retSize = obj->size;
    for(int i = 0;i<obj->size;i++){
        int x = rand()%(obj->size - i) + i;
        int tmp = obj->src[i];
        obj->src[i] = obj->src[x];
        obj->src[x] = tmp;
    }
    
    return obj->src;
}

void solutionFree(Solution* obj) {
    free(obj->src);
    free(obj->record);
    obj->size = 0;
    obj->src = NULL;
    obj->record = NULL;
}

/**
 * Your Solution struct will be instantiated and called as such:
 * Solution* obj = solutionCreate(nums, numsSize);
 * int* param_1 = solutionReset(obj, retSize);
 
 * int* param_2 = solutionShuffle(obj, retSize);
 
 * solutionFree(obj);
*/

面试题【03.02】【栈的最小值】：https://leetcode-cn.com/problems/min-stack-lcci/
typedef struct LinkNode{
    int val;
    struct LinkNode* next;
}LinkNode;
typedef struct LinkStack{
    LinkNode* head;
}LinkStack;

bool IsEmpty(LinkStack*pt);
void LinkStackInit(LinkStack* pt);
void LinkStackPush(LinkStack* pt,int x);
void LinkStackPop(LinkStack* pt);
int LinkStackTop(LinkStack* pt);
void LinkStackDestory(LinkStack* pt);

bool IsEmpty(LinkStack* pt)
{return pt->head == NULL;}
void LinkStackInit(LinkStack* pt)
{pt->head = NULL;}
void LinkStackPush(LinkStack* pt, int x){
    LinkNode* p = (LinkNode*)malloc(sizeof(LinkNode));
    p->val = x;
    p->next = pt->head;
    pt->head = p;
}

void LinkStackPop(LinkStack* pt){
    if(!IsEmpty(pt)){
        LinkNode* p = pt->head;
        pt->head = p->next;
        free(p);        
    }
}

void LinkStackDestory(LinkStack* pt){
    while(pt->head){
        LinkNode* p = pt->head;
        pt->head = p->next;
        free(p);
    }
}

int LinkStackTop(LinkStack* pt){
    return pt->head->val;
}

typedef struct {
    LinkStack s;
    LinkStack sm;
} MinStack;

/** initialize your data structure here. */

MinStack* minStackCreate() {
    MinStack* obj = (MinStack*)malloc(sizeof(MinStack));
    LinkStackInit(&(obj->s));
    LinkStackInit(&(obj->sm));
    return obj;
}

void minStackPush(MinStack* obj, int x) {
    LinkStackPush(&(obj->s),x);
    if(IsEmpty(&(obj->sm)) || LinkStackTop(&(obj->sm))>=x)
        LinkStackPush(&(obj->sm),x);
}

void minStackPop(MinStack* obj) {
    if(LinkStackTop(&(obj->s))==LinkStackTop(&(obj->sm)))
        LinkStackPop(&(obj->sm));
    LinkStackPop(&(obj->s));
}

int minStackTop(MinStack* obj) {
    return LinkStackTop(&(obj->s));
}

int minStackGetMin(MinStack* obj) {
    return LinkStackTop(&(obj->sm));
}

void minStackFree(MinStack* obj) {
    LinkStackDestory(&(obj->s));
    LinkStackDestory(&(obj->sm));
    obj= NULL;
}

/**
 * Your MinStack struct will be instantiated and called as such:
 * MinStack* obj = minStackCreate();
 * minStackPush(obj, x);
 
 * minStackPop(obj);
 
 * int param_3 = minStackTop(obj);
 
 * int param_4 = minStackGetMin(obj);
 
 * minStackFree(obj);
*/

LeetCode【13】【罗马数字转整数】：https://leetcode-cn.com/problems/roman-to-integer/
int romanToInt(char * s){
    int i = 0;
    int res = 0;
    while(s[i]){
        switch(s[i]){
            case 'I':
                res+=1;
                switch(s[++i]){
                    case 'V':res+=3;break;
                    case 'X':res+=8;break;
                    default:i--;break;
                }
                break;
            case 'V':res+=5;break;
            case 'X':
                res+= 10;
                switch(s[++i]){
                    case 'L':res+=30;break;
                    case 'C':res+=80;break;
                    default:i--;break;
                }
                break;
            case 'L':res+=50;break;
            case 'C':
                res+=100;
                switch(s[++i]){
                    case 'D':res+=300;break;
                    case 'M':res+=800;break;
                    default:i--;break;
                }
                break;
            case 'D':res+=500;break;
            case 'M':res+=1000;break;
            default:break;
        }
        i++;
    }
    return res;
}

LeetCode【98】【验证二叉搜索树】：https://leetcode-cn.com/problems/validate-binary-search-tree/
int TreeNodeCount(struct TreeNode* root){
    if(!root)
        return 0;
    return TreeNodeCount(root->left) + TreeNodeCount(root->right)+1;
    
}
void MidOrder(struct TreeNode* root,int* nums,int* index){
    if(!root)
        return;
    MidOrder(root->left,nums,index);
    nums[(*index)++] = root->val;
    MidOrder(root->right,nums,index);
}
bool isValidBST(struct TreeNode* root){
    int cnt = TreeNodeCount(root);    
    int* nums = (int*)malloc(sizeof(int)*cnt);
    cnt = 0;
    MidOrder(root,nums,&cnt);
    for(int i = 1;i<cnt;i++)
        if(nums[i]<=nums[i-1])
            return false;
    return true;
}

面试题【16.15】【珠玑妙算】：https://leetcode-cn.com/problems/master-mind-lcci/
int* masterMind(char* solution, char* guess, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    res[0] = 0, res[1] = 0;
    for(int i = 0; i < 4; i++){
        if(solution[i] == guess[i])
            res[0]++;
    }
    int cnt_R[2] = {0},cnt_Y[2] = {0},cnt_G[2] = {0},cnt_B[2] = {0};
    for(int i = 0; i < 4; i++){
        if(solution[i]=='R')
            cnt_R[0]++;
        else if(solution[i] == 'Y')
            cnt_Y[0]++;
        else if(solution[i] == 'G')
            cnt_G[0]++;
        else
            cnt_B[0]++;
    }
    for(int i = 0; i < 4; i++){
        if(guess[i]=='R')
            cnt_R[1]++;
        else if(guess[i] == 'Y')
            cnt_Y[1]++;
        else if(guess[i] == 'G')
            cnt_G[1]++;
        else
            cnt_B[1]++;
    }
    res[1] = fmin(cnt_R[0],cnt_R[1])+fmin(cnt_Y[0],cnt_Y[1])+fmin(cnt_G[0],cnt_G[1])+fmin(cnt_B[0],cnt_B[1]);
    res[1]-=res[0];
    return res;
}

剑指offer【32-III】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/
int Height(struct TreeNode* root){
        if(!root)
            return 0;
        int h_l = Height(root->left)+1;
        int h_r = Height(root->right)+1;
        return h_l>h_r?h_l:h_r;
    }
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
        if(NULL == root){
            *returnSize = 0;
            return NULL;
        }
        int level = Height(root);
        int** res = (int**)malloc(sizeof(int*)*level);
        *returnColumnSizes = (int*)malloc(sizeof(int)*level);
        *returnSize = level;
        struct TreeNode *q1[1000],*q2[1000];
        int q1_size = 0,q2_size = 0;
        q1[0] = root,q1_size++;
        int h = 0;
        while(h<level){
            res[h] = (int*)malloc(sizeof(int)*q1_size);
            for(int i = 0;i<q1_size;i++)
                res[h][i] = q1[i]->val;
            (*returnColumnSizes)[h] = q1_size;
            for(int i = 0;i<q1_size;i++){
                if(q1[i]->left)
                    q2[q2_size++] = q1[i]->left;
                if(q1[i]->right)
                    q2[q2_size++] = q1[i]->right;
            }
            memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
            q1_size = q2_size;
            q2_size = 0;
            h++;
        } 
        for(int i = 1;i<level;i+=2){
            int top = (*returnColumnSizes)[i];
            for(int j = 0;j<top/2;j++){
                int tmp = res[i][j];
                res[i][j] = res[i][top-j-1];
                res[i][top-j-1] = tmp;
            }
        }
        return res;
}

LeetCode【515】【在每个树行中找最大值】：https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/
int Height(struct TreeNode* root){
        if(!root)
            return 0;
        int h_l = Height(root->left)+1;
        int h_r = Height(root->right)+1;
        return h_l>h_r?h_l:h_r;
    } 
int* largestValues(struct TreeNode* root, int* returnSize){
    int layer = Height(root);
    *returnSize = layer;
    int* res = (int*)malloc(sizeof(int)*layer);
    struct TreeNode *q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root,++q1_size;

    int h = 0;
    while(h < layer){
        int max = q1[0]->val;
        for(int i = 1;i<q1_size;i++)
            if(q1[i]->val>max)
                max = q1[i]->val;
        res[h] = max;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
    }
    return res;
}

剑指offer【21-I】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/
int Height(struct TreeNode* root){
        if(!root)
            return 0;
        int h_l = Height(root->left)+1;
        int h_r = Height(root->right)+1;
        return h_l>h_r?h_l:h_r;
}
int NumofNode(struct TreeNode* root){
    if(!root)
        return 0;
    return NumofNode(root->left)+NumofNode(root->right)+1;
}
int* levelOrder(struct TreeNode* root, int* returnSize){
    if(NULL == root){
            *returnSize = 0;
            return NULL;
    }
    int level = Height(root);
    int num = NumofNode(root);
    int* res = (int*)malloc(sizeof(int*)*num);
    *returnSize = num;
    struct TreeNode *q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root,q1_size++;
    int h = 0;
    int cnt = 0;
    while(h<level){
        for(int i = 0;i<q1_size;i++)
            res[cnt++] = q1[i]->val;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        h++;
    } 
    return res;
}

LeetCode【637】【二叉树的层平均值】：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/
int Height(struct TreeNode* root){
    if(!root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r;
}
double* averageOfLevels(struct TreeNode* root, int* returnSize){
    int layer = Height(root);
    double* res = (double*)malloc(sizeof(double)*layer);
    *returnSize = layer;
    struct TreeNode* q1[1000],*q2[1000];
    int q1_size = 1,q2_size = 0;
    q1[0] = root;
    int h  = 0;
    double sum = 0.0;
    while(h<layer){
        for(int i = 0;i<q1_size;i++)
            sum += q1[i]->val;
        res[h] = sum/q1_size;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
        sum = 0; 
    }
    return res;
}

LeetCode【513】【找树左下角的值】：https://leetcode-cn.com/problems/find-bottom-left-tree-value/
int Height(struct TreeNode* root){
    if(!root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r;
}
int findBottomLeftValue(struct TreeNode* root){
    int layer = Height(root);
    struct TreeNode* q1[1000],*q2[1000];
    int q1_size = 1,q2_size = 0;
    q1[0] = root;
    int h  = 0;
    int res;
    while(h<layer){
        if(h == layer - 1){
            res = q1[0]->val;
            break;
        }
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
    }
    return res;
}

LeetCode【1302】【层数最深叶子节点的和】：https://leetcode-cn.com/problems/deepest-leaves-sum/
int Height(struct TreeNode* root){
    if(!root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r;
}
int deepestLeavesSum(struct TreeNode* root){
    int layer = Height(root);
    struct TreeNode* q1[10000],*q2[10000];
    int q1_size = 1,q2_size = 0;
    q1[0] = root;
    int h  = 0;
    int sum = 0;
    while(h<layer){
        if(h == layer - 1){
            for(int i = 0;i<q1_size;i++)
                sum+=q1[i]->val;
            break;
        }
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size,q2_size = 0;
        h++;
    }
    return sum;
}

LeetCode【501】【二叉树中的众数】：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/
int* res;
int resSize;
int base, count, maxCount;
void update(int num){
    if(num == base)
        ++count;
    else
        count = 1,base = num;
    if(count == maxCount)
        res[resSize++] = num;
    if (count > maxCount) {
        maxCount = count;
        resSize = 0;
        res[resSize++] = base;
    }
}  
void dfs(struct TreeNode* root){
    if(!root)
        return;
    dfs(root->left);
    update(root->val);
    dfs(root->right);
} 
int* findMode(struct TreeNode* root, int* returnSize){
    base = count = maxCount = 0;
    res = malloc(sizeof(int) * 4001);
    resSize = 0;
    dfs(root);
    *returnSize = resSize;
    return res;
}

LeetCode【530】【二叉搜索书的最小绝对差】：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/
void dfs(struct TreeNode* root,int* res,int* index){
    if(!root)
        return;
    dfs(root->left,res,index);
    res[*index] = root->val;
    (*index)++;
    dfs(root->right,res,index);
}
int getMinimumDifference(struct TreeNode* root){
    int* res = (int*)malloc(sizeof(int)*10000);
    int index = 0;
    dfs(root,res,&index);
    int Min = INT_MAX;
    for(int i = 1;i<index;i++){
        int tmp = res[i] - res[i-1];
        if(tmp<Min)
            Min = tmp;
    }
    return Min;
}

LeetCode【832】【翻转图像】：https://leetcode-cn.com/problems/flipping-an-image/
int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){
    *returnSize = imageSize;
    *returnColumnSizes = imageColSize;
    int top = imageSize%2?imageSize/2 + 1:imageSize/2;
    for(int i = 0;i<imageSize;i++){
        for(int j = 0;j < top;j++){
            int tmp = image[i][j];
            image[i][j] = 1^image[i][imageSize-1-j];
            image[i][imageSize-1-j] = 1^tmp;
        }
    }
    return image;
}

LeetCode【257】【二叉树的所有路径】：https://leetcode-cn.com/problems/binary-tree-paths/
class Solution {
public:
    vector<string> res;
    vector<string> binaryTreePaths(TreeNode* root) {
       string tmp;
       DFS(root,tmp);
       return res;
    }
    void DFS(TreeNode* root,string tmp){
        if(!root)
            return;
        tmp += to_string(root->val);
        if(!root->left && !root->right)
            res.push_back(tmp);
        else{
            tmp += "->";
            DFS(root->left,tmp);
            DFS(root->right,tmp);
        }
    }
};

牛客【矩形覆盖】：https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tab=answerKey
class Solution {
public:
    int rectCover(int number) {
        vector<int> dp(3);
        dp[0] = 1,dp[1]=1;
        for(int i = 2;i<=number;++i){
            dp[2]=dp[0]+dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return number>1?dp[2]:number>=0?number:0;
    }
};

LeetCode【139】【单词拆分】：https://leetcode-cn.com/problems/word-break/
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        if(s.empty())
            return false;
        if(wordDict.empty())
            return false;
        auto wordDictSet = unordered_set <string> ();
        for (auto word: wordDict) {
            wordDictSet.insert(word);
        }
        int sz = s.size();
        vector<bool> dp(sz+1,false);
        dp[0] = true;
        for(int i = 1;i<=sz;++i){
            for(int j = 0;j<i;++j){
                if(dp[j]&&wordDictSet.find(s.substr(j,i-j))!=wordDictSet.end()){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[sz];
    }
};

牛客【三角形】：https://www.nowcoder.com/practice/2b7995aa4f7949d99674d975489cb7da?tpId=46&tqId=29060&tPage=2&rp=2&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-rankin&tab=answerKey
【自底向上】
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        if(triangle.empty())
            return 0;
        int sz = triangle.size();
        vector<vector<int>> dp(triangle);
        for(int i = 1;i<sz;++i){
            for(int j = 0;j<=i;++j){
                if(j==0)
                    dp[i][j] = dp[i-1][j];
                else if(j==i)
                    dp[i][j] = dp[i-1][j-1];
                else 
                    dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]);
                dp[i][j]+=triangle[i][j];
            }
        }
        int res = dp[sz-1][0];
        for(int i = 1;i<sz;++i)
            res = res<dp[sz-1][i]?res:dp[sz-1][i];
        return res;
    }
};
【自顶向下】：
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        if(triangle.empty())
            return 0;
        int sz = triangle.size();
        vector<vector<int>> dp(triangle);
        for(int i = sz-2;i>=0;--i){
            for(int j = 0;j<=i;++j)
                dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j];
        }
        return dp[0][0];
    }
};

牛客【求路径】：https://www.nowcoder.com/practice/166eaff8439d4cd898e3ba933fbc6358?tpId=46&tqId=29117&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param m int整型 
     * @param n int整型 
     * @return int整型
     */
    int uniquePaths(int m, int n) {
        if(n<0||m<0)
            return 0;
        vector<vector<int>> path(m,vector<int> (n,1));
        for(int i = 1;i<m;++i)
            for(int j = 1;j<n;++j)
                path[i][j] = path[i-1][j]+path[i][j-1];
        return path[m-1][n-1];
    }
};

牛客【求路径2】：https://www.nowcoder.com/practice/3cdf08dd4e974260921b712f0a5c8752?tpId=46&tqId=29116&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param obstacleGrid int整型vector<vector<>> 
     * @return int整型
     */
    int uniquePathsWithObstacles(vector<vector<int> >& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(n<0||m<0)
            return 0;
        vector<vector<int>> path(m,vector<int> (n,0));
        for(int i = 0;i<m;++i){
            if(obstacleGrid[i][0])
                break;
            else
                path[i][0]=1;
        }
        for(int i = 0;i<n;++i){
            if(obstacleGrid[0][i])
                break;
            else
                path[0][i]=1;
        }
        for(int i = 1;i<m;++i)
            for(int j = 1;j<n;++j)
                path[i][j] = obstacleGrid[i][j]?0:path[i-1][j]+path[i][j-1];
        return path[m-1][n-1];
    }
};

牛客【带权值的最小路径和】：https://www.nowcoder.com/practice/23462ed010024fcabb7dbd3df57c715e?tpId=46&tqId=29115&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param grid int整型vector<vector<>> 
     * @return int整型
     */
    int minPathSum(vector<vector<int> >& grid) {
        int m = grid.size();
        int n = grid[0].size();
        if(!m || !n)
            return 0;
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0] = grid[0][0];
        for(int i = 1;i<m;++i)
            dp[i][0] = grid[i][0]+dp[i-1][0];
        for(int i = 1;i<n;++i)
            dp[0][i] = grid[0][i]+dp[0][i-1];
        for(int i = 1;i<m;++i){
            for(int j = 1;j<n;++j)
                dp[i][j] = min(dp[i][j-1],dp[i-1][j])+grid[i][j];
        }
        return dp[m-1][n-1];
    }
};

LeetCode【209】【长度最小的子数组】：https://leetcode-cn.com/problems/minimum-size-subarray-sum/
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX;
        int sz = nums.size();
        int left = 0,right = 0;
        int sum = 0;
        while(right<sz){
            sum+=nums[right];
            while(sum>=target){
                res = min(res,right-left+1);
                sum-=nums[left++];
            }
            ++right;
        }
        return res==INT_MAX?0:res;
    }
};

【746】【使用最小花费爬楼梯】：https://leetcode-cn.com/problems/min-cost-climbing-stairs/
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int sz = cost.size();
        vector<int> dp(sz+1,0);
        dp[0] = 0,dp[1] = 0;
        for(int i = 2;i<=sz;++i)
            dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        return dp[sz];
    }
};

LeetCode【908】【最小差值】：https://leetcode-cn.com/problems/smallest-range-i/
class Solution {
public:
    int smallestRangeI(vector<int>& A, int K) {
        int n = A.size();
        int max_A = A[0];
        int min_A = A[0];
        for(int i = 1;i<n;++i){
            if(A[i]>max_A)
                max_A = A[i];
            else if(A[i]<min_A)
                min_A = A[i];
        }
        int tmp = max_A-min_A - 2*K;
        return tmp>0?tmp:0;
    }
};

LeetCode【910】【最小差值II】：https://leetcode-cn.com/problems/smallest-range-ii/
class Solution {
public:
    int smallestRangeII(vector<int>& A, int K) {
        int n = A.size();
        sort(A.begin(),A.end());
        int res = A[n-1]-A[0];
        for(int i = 0;i<n-1;++i){
            int tmp1 = max(A[n-1]-K,A[i]+K);
            int tmp2 = min(A[i+1]-K,A[0]+K);
            int tmp3 = tmp1-tmp2;
            res = min(res,tmp3);
        }
        return res;
    }
};

LeetCode【931】【下降路径最小和】：https://leetcode-cn.com/problems/minimum-falling-path-sum/
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0] = matrix[0]; 
        for(int i = 1;i<m;++i){
            for(int j = 0;j<n;++j){
                if(j==n-1)
                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]);
                else if(!j)
                    dp[i][j] = min(dp[i-1][j],dp[i-1][j+1]);
                else
                    dp[i][j] = min(min(dp[i-1][j-1],dp[i-1][j]),dp[i-1][j+1]);
                dp[i][j]+=matrix[i][j];
            }
        }
        int res = dp[m-1][0];
        for(int i = 1;i<n;++i)
            res = res<dp[m-1][i]?res:dp[m-1][i];
        return res;
     }
};

LeetCode【292】【Nim游戏】：https://leetcode-cn.com/problems/nim-game/
class Solution {
public:
    bool canWinNim(int n) {
        return n%4!=0;
    }
};

剑指offer【37】【序列化二叉树】：https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/
class Codec {
public:
    string res;
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root)
            return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int sz = q.size();
            for(int i = 0;i<sz;++i){
                TreeNode* t = q.front();
                q.pop();
                if(t){
                    res += to_string(t->val);
                    res+=",";
                    q.push(t->left);
                    q.push(t->right);
                }
                else
                    res+="$,";
            }
        }
        return res;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data){
        split(data);
        int sz = seq.size();
        int start = 0;
        return Creat(start,sz);
    }
    private:
    vector<string> seq;
    void split(string& data){
        char* start = (char*)data.c_str();
        char* send = start;
        while(*send){
            if(*send == ','){
                string tmp;
                for(char* r = start;r!=send;++r)
                    tmp.push_back(*r);
                seq.push_back(tmp);
                start = send + 1;
                send = start;
            }else
                ++send;
        }
    }
    int to_num(const string& str){
        int res = 0;
        int flag = 1;
        int index = 0;
        if(str[index] =='-'){
            flag = -1;
            ++index;
        }
        int sz = str.size();
        for(int i = index;i<sz;i++)
            res = res*10 + (str[i]-'0');
        return flag*res;
    }
    TreeNode* Creat(int index,const int& sz){
        if(index>=sz || seq[index][0] == '$')
            return nullptr;
        int cnt = 0;
        for(int i = 0;i<index;++i)
            if(seq[i][0]=='$')
                ++cnt;
        TreeNode* t = new TreeNode(to_num(seq[index]));
        t->left = Creat(2*(index-cnt)+1,sz);
        t->right = Creat(2*(index-cnt)+2,sz);
        return t;
    }

剑指offer【12】【矩阵中的路径】：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        _rows = board.size();
        _cols = board[0].size();
        for(int i = 0;i<_rows;++i)
            for(int j = 0;j<_cols;++j)
                if(dfs(i,j,0,word,board))
                    return true;
        return false;
    }
    private:
    int _rows,_cols;
    bool dfs(int row,int col,int index,const string& word,vector<vector<char>>& board){
        char c = word[index];
        if(row>=_rows || row<0 || col<0 || col>=_cols || board[row][col]!=c)
            return false;
        if(index == word.size()-1)
            return true;
        board[row][col] = '\0';
        bool res = dfs(row,col+1,index+1,word,board)||dfs(row,col-1,index+1,word,board)||
            dfs(row+1,col,index+1,word,board)||dfs(row-1,col,index+1,word,board);
        board[row][col] = word[index];
        return res;
    }
};

剑指offer【13】【机器人的运行范围】：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/
class Solution {
public:
    int movingCount(int m, int n, int k) {
        if(k<0 || m<=0 || n<= 0)
            return 0;
        vector<vector<bool>> visited(m,vector<bool> (n,false));
        int cnt = CheckCore(0,0,k,visited,m,n);
        return cnt; 
    }
    private:
    int CheckCore(const int& row,const int& col,const int& k,vector<vector<bool>>& visited,const int& m,const int& n){
        int cnt = 0;
        if(Check(row,col,k,visited,m,n)){
            visited[row][col] = true;
            cnt = 1+CheckCore(row-1,col,k,visited,m,n)+CheckCore(row+1,col,k,visited,m,n)+
                CheckCore(row,col-1,k,visited,m,n)+CheckCore(row,col+1,k,visited,m,n);
        }
        return cnt;
    }
    bool Check(const int& row,const int& col,const int& k,vector<vector<bool>>& visited,const int& m,const int& n){
        if(row>=0&&row<m&&col>=0&&col<n&&GetAdd(row,col,k)&&!visited[row][col])
            return true;
        return false;
    }
    bool GetAdd(int row,int col,const int& k){
        int res = 0;
        while(row){
            res+=row%10;
            row/=10;
        }
        while(col){
            res+=col%10;
            col/=10;
        }
        return res<=k;
    }
};

LeetCode【657】【机器人能否返回原点】：https://leetcode-cn.com/problems/robot-return-to-origin/
class Solution {
public:
    bool judgeCircle(string moves) {
        int sz = moves.size();
        int x = 0,y = 0;
        for(int i = 0;i<sz;i++){
            if(moves[i] == 'U')
                ++y;
            else if(moves[i] == 'D')
                --y;
            else if(moves[i] == 'L')
                --x;
            else
                ++x;
        }
        return !x && !y;
    }
};

LeetCode【1041】【困于环中的机器人】：https://leetcode-cn.com/problems/robot-bounded-in-circle/
class Solution {
public:
    bool isRobotBounded(string instructions) {
        int x = 0,y = 0;
        int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};//右上左下
        int sz = instructions.size();
        int d = 0;
        for(int i = 0;i < sz; ++i){
            if(instructions[i] == 'L')
                d += 1;
            else if(instructions[i] == 'R')
                d += 3;
            else{
                d %= 4;
                x += dir[d][0];
                y += dir[d][1];
            }
        }
        return d%4 || !x && !y;
    }
};

面试题【08.02】【迷路的机器人】：https://leetcode-cn.com/problems/robot-in-a-grid-lcci/
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> pathWithObstacles(vector<vector<int>>& obstacleGrid) {
        r = obstacleGrid.size(),c = obstacleGrid[0].size();
        if(!r || !c || obstacleGrid[r-1][c-1])
            return res;
        vector<vector<bool>> vis(r,vector<bool>(c,true));
        BackTrack(0,0,obstacleGrid,vis);
        return res;
    }
    private:
    int r,c;
    bool BackTrack(int row,int col,const vector<vector<int>>& ob,vector<vector<bool>>& vis){
        int sz = res.size();
        if(sz>0 && res[sz-1][0]==r-1 && res[sz-1][1]==c-1)//已到终点
            return true; 
        if(row>=r || col>=c || ob[row][col] || !vis[row][col])//剪枝
            return false;
        res.push_back(vector<int> ({row,col}));
        if(BackTrack(row+1,col,ob,vis) || BackTrack(row,col+1,ob,vis))//一个方向即可
            return true;
        vis[row][col] = false;//此路不通
        res.pop_back();
        return false;
    }
};

剑指offer【47】【礼物的最大价值】：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid);
        int m = grid.size();
        int n = grid[0].size();
        for(int i = 1;i<n;++i)
            dp[0][i] = dp[0][i-1] + grid[0][i];
        for(int i = 1;i<m;++i)
            dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int i = 1;i<m;++i)
            for(int j = 1;j<n;++j)
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + grid[i][j];
        return dp[m-1][n-1];
    }
};

面试题【08.01】【三步问题】：https://leetcode-cn.com/problems/three-steps-problem-lcci/
class Solution {
public:
    int waysToStep(int n) {
        int r = 1000000007;
        vector<int> dp({1,2,4,0});
        for(int i = 4;i<=n;++i){
            dp[3] = ((dp[0]+dp[1])%r+dp[2])%r;
            dp[0] = dp[1];
            dp[1] = dp[2];
            dp[2] = dp[3];
        }
        return n<4?dp[n-1]:dp[3];
    }
};

面试题【08.11】【硬币】：https://leetcode-cn.com/problems/coin-lcci/
class Solution {
public:
    int waysToChange(int n) {
        int r = 1000000007;
        vector<int> coins({25,10,5,1});
        vector<int> dp(n+1,0);
        dp[0] = 1;
        for(int i = 0;i<4;++i)
            for(int j = coins[i];j<=n;++j)
               dp[j] = (dp[j]+dp[j-coins[i]])%r;
        return dp[n];
    }
};

LeetCode【96】【不同的二叉搜索树】：https://leetcode-cn.com/problems/unique-binary-search-trees/
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0] = 1,dp[1] = 1;
        for(int i = 2;i<=n;++i)
            for(int j =1;j<=i;++j)
                dp[i]+=dp[j-1]*dp[i-j];
        return dp[n];
    }
};

LeetCode【1832】【判断句子是否为全字母句】：https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/
class Solution {
public:
    bool checkIfPangram(string sentence) {
        int cnt[26] = {0};
        int sz = sentence.size();
        for(int i = 0;i<sz;++i)
            cnt[sentence[i]-'a']=1;
        for(int i = 0; i < 26;++i)
            if(!cnt[i])
                return false;
        return true;
    }
};

面试题【10.01】【合并排序的数组】：https://leetcode-cn.com/problems/sorted-merge-lcci/
class Solution {
public:
    void merge(vector<int>& A, int m, vector<int>& B, int n) {
        int szB = B.size();
        for(int i = 0;i<szB;++i){
            int szA = A.size();
            int j = m - 1;
            for(;j>=0 && B[i]<A[j];--j)
                A[j+1] = A[j];
            A[j+1] = B[i];
            ++m;
        }
    }
};

LintCode【125】【背包问题II】：https://www.lintcode.com/problem/backpack-ii/
class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @param V: Given n items with value V[i]
     * @return: The maximum value
     */
    int backPackII(int m, vector<int> &A, vector<int> &V) {
        // write your code here
        int n = A.size();//物品数量
        if(!m || !n)
            return 0;
        vector<vector<int>> maxV(n+1,vector<int>(m+1,0));//横向为背包容量
        for(int i = 1;i<=n;++i){
            for(int j = 1;j<=m;++j)
                if(A[i-1] <= j)//放的下，分两种：直接放，拿出一部分再放
                    maxV[i][j] = max(maxV[i-1][j],maxV[i-1][j-A[i-1]]+V[i-1]);
                else//背包放不下
                    maxV[i][j] = maxV[i-1][j];
        }
        return maxV[n][m];
    }
};

class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @param V: Given n items with value V[i]
     * @return: The maximum value
     */
    int backPackII(int m, vector<int> &A, vector<int> &V) {
        // write your code here
        int n = A.size();//物品数量
        if(!m || !n)
            return 0;
        vector<int> maxV(m+1,0);//横向为背包容量
        for(int i = 1;i<=n;++i){
            for(int j = m;j>=0;--j)
                if(A[i-1] <= j)//放的下，分两种：直接放，拿出一部分再放
                    maxV[j] = max(maxV[j],maxV[j-A[i-1]]+V[i-1]);
                else//背包放不下
                    maxV[j] = maxV[j];
        }
        return maxV[m];
    }
};
LeetCode【132】【分割回文串】：https://leetcode-cn.com/problems/palindrome-partitioning-ii/
class Solution {
public:
    int minCut(string s) {
        int sz = s.size();
        vector<int> dp(sz+1,0);
        for(int i = 0;i<=sz;++i)
            dp[i] = i - 1;
        for(int i = 2;i<=sz;++i){
            for(int j = 0;j<i;++j)//
                if(IsPal(s,j,i-1))
                    dp[i] = min(dp[i],dp[j]+1);
        }
        return dp[sz];
    }
    bool IsPal(const string& s,int start,int end){
        while(start < end){
            if(s[start] != s[end])
                return false;
            ++start,--end;
        }
        return true;
    }
};

牛客【编辑距离】：https://www.nowcoder.com/practice/81d7738f954242e5ade5e65ec40e5027?tpId=46&tqId=29106&tPage=1&rp=1&ru=%2Fta%2Fleetcode&qru=%2Fta%2Fleetcode%2Fquestion-ranking&tab=answerKey
class Solution {
public:
    /**
     * 
     * @param word1 string字符串 
     * @param word2 string字符串 
     * @return int整型
     */
    int minDistance(string word1, string word2) {
        int sz1 = word1.size();
        int sz2 = word2.size();
        vector<vector<int>> minD(sz1+1,vector<int>(sz2+1,0));
        for(int i = 0;i<=sz1;++i)
            minD[i][0] = i;
        for(int i = 0;i<=sz2;++i)
            minD[0][i] = i;
        for(int i = 1;i<=sz1;++i){
            for(int j = 1;j<=sz2;++j){
                //插入，删除
                minD[i][j] = min(minD[i][j-1],minD[i-1][j])+1;
                //替换
                if(word1[i-1] == word2[j-1])
                    minD[i][j] = min(minD[i][j],minD[i-1][j-1]);
                else
                    minD[i][j] = min(minD[i][j],minD[i-1][j-1]+1);
            }
        }
        return minD[sz1][sz2];
    }
};

LeetCode【690】【员工的重要性】：https://leetcode-cn.com/problems/employee-importance/
class Solution {
public:
    map<int, Employee *> m;
    int getImportance(vector <Employee*> es, int id) {
        int n = es.size();
        for (int i = 0; i < n; i++) 
            m.insert({es[i]->id, es[i]});
        return getVal(id);
    }
    int getVal(int id){
        Employee* master = m[id];
        int imp =master->importance;
        for(auto& p:master->subordinates)
            imp+=getVal(p);
        return imp;
    }
};
【BFS】：
class Solution {
public:
    map<int, Employee *> m;
    int getImportance(vector <Employee*> es, int id) {
        int n = es.size();
        for (int i = 0; i < n; i++) 
            m.insert({es[i]->id, es[i]});
        queue<int> q;
        q.push(id);
        int sum = 0;
        while(!q.empty()){
            int cur = q.front();
            q.pop();
            sum+=m[cur]->importance;
            for(auto& e:m[cur]->subordinates)
                q.push(e);

        }
        return sum;
    }
};

LeetCode【733】【图像渲染】：https://leetcode-cn.com/problems/flood-fill/
class Solution {
public:
    int change[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int oldcolor = image[sr][sc];
        if(oldcolor!=newColor)
            DFS(image,sr,sc,oldcolor,newColor);
        return image;
    }
    void DFS(vector<vector<int>>& image, int x, int y,const int& oldcolor,const int& newColor){
        if(x>=image.size() || x<0 || y>=image[0].size() || y<0 || image[x][y]!=oldcolor)
            return;
        image[x][y] = newColor;
        for(int i = 0;i<4;++i)
            DFS(image,x+change[i][0],y+change[i][1],oldcolor,newColor);
    }
};

LeetCode【130】【被围绕的区域】：https://leetcode-cn.com/problems/surrounded-regions/
class Solution {
public:
    int dir[4][2] ={{1,0},{0,1},{-1,0},{0,-1}};
    void solve(vector<vector<char>>& board) {
        int m = board.size();
        int n = board[0].size();
        for(int i = 0;i<m;++i){
            if(board[i][0] == 'O')//第0列
                DFS(board,i,0,m,n);
            if(board[i][n-1] == 'O')//第n-1列
                DFS(board,i,n-1,m,n);
        }
        for(int i = 0;i<n;++i){
            if(board[0][i] == 'O')//第0行
                DFS(board,0,i,m,n);
            if(board[m-1][i] == 'O')//第m-1行
                DFS(board,m-1,i,m,n);
        }
        for(int i = 0;i<m;++i)
            for(int j=0;j<n;++j){
                if(board[i][j]=='O')
                    board[i][j] = 'X';
                else if(board[i][j] == 'A')
                    board[i][j] = 'O';
            }
    }
    void DFS(vector<vector<char>>& board,int x,int y,const int& m,const int& n){
        if(x<0||y<0||x>=m||y>=n||board[x][y]!='O')
            return;
        board[x][y] = 'A';
        for(int i = 0;i<4;++i)
            DFS(board,x + dir[i][0],y + dir[i][1],m,n);
    }
};

LeetCode【200】【岛屿数量】：https://leetcode-cn.com/problems/number-of-islands/
class Solution {
public:
    int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        int res = 0;
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j)
                if(grid[i][j]=='1' && !visited[i][j]){
                    ++res;
                    DFS(grid,i,j,m,n,visited);
                }
        }
        return res;
    }
    void DFS(vector<vector<char>>& grid,int x,int y,const int& m,const int&n,vector<vector<bool>>& visited){
        visited[x][y] = true;
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<m && nx>=0 && ny>=0 && ny<n && !visited[nx][ny] && grid[x][y] == '1')
                DFS(grid,nx,ny,m,n,visited);
        }
    }
};

LeetCode【994】【腐烂的橘子】：https://leetcode-cn.com/problems/rotting-oranges/
class Solution {
public:
    int dir[4][2] ={{1,0},{0,1},{-1,0},{0,-1}};
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<int,int>> q;
        int row = grid.size();
        int col =grid[0].size();
        for(int i = 0;i<row;++i)
            for(int j = 0;j<col;++j)
                if(grid[i][j] == 2)
                    q.push(make_pair(i,j));
        int minTime = 0;
        while(!q.empty()){
            int sz = q.size();
            int flag = 0;
            for(int i = 0;i<sz;++i){
                pair<int,int> curPos = q.front();
                q.pop();
                for(int i = 0;i<4;++i){
                    int nx = curPos.first + dir[i][0];
                    int ny = curPos.second + dir[i][1];
                    if(nx<0 || ny<0
                        || nx>=row || ny >= col)
                        continue;
                    if(grid[nx][ny] == 1){
                        flag = 1;
                        grid[nx][ny] = 2;
                        q.push(make_pair(nx,ny));
                    }
                }
            }
            if(flag)
                ++minTime;
        }
        for(int i = 0;i<row;++i)
            for(int j = 0;j<col;++j)
                if(grid[i][j] == 1)
                    return -1;
        return minTime;
    }
};

LeetCode【695】【岛屿的最大面积】：https://leetcode-cn.com/problems/max-area-of-island/
class Solution {
public:
    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int area = 0;
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        for(int i = 0;i<m;++i)
            for(int j = 0;j<n;++j){
                if(grid[i][j] && !visited[i][j]){
                    int cur = 1;
                    DFS(grid,i,j,m,n,visited,area,cur);
                }
            }
        return area;
    }
    void DFS(vector<vector<int>>& grid,int x,int y,const int& m,const int& n,vector<vector<bool>>& visited,int& res,int& cur){
        if(cur>res)
            res = cur;
        visited[x][y] = true;
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0 || ny<0 || nx>=m || ny>=n)
                continue;
            if(grid[nx][ny] && !visited[nx][ny]){
                ++cur;
                DFS(grid,nx,ny,m,n,visited,res,cur);
            }
        }
    }
};

LeetCode【463】【岛屿的周长】：https://leetcode-cn.com/problems/island-perimeter/
class Solution {
public:
    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; 
    int islandPerimeter(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int res = 0;
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j){
                if(grid[i][j]){
                    int cnt = 0;
                    for(int k = 0;k<4;++k){
                        int nx = i + dir[k][0];
                        int ny = j + dir[k][1];
                        if(nx<0||ny<0||nx>=m||ny>=n||!grid[nx][ny])
                            ++cnt;
                    }
                    res+=cnt;
                }
            }
        }
        return res;
    }
};
【DFS】：
class Solution {
public:
    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}}; 
    int DFS(int x, int y, vector<vector<int>> &grid, int n, int m) {
        if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 0) {
            return 1;
        }
        if (grid[x][y] == 2) {
            return 0;
        }
        grid[x][y] = 2;
        int res = 0;
        for (int i = 0; i < 4; ++i) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            res += DFS(tx, ty, grid, n, m);
        }
        return res;
    }
    int islandPerimeter(vector<vector<int>> &grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    ans += DFS(i, j, grid, n, m);
                }
                if(ans)
                    break;
            }
        }
        return ans;
    }
};

LeetCode【1254】【统计封闭岛屿的数目】：https://leetcode-cn.com/problems/number-of-closed-islands/
class Solution {
public: 
    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int closedIsland(vector<vector<int>>& grid) {
       int m = grid.size();
       int n = grid[0].size();
       int res = 0;
       vector<vector<bool>> visited(m,vector<bool>(n,false));
       for(int i = 0;i<m;++i){
            if(!grid[i][0])//第0列
                DFS(grid,i,0,m,n,visited);
            if(!grid[i][n-1])//最后一列
                DFS(grid,i,n-1,m,n,visited);
        }
        for(int i = 0;i<n;++i){
            if(!grid[0][i])//第0行
                DFS(grid,0,i,m,n,visited);
            if(!grid[m-1][i])//最后一行
                DFS(grid,m-1,i,m,n,visited);
        }
       for(int i = 0;i<m;++i) {
           for(int j = 0;j<n;++j){
               if(!grid[i][j] && !visited[i][j]){
                   ++res;
                   DFS(grid,i,j,m,n,visited);
               }
           }
       }
       return res;
    }
    void DFS(vector<vector<int>>& grid,int x,int y,const int& m,const int&n,vector<vector<bool>>& visited){
        visited[x][y] = true;
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0 || ny<0 || nx>=m || ny>=n || grid[nx][ny] || visited[nx][ny])
                continue;
            DFS(grid,nx,ny,m,n,visited);
        }
    }
};

LeetCode【329】【矩阵中的最长递增路径】：https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/
class Solution {
public:
    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        m = matrix.size();
        n = matrix[0].size();
        int res = 0;
        vector<vector<int>> memo(m,vector<int>(n,0));
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j)
                res = max(res,DFS(matrix,i,j,memo));
        }
        for(int i = 0;i<m;++i){
            for(int j = 0;j<n;++j)
                cout<<memo[i][j]<<" ";
            cout<<endl;
        }
        return res;
    }
    int DFS(vector<vector<int>>& matrix,int x,int y,vector<vector<int>>& memo){
        if(memo[x][y])
            return memo[x][y];
        ++memo[x][y];
        for(int i = 0;i<4;++i){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if(nx<0||ny<0||nx>=m||ny>=n||matrix[nx][ny]<=matrix[x][y])
                continue;
            memo[x][y] = max(memo[x][y],DFS(matrix,nx,ny,memo)+1);
        }
        return memo[x][y];
    }
    private:
        int n;
        int m;
};

LeetCode【874】【模拟行走机器人】：https://leetcode-cn.com/submissions/detail/174103319/testcase/
class Solution {
public:
    int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};//上右下左--顺时针方向转 
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        int distance = 0;
        int x = 0,y = 0;
        int sz = commands.size();
        int pt = 0;
        set<pair<int, int>> obstacleSet;
        for(int i=0;i<obstacles.size();i++)
            obstacleSet.insert(make_pair(obstacles[i][0], obstacles[i][1]));
        for(int i = 0;i<sz;++i){
            if(commands[i] == -1)
                pt = pt == 3?0:pt+1;
            else if(commands[i] == -2)
                pt = (!pt)?3:pt-1;
            else{
                for(int k = 0;k<commands[i];k++){
                    int nx = x + dir[pt][0];
                    int ny = y + dir[pt][1];
                    if (obstacleSet.find(make_pair(nx, ny)) == obstacleSet.end()) {
                        x = nx;
                        y = ny;
                        distance = max(distance, x*x + y*y);
                    }
                    else
                        break;
                }  
            }
        }
        return distance;
    }
};

LeetCode【LCP03】【机器人大冒险】：https://leetcode-cn.com/problems/programmable-robot/
class Solution {
public:
    bool robot(string command, vector<vector<int>>& obstacles, int x, int y) {
        int n = command.size(), m = obstacles.size(), cX = 0, cY = 0;
        for(int i = 0; i < n; ++i){ // O(n)，统计一个循环需要x和y能走多远
            if(command[i] == 'U') cY++;
            else cX++;
        }
        for(int i = 0; i < m; ++i){ // O(m)，计算每一个障碍物会不会碰到
            int oX = obstacles[i][0], oY = obstacles[i][1];
            if(oX > x || oY > y) continue; // 障碍物在终点之外
            int cnt = min(oX / cX, oY / cY); // 到障碍物至少需要多少个完整循环
            oX -= cnt * cX, oY -= cnt * cY;
            if(oX == 0 && oY == 0) return false; // 刚好cnt个完整循环到障碍物
            for(int j = 0; j < n; ++j){ // O(n)
                if(command[j] == 'U') oY--;
                else oX--;
                if(oX == 0 && oY == 0) return false; // 碰到障碍物
                if(oX < 0 || oY < 0) break; // 碰不到障碍物的情况
            }
        }
        int cycle = min(x/ cX, y / cY); // 到终点至少需要多少个循环
        x -= cycle * cX, y -= cycle * cY;
        if(x == 0 && y == 0) return true; // 刚好cycle个完整循环可以到终点
        for(int i = 0; i < n; ++i){ // O(n)
            if(command[i] == 'U') y--;
            else x--;
            if(x==0 && y == 0) return true; // 能到终点
            if(x < 0 || y < 0) return false; // 不能到终点
        }
        return true;
    }
};